Security : Nebbett's Shuttle
============================

This technique was windows specific and utilises the win32 api as well as internal windows functions to accomplish its purpose. The essence of Nebbett's approach was to launch a process in suspended state. Once in suspeneded state its process memory could be manipulated and overwritten with a new executable. Execuiton of this process is then resumed.

Covertly laucning an executable using Nebbett's Shuttle allows the malicious process to appear as process which it was started as. For example, if one were to use this technique with notepad.exe bein g the process which is started in a suspended state, then overwritten with sol.exe, a game of solitaire would be presented to the user. When the user views their task manager it will appear as though the notepad program is running.

A malware launcher can be crafter which downloads a program from the internet and executes it without leaving any disk residue of this action taking place. With no disk residue a forensic examiner will also be unable to capture the malicious binary for reverse engineering.

A program which uses debugger techniques will launch or attach to a process. If the process is launched by the debugger then a breakpoint will be placed at any entry point. Otherwise, if the debugger attaches to a running process then a breakpoint is placed at the currently executing instruction. When the breakpoint is triggered, control flow of the program belongs to the debugger. The first step taken against the suspended process is to inject a small piece of shellcode at the currently executing memory location whose purpose it is to allocate a small buffer outside of the locaiton occupied by the executables memory image. The final instruction in this shellcode will be a software interrupt (int 3). When the interrupt instruction is executed control will return to the debugger.

The next action performed by the debugger is the injection of a second piece of shellcode. This time the shellcode is inserted into the memory buffer which was just created by the first piece of shellocde. The job of second piece of shellcode is first to unmap the executable image from memory. The reason for this is so that we can place our new executable in its favored location and eliminate some compatibility issues associated with this form of injection. Next the shellcode allocates the amount of memory needed to contain the new executable memory image. It then grows the heap if needed, according to what is required by the new executable. Once again, the final instruction in the shellcode is the sofware interrupt instruction.

After control returns to the debugger it must populate the target process' memory with the new executable image. It will also populate the stack with the appropriate data for the new process and set registers to the values appropriate for a new process. At this point the debugging process may detach itself from the target if necessary as execution is resumed on manipulated process.

A protable mechanism exists for performing debugging operations on most UNIX variants. This interface, the ptrace() system call, provides capablities to attach to a remote process, debug a child process, read and write process memory, manipulate registers and alter signal handlers in the target process. Using the approach of the ptrace() system call to manipulate processes it is possible to achieve other process injection techniques beyond what we have just discussed.
